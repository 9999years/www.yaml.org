<?xml version="1.0"?>
<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook V4.2//EN"
         "file:///usr/local/share/xml/docbook/4.2/docbookx.dtd" [
  <!ENTITY productionsrecap SYSTEM "productionsrecap.dbk">
]>
<!-- <book status="draft"> -->
<book>
  <bookinfo>
    <title>
      YAML Ain't Markup Language (<trademark>YAML</trademark>) 1.0
    </title>

    <subtitle>
      Working Draft 200?-???-??
    </subtitle>

    <authorgroup>
      <author>
        <firstname>Oren</firstname>
        <surname>Ben-Kiki</surname>
        <email>oren@ben-kiki.org</email>
      </author>

      <author>
        <firstname>Clark</firstname>
        <surname>Evans</surname>
        <email>cce@clarkevans.com</email>
      </author>

      <author>
        <firstname>Brian</firstname>
        <surname>Ingerson</surname>
        <email>ingy@ttul.org</email>
      </author>
    </authorgroup>

    <copyright>
      <year>2001-2004</year>
      <holder>Oren Ben-Kiki</holder>
      <holder>Clark Evans</holder>
      <holder>Brian Ingerson</holder>
    </copyright>

    <releaseinfo id="releaseinfo">
      <emphasis>This version:</emphasis>
      <ulink url="http://www.yaml.org/spec/29jan2004.html" /><sbr />
      <emphasis>Latest version:</emphasis>
      <ulink url="http://www.yaml.org/spec" />
    </releaseinfo>

    <legalnotice>
      This document may be freely copied provided it is not modified.
    </legalnotice>

    <abstract>
      <title>Status of this Document</title>

      <para>
        This is an intermediate working draft and is being actively 
        revised. Hopefully the next draft will be a release candidate.
        TODO: Verify indentation computations (there's a +/-1 problem in
        block indentation). review production naming and folding descisions.
        Allow draft to be printed (direct DocBook -> PDF?).
      </para>

      <para>
        We wish to thank implementers who have tirelessly tracked earlier
        versions of this specification, and our fabulous user community
        whose feedback has both validated and clarified our direction.
      </para>
    </abstract>

    <abstract>
      <title>Abstract</title>

      <para>
        <trademark>YAML</trademark> (rhymes with <quote>camel</quote>) is a
        human friendly, cross language, Unicode based data serialization
        language designed around the common native structures of agile
        programming languages. It is broadly useful for programming needs
        ranging from configuration files to Internet messaging to object
        persistence to data auditing. Together with the <ulink
        url="http://www.unicode.org/">Unicode</ulink> standard for
        characters, this specification provides all the information
        necessary to understand YAML Version 1.0 and to construct programs
        that process YAML information.
      </para>
    </abstract>

  </bookinfo>

  <chapter>
    <title><anchor id="intro"/>Introduction</title>

    <para>
      "YAML Ain't Markup Language" (abbreviated YAML) is a data
      serialization language designed to be human friendly and work well
      with modern programming languages for common everyday tasks. This
      specification is both an introduction to the YAML language and the
      concepts supporting it; and also a complete reference of the
      information needed to develop applications for processing YAML.
    </para>

    <para>
      Open, interoperable and readily understandable tools have advanced
      computing immensely. YAML was designed from the start to be useful and
      friendly to the people working with data. It uses printable Unicode
      characters, some of which provide structural information and the rest
      representing the data itself. YAML achieves a unique cleanness by
      minimizing the amount of structural characters, and allowing the data
      to show itself in a natural and meaningful way. For example,
      indentation is used for structure, colons separate pairs, and dashes
      are used for bullet lists.
    </para>

    <para>
      There are myriad flavors of data structures, but they can all be
      adequately represented with three basic primitives: mappings
      (hashes/dictionaries), sequences (arrays/lists) and scalars
      (strings/numbers). YAML leverages these primitives and adds a simple
      typing system and aliasing mechanism to form a complete language for
      encoding any data structure. While most programming languages
      can use YAML for data serialization, YAML excels in those languages
      that are fundamentally built around the three basic primitives. These
      include the new wave of agile languages such as Perl, Python, PHP,
      Ruby and Javascript.
    </para>

    <para>
      There are hundreds of different languages for programming, but only a
      handful of languages for storing and transferring data. Even though its
      potential is virtually boundless, YAML was specifically created to work
      well for common use cases such as: configuration files, log files,
      interprocess messaging, cross-language data sharing, object persistence
      and debugging of complex data structures. When data is well organized
      and easy to understand, programming becomes a simpler task.
    </para>

    <sect1>
      <title><anchor id="intro-goals" />Goals</title>

      <para>
        The design goals for YAML are:
      </para>

      <orderedlist>
        <listitem>
          <para>
            YAML documents are easily readable by humans.
          </para>
        </listitem>
        <listitem>
          <para>
            YAML uses the native data structures of agile languages.
          </para>
        </listitem>
        <listitem>
          <para>
            YAML data is portable between programming languages.
          </para>
        </listitem>
        <listitem>
          <para>
            YAML has a consistent model to support generic tools.
          </para>
        </listitem>
        <listitem>
          <para>
            YAML enables stream-based processing.
          </para>
        </listitem>
        <listitem>
          <para>
            YAML is expressive and extensible.
          </para>
        </listitem>
        <listitem>
          <para>
            YAML is easy to implement and use.
          </para>
        </listitem>
      </orderedlist>
    </sect1>

    <sect1>
      <title><anchor id="intro-prior" />Prior Art</title>

      <para>
        YAML's initial direction was set by the data serialization and markup
        language discussions among <ulink
            url="http://www.docuverse.com/smldev/">SML-DEV</ulink> members.
        Later on it directly incorporated experience from Brian Ingerson's
        Perl module <ulink
            url="http://search.cpan.org/doc/INGY/Data-Denter-0.13/Denter.pod"
        >Data::Denter</ulink>. Since then YAML has matured through ideas
        and support from its user community.
      </para>

      <para>
        YAML integrates and builds upon concepts described by
        <ulink url="http://cm.bell-labs.com/cm/cs/cbook/index.html">C</ulink>,
        <ulink url="http://java.sun.com/">Java</ulink>, <ulink
        url="http://www.perl.org/">Perl</ulink>, <ulink
        url="http://www.python.org/">Python</ulink>, <ulink
        url="http://www.ruby-lang.org/">Ruby</ulink>, <ulink
        url="http://www.ietf.org/rfc/rfc0822.txt">RFC0822</ulink> (MAIL),
        <ulink
        url="http://www.ics.uci.edu/pub/ietf/html/rfc1866.txt">RFC1866</ulink>
        (HTML), <ulink
        url="http://www.ietf.org/rfc/rfc2045.txt">RFC2045</ulink> (MIME),
        <ulink url="http://www.ietf.org/rfc/rfc2396.txt">RFC2396</ulink> (URI),
        <ulink url="http://www.w3.org/TR/REC-xml.html">XML</ulink>,
        <ulink url="http://www.saxproject.org/">SAX</ulink> and <ulink
        url="http://www.w3.org/TR/SOAP">SOAP</ulink>.
      </para>

      <para>
        The syntax of YAML was motivated by Internet Mail (RFC0822) and
        remains partially compatible with that standard. Further, YAML
        borrows the idea of having <link linkend="syntax-document">multiple
        documents</link> from MIME (RFC2045). YAML's top-level production
        is a <link linkend="preview-struct">stream</link> of independent
        documents; ideal for message-based distributed processing
        systems.
      </para>

      <para>
        YAML's indentation based <link linkend="syntax-indent">block
        scoping</link> is similar to Python's (without the ambiguities caused
        by tabs). Indented blocks facilitate easy inspection of a document's
        structure. YAML's <link linkend="syntax-literal">literal</link> scalar
        leverages this by enabling formatted text to be cleanly mixed within an
        indented structure without troublesome escaping.
      </para>

      <para>
        YAML's <link linkend="syntax-double">double quoted</link> scalar uses
        familiar C-style <link linkend="syntax-escape">escape sequences</link>.
        This enables ASCII representation of non-printable or 8-bit (ISO
        8859-1) characters such as <link linkend="ns-esc-8-bit"
        ><quote><userinput>\x3B</userinput></quote></link>. 16-bit Unicode and
        32-bit (ISO/IEC 10646) characters are supported with escape sequences
        such as <link linkend="ns-esc-16-bit"
        ><quote><userinput>\u003B</userinput></quote></link> and <link
        linkend="ns-esc-32-bit"
        ><quote><userinput>\U0000003B</userinput></quote></link>.
      </para>

      <para>
        Motivated by HTML's end-of-line normalization, YAML's <link
        linkend="syntax-folded">folded</link> scalar employs an intuitive
        method of handling white space. In YAML, single line breaks may be
        <link linkend="syntax-fold">folded</link> into a single space, while
        empty lines represent line break characters. This technique allows for
        paragraphs to be word-wrapped without affecting the canonical form of
        the content.
      </para>

      <para>
        YAML's core type system is based on the requirements
        of Perl, Python and Ruby. YAML directly supports both <link
        linkend="preview-collect">collection</link> (<link
        linkend="type-map">hash</link>, <link
        linkend="type-seq">array</link>) values and <link
        linkend="preview-scalar">scalar</link> (<link
        linkend="type-str">string</link>) values. Support for common types
        enables programmers to use their language's native data constructs
        for YAML manipulation, instead of requiring a special document
        object model (DOM).
      </para>

      <para>
        Like XML's SOAP, YAML supports serializing native graph structures
        through a rich <link linkend="model-alias">alias</link>
        mechanism. Also like SOAP, YAML provides for <link
        linkend="model-tag">application-defined types</link>. This
        allows YAML to encode rich data structures required for modern
        distributed computing. YAML provides unique global <link
        linkend="syntax-tag">type names</link> using a namespace
        mechanism inspired by Java's DNS based package naming convention and
        XML's URI based namespaces.
      </para>

      <para>
        YAML was designed to have an incremental interface that includes
        both a pull-style input stream and a push-style (SAX-like) output
        stream interfaces. Together this enables YAML to support the
        processing of large documents, such as a transaction log, or
        continuous streams, such as a feed from a production machine.
      </para>
    </sect1>

    <sect1>
      <title><anchor id="intro-xml" />Relation to XML</title>

      <para>
        Newcomers to YAML often search for its correlation to the eXtensible
        Markup Language (XML). While the two languages may actually compete
        in several application domains, there is no direct correlation
        between them.
      </para>

      <para>
        YAML is primarily a data serialization language. XML was designed to
        be backwards compatible with the Standard Generalized Markup
        Language (SGML) and thus had many design constraints placed on it
        that YAML does not share. Inheriting SGML's legacy, XML is designed
        to support structured documents, where YAML is more closely targeted
        at messaging and native data structures. Where XML is a pioneer in
        many domains, YAML is the result of lessons learned from XML and
        other technologies.
      </para>

      <para>
        It should be mentioned that there are ongoing efforts to define
        standard XML/YAML mappings. This generally requires that a subset of
        each language be used. For more information on using both XML and
        YAML, please visit <ulink url="http://yaml.org/xml/" />.
      </para>
    </sect1>

    <sect1>
      <title><anchor id="intro-term" />Terminology</title>

      <para>
        This specification uses key words in accordance with <ulink
        url="http://www.ietf.org/rfc/rfc2119.txt">RFC2119</ulink> to
        indicate requirement level. In particular, the following words are
        used to describe the actions of a YAML processor:
      </para>

      <variablelist>
        <varlistentry>
          <term>
            <para>
              <firstterm>may</firstterm>
            </para>
          </term>

          <listitem>
            <para>
              This word, or the adjective
              <quote><firstterm>optional</firstterm></quote>, mean that
              conforming YAML processors are permitted, but need not behave as
              described.
          </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              <firstterm>should</firstterm>
            </para>
          </term>

          <listitem>
            <para>
              This word, or the adjective
              <quote><firstterm>recommended</firstterm></quote>, mean that
              there could be reasons for a YAML processor to deviate from
              the behavior described, but that such deviation could hurt
              interoperability and should therefore be advertised with
              appropriate notice.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              <firstterm>must</firstterm>
            </para>
          </term>

          <listitem>
            <para>
              This word, or the term
              <quote><firstterm>required</firstterm></quote> or
              <quote><firstterm>shall</firstterm></quote>, mean that the
              behavior described is an absolute requirement of the
              specification.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="preview" />Preview</title>

    <para>
      This section provides a quick glimpse into the expressive power of
      YAML. It is not expected that the first-time reader grok all of the
      examples. Rather, these selections are used as motivation for the
      remainder of the specification.
    </para>

    <sect1>
      <title><anchor id="preview-collect" />Collections</title>

      <para>
        YAML's block collections use indentation for scope and begin each
        member on its own line. Block sequences indicate each member with a
        dash&nbsp;(<quote><userinput>-</userinput></quote>). Block mappings
        use a colon to mark each (key:&nbsp;value) pair.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Sequence of scalars<sbr />
              (ball players)
            </title>
<programlisting>- Mark McGwire<sbr />
- Sammy Sosa
- Ken Griffey
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Mapping of scalars to scalars<sbr />
              (player statistics)
            </title>
<programlisting>hr:  65<sbr />
avg: 0.278
rbi: 147
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Mapping of scalars to sequences<sbr />
              (ball clubs in each league)
            </title>
<programlisting>american:<sbr />
  - Boston Red Sox
  - Detroit Tigers
  - New York Yankees
national:
  - New York Mets
  - Chicago Cubs
  - Atlanta Braves
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Sequence of mappings<sbr />
              (players' statistics)
            </title>
<programlisting>-<sbr />
  name: Mark McGwire
  hr:   65
  avg:  0.278
-
  name: Sammy Sosa
  hr:   63
  avg:  0.288
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        YAML also has in-line flow styles for compact notation. The flow
        sequence is written as a comma separated list within square
        brackets. In a similar manner, the flow mapping uses curly braces.
        In YAML, the space after the <quote><userinput>-</userinput></quote>
        and <quote><userinput>:</userinput></quote> and
        <quote><userinput>:</userinput></quote> is mandatory.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Sequence of sequences</title>
<programlisting>- [name        , hr, avg  ]<sbr />
- [Mark McGwire, 65, 0.278]
- [Sammy Sosa  , 63, 0.288]


</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Mapping of mappings</title>
<programlisting>Mark McGwire: {hr: 65, avg: 0.278}<sbr />
Sammy Sosa: {
    hr: 63,
    avg: 0.288
  }
</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-struct" />Structures</title>

      <para>
        YAML uses three
        dashes&nbsp;(<quote><userinput>---</userinput></quote>) to separate
        documents within a stream. Comment lines begin with the Octothorpe
        (usually called the <quote>hash</quote> or <quote>pound</quote> sign -
        <quote><userinput>#</userinput></quote>). Three
        dots&nbsp;(<quote><userinput>...</userinput></quote>) indicate the end
        of a document without starting a new one, for use in communication
        channels.
      </para>

      <para>
        Repeated nodes are first marked with the
        ampersand&nbsp;(<quote><userinput>&amp;</userinput></quote>) and
        then referenced with an
        asterisk&nbsp;(<quote><userinput>*</userinput></quote>) thereafter.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Two documents in a stream<sbr />
              each with a leading comment
            </title>
<programlisting># Ranking of 1998 home runs<sbr />
---
- Mark McGwire
- Sammy Sosa
- Ken Griffey

# Team ranking
---
- Chicago Cubs
- St Louis Cardinals
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Play by play feed<sbr />
              from a game
            </title>
<programlisting>---<sbr />
time: 20:03:20
player: Sammy Sosa
action: strike (miss)
...
---
time: 20:03:47
player: Sammy Sosa
action: grand slam
...
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Single document with two<sbr />
              throwaway comments
            </title>
<programlisting>---<sbr />
hr: # 1998 hr ranking
  - Mark McGwire
  - Sammy Sosa
rbi:
  # 1998 rbi ranking
  - Sammy Sosa
  - Ken Griffey
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Node for <quote><userinput>Sammy Sosa</userinput></quote><sbr />
              appears twice in this document
            </title>
<programlisting>---<sbr />
hr:
  - Mark McGwire
  # Following node labeled SS
  - &amp;SS Sammy Sosa
rbi:
  - *SS # Subsequent occurrence
  - Ken Griffey
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        The question mark indicates a complex key. Within a block sequence,
        mapping pairs can start immediately following the dash.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Mapping between sequences</title>
<programlisting>? # PLAY SCHEDULE<sbr />
  - Detroit Tigers
  - Chicago Cubs
:
  - 2001-07-23

? [ New York Yankees,
    Atlanta Braves ]
: [ 2001-07-02, 2001-08-12,
    2001-08-14 ]
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Sequence key shortcut</title>
<programlisting>---<sbr />
# products purchased
- item    : Super Hoop
  quantity: 1
- item    : Basketball
  quantity: 4
- item    : Big Shoes
  quantity: 1


</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-scalar" />Scalars</title>

      <para>
        Scalar values can be written in block form using a literal
        style&nbsp;(<quote><userinput>|</userinput></quote>) where all new
        lines count. Or they can be written with the folded
        style&nbsp;(<quote><userinput>&gt;</userinput></quote>) for content
        that can be word wrapped. In the folded style, newlines are treated as
        a space unless they are part of a blank or indented line.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              In literals,<sbr />
              newlines are preserved
            </title>
<programlisting># ASCII Art<sbr />
--- |
  \//||\/||
  // ||  ||__
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              In the plain scalar,<sbr />
              newlines are treated as a space
            </title>
<programlisting>---<sbr />
  Mark McGwire's
  year was crippled
  by a knee injury.
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Folded newlines preserved<sbr />
              for indented and blank lines
            </title>
<programlisting>--- &gt;<sbr />
 Sammy Sosa completed another
 fine season with great stats.

   63 Home Runs
   0.288 Batting Average

 What a year!
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Indentation determines scope<sbr />
              &nbsp;
            </title>
<programlisting>name: Mark McGwire<sbr />
accomplishment: &gt;
  Mark set a major league
  home run record in 1998.
stats: |
  65 Home Runs
  0.278 Batting Average

</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        YAML's flow scalars include the plain style (most examples thus far)
        and quoted styles. The double quoted style provides escape sequences.
        Single quoted style is useful when escaping is not needed. All flow
        scalars can span multiple lines; intermediate whitespace is trimmed to
        a single space.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Quoted scalars</title>
<programlisting>unicode: "Sosa did fine.\u263A"<sbr />
control: "\b1998\t1999\t2000\n"
hexesc:  "\x13\x10 is \r\n"

single: '"Howdy!" he cried.'
quoted: ' # not a ''comment''.'
tie-fighter: '|\-*-/|'
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Multi-line flow scalars</title>
<programlisting>plain:<sbr />
  This unquoted scalar
  spans many lines.

quoted: "So does this
  quoted scalar.\n"

</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-tag" />Tags</title>

      <para>
        In YAML, plain (unquoted) scalars are given an implicit type
        depending on the application.
        
        
        
        The examples in this specification use
        types from YAML's <link linkend="tag-repository">tag
        repository</link>, which includes types like integers, floating point
        values, timestamps, null, boolean, and string values.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Integers</title>
<programlisting>canonical: 12345<sbr />
decimal: +12,345
sexagecimal: 3:25:45
octal: 014
hexadecimal: 0xC

</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Floating point</title>
<programlisting>canonical: 1.23015e+3<sbr />
exponential: 12.3015e+02
sexagecimal: 20:30.15
fixed: 1,230.15
negative infinity: (-inf)
not a number: (NaN)
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Miscellaneous</title>
<programlisting>null: ~<sbr />
true: y
false: n
string: '12345'
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Timestamps</title>
<programlisting>canonical: 2001-12-15T02:59:43.1Z<sbr />
iso8601:  2001-12-14t21:59:43.10-05:00
spaced:  2001-12-14 21:59:43.10 -05:00
date:   2002-12-14
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        Explicit typing is denoted with a tag using the exclamantion point
        (<quote><userinput>!</userinput></quote>) symbol. Application tags
        should include a domain name and may use the
        caret&nbsp;(<quote><userinput>^</userinput></quote>) to abbreviate
        subsequent tags. 
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Various explicit tags</title>
<programlisting>---<sbr />
not-date: !str 2002-04-28

picture: !binary |
 R0lGODlhDAAMAIQAAP//9/X
 17unp5WZmZgAAAOfn515eXv
 Pz7Y6OjuDg4J+fn5OTk6enp
 56enmleECcgggoBADs=

application specific tag: !!something |
 The semantics of the tag
 above may be different for
 different documents.

</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Application specific tag</title>
<programlisting># Establish a tag prefix<sbr />
--- !clarkevans.com,2002/graph/^shape
  # Use the prefix: shorthand for
  # !clarkevans.com,2002/graph/circle
- !^circle
  center: &amp;ORIGIN {x: 73, y: 129}
  radius: 7
- !^line
  start: *ORIGIN
  finish: { x: 89, y: 102 }
- !^label
  start: *ORIGIN
  color: 0xFFEEBB
  text: Pretty vector drawing.
</programlisting>
          </example>
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Unordered set</title>
<programlisting># sets are represented as a<sbr />
# mapping where each key is
# associated with the empty string
--- !set
? Mark McGwire
? Sammy Sosa
? Ken Griff
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Ordered mappings</title>
<programlisting># ordered maps are represented as<sbr />
# a sequence of mappings, with
# each mapping having one key
--- !omap
- Mark McGwire: 65
- Sammy Sosa: 63
- Ken Griffy: 58
</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-full" />Full Length Example</title>

      <para>
        Below are two full-length examples of YAML. On the left is a sample
        invoice; on the right is a sample log file.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Invoice</title>
<programlisting>--- !clarkevans.com,2002/^invoice<sbr />
invoice: 34843
date   : 2001-01-23
bill-to: &amp;id001
    given  : Chris
    family : Dumars
    address:
        lines: |
            458 Walkman Dr.
            Suite #292
        city    : Royal Oak
        state   : MI
        postal  : 48046
ship-to: *id001
product:
    - sku         : BL394D
      quantity    : 4
      description : Basketball
      price       : 450.00
    - sku         : BL4438H
      quantity    : 1
      description : Super Hoop
      price       : 2392.00
tax  : 251.42
total: 4443.52
comments:
    Late afternoon is best.
    Backup contact is Nancy
    Billsmer @ 338-4338.
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Log file</title>
<programlisting>---<sbr />
Time: 2001-11-23 15:01:42 -05:00
User: ed
Warning:
  This is an error message
  for the log file
---
Time: 2001-11-23 15:02:31 -05:00
User: ed
Warning:
  A slightly different error
  message.
---
Date: 2001-11-23 15:03:17 -05:00
User: ed
Fatal:
  Unknown variable "bar"
Stack:
  - file: TopClass.py
    line: 23
    code: |
      x = MoreObject("345\n")
  - file: MoreClass.py
    line: 58
    code: |-
      foo = bar



</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="model" />Processing YAML Information</title>

    <para>
      YAML is both a text format and a method for representing native
      language data structures in this format. This specification defines
      two concepts: a class of data objects called YAML representations, and
      a syntax for encoding YAML representations as a series of
      characters, called a YAML stream. A YAML
      <firstterm>processor</firstterm> is a tool for converting information
      between these complementary views. It is assumed that a YAML processor
      does its work on behalf of another module, called an
      <firstterm>application</firstterm>. This chapter describes the
      information structures a processor must provide to or obtain from the
      application.
    </para>

    <para>
      YAML information is used in two ways: for machine processing, and
      for human consumption. The challenge of reconciling these two
      perspectives is best done in three distinct translation stages:
      representation, serialization, and presentation. Representation
      addresses how YAML views native language data structures to achieve
      portability between programming environments. Serialization
      concerns itself with turning a YAML representation into a serial
      form, that is, a form with sequential access constraints.
      Presentation deals with the formatting of a YAML serialization as a
      stream of characters, in a manner friendly to humans.
    </para>

    <figure>
      <title>YAML Overview</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="overview2.eps" format="eps" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>
      A processor need not expose the serialization or representation
      stages. It may translate directly between native objects and
      a character stream and (<quote>dump</quote> and <quote>load</quote>
      in the diagram above). However, such a direct translation should
      take place so that the native objects are constructed only from
      information available in the representation.
    </para>

    <sect1>
      <title><anchor id="model-processes" />Processes</title>

      <para>
        This section details the processes shown in the 
        diagram above.
      </para>

      <sect2>
        <title><anchor id="model-processes-represent" />Represent</title>

        <para>
          YAML representations model the data constructs from agile
          programming languages, such as Perl, Python, or Ruby. YAML
          representations view native language data objects in a generic
          manner, allowing data to be portable between various programming
          languages and implementations. Strings, arrays, hashes, and other
          user-defined types are supported. This specification formalizes
          what it means to be a YAML representation and suggests how
          native language objects can be viewed as a YAML representation.
        </para>

        <para>
          YAML representations are constructed with three primitives: the
          <link linkend="model-sequence">sequence</link>, the <link
          linkend="model-mapping">mapping</link> and the <link
          linkend="model-scalar">scalar</link>. By sequence we mean
          an ordered collection, by mapping we mean an unordered association
          of unique keys to values, and by scalar we mean any object with
          opaque structure yet expressible as a series of Unicode
          characters. When used generatively, these primitives construct
          directed graph structures. These primitives were chosen because
          they are both powerful and familiar: the sequence corresponds to a
          Perl array and a Python list, the mapping corresponds to a Perl
          hash table and a Python dictionary. The scalar represents strings,
          integers, dates and other atomic data types.
        </para>

        <para>
          YAML represents any native language data object as one of these
          three primitives, together with a type specifier called a
          <firstterm>tag</firstterm>. Type specifiers are either global,
          using a syntax based on the domain name and registration date, or
          private in scope. For example, an integer is represented in YAML
          with a scalar plus a globally scoped
          <userinput>tag:yaml.org,2002/int</userinput> tag. Similarly, an
          invoice object, particular to a given organization, could be
          represented as a mapping together with a
          <userinput>tag:private.yaml.org,2002:invoice</userinput> tag. This
          simple model, based on the sequence and mapping and scalar
          together with a type specifier, can represent any data structure
          independent of programming language.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-serialize" />Serialize</title>

        <para>
          For sequential access mediums, such as an
          event callback API, a YAML representation must be serialized to an
          ordered tree. Serialization is necessary since nodes in a YAML
          representation may be referenced more than once (more than one
          incoming arrow) and since mapping keys are unordered. Serialization
          is accomplished by imposing an ordering on mapping keys and by
          replacing the second and subsequent references to a given node with
          place holders called aliases. The result of this process, the YAML
          serialization tree, can then be traversed to produce a series of
          event calls for one-pass processing of YAML data.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-present" />Present</title>

        <para>
          YAML <firstterm>character streams</firstterm> (or documents)
          encode YAML representations into a series of characters. Some of
          the characters in a YAML stream represent the content of the
          source information, while other characters are used for
          presentation style. Not only must YAML character streams store
          YAML representations, they must do so in a manner which is human
          friendly.
        </para>

        <para>
          To address human presentation, the YAML syntax has a rich set of
          stylistic options which go far beyond the needs of data
          serialization. YAML has two approaches for expressing a node's
          nesting, one that uses indentation to designate depth in the
          serialization tree and another which uses begin and end
          delimiters. Depending upon escaping and how line breaks should be
          treated, YAML scalars may be written with many different styles.
          YAML syntax also has a comment mechanism for annotations orthogonal
          to the <quote>content</quote> of a YAML representation. These
          presentation level details provide sufficient variety of
          expression.
        </para>

        <para>
          In a similar manner, for human readable text, it is frequently
          desirable to omit data typing information which is often obvious
          to the human reader and not needed. This is especially true if the
          information is created by hand, expecting humans to bother with
          data typing detail is optimistic. Implicit type information may be
          restored using a data schema or similar mechanisms.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-parse" />Parse</title>

        <para>
          Parsing is the inverse process of presentation, it takes
          a stream of characters and produces a series of events.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-compose" />Compose</title>

        <para>
          Composing takes a series of events and produces a node graph
          representation. See <link
          linkend="model-complete">completeness</link> for more detail
          on the constraints composition must follow. When composing,
          one must deal with broken aliases and anchors, and other
          things of this sort.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-construct" />Construct</title>

        <para>
          Construction converts construct YAML representations into native
          language objects.
        </para>
      </sect2>

    </sect1>

    <sect1>
      <title><anchor id="model-models" />Information Models</title>

      <para>
        This section has the formal details of the results of
        the processes.
      </para>

      <figure>
        <title>YAML Information Models</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="model2.eps" format="eps" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        To maximize data portability between programming languages and
        implementations, users of YAML should be mindful of the distinction
        between serialization or presentation properties and those which are
        part of the YAML representation. While imposing a order on mapping
        keys is necessary for flattening YAML representations to a
        sequential access medium, the specific ordering of a mapping should
        not be used to convey application level information. In a similar
        manner, while indentation technique or the specific scalar style is
        needed for character level human presentation, this syntax detail is
        not part of a YAML serialization nor a YAML representation. By
        carefully separating properties needed for serialization and
        presentation, YAML representations of native language information
        will be consistent and portable between various programming
        environments.
      </para>

      <sect2>
        <title><anchor id="model-representation" />Node Graph
        Representation</title>

        <para>
          In YAML's view, native data is represented as a directed
          graph of <link linkend="model-tag">tagged</link> <link
          linkend="model-node">nodes</link>. Nodes that are defined in
          terms of other nodes are <link
          linkend="model-collection">collections</link> and nodes that are
          defined independent of any other nodes are <link
          linkend="model-scalar">scalars</link>. YAML supports two
          kinds of collection nodes, <link
          linkend="model-sequence">sequence</link> and <link
          linkend="model-mapping">mappings</link>. Mapping nodes
          are somewhat tricky because its keys are considered to be unordered
          and <link linkend="model-equality">unique</link>.
        </para>

        <figure>
          <title>YAML Representation</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="represent2.eps" format="eps" />
            </imageobject>
          </mediaobject>
        </figure>

        <sect3>
          <title><anchor id="model-node" />Nodes</title>
          <para>
            A YAML representation is a rooted, connected, directed graph. By
            <quote>directed graph</quote> we mean a set of nodes and arrows,
            where arrows connect one node to another (<ulink
            url="http://www.nist.gov/dads/HTML/directedgraph.html"> a formal
            definition </ulink>). Note that the YAML graph may include cycles,
            and a node may have more than one incoming arrow.
         </para>

          <para>
            YAML nodes have a <link linkend="model-tag">tag</link> and
            can be of one of three kinds: scalar, sequence, or mapping. The
            node's tag serves to restrict the set of possible values
            which the node can have.
          </para>

          <variablelist>
            <varlistentry>
              <term>
                <anchor id="model-scalar" />
                <firstterm>scalar</firstterm>
              </term>
              <listitem>
                <para>
                  A scalar is a series of zero or more Unicode characters.
                  YAML places no restriction on the length or content of the
                  series.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <anchor id="model-sequence" />
                <firstterm>sequence</firstterm>
              </term>
              <listitem>
                <para>
                  A sequence is a series of zero or more nodes. In particular,
                  a sequence may contain the same node more than once or it
                  could even contain itself (directly or indirectly).
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <anchor id="model-mapping" />
                <firstterm>mapping</firstterm>
              </term>
              <listitem>
                <para>
                  A mapping is an unordered set of key/value node pairs, with
                  the restriction that each of the keys is unique. This
                  restriction has non-trivial implications detailed
                  <link linkend="model-equality">below</link>.
                  YAML places no further restrictions on the nodes. In
                  particular, keys may be arbitrary nodes, the same node may
                  be used as a value in several pairs, and a mapping could
                  even contain itself as a key or a value (directly or
                  indirectly).
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>
            <anchor id="model-collection" />When appropriate, it is convenient
            to consider sequences and mappings together, as a
            <firstterm>collection</firstterm>. In this view, sequences are
            treated as mappings with integer keys starting at zero. Having a
            unified collections view for sequences and mappings is helpful for
            both constructing practical YAML tools and APIs and for
            theoretical analysis.
          </para>

          <para>
            YAML allows several representations to be encoded
            to the same character stream. Representations appearing in the
            same character stream are independent. That is, a given node may
            not appear in more than one representation graph.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-tag" />Tags</title>

          <para>
            YAML represents type information of native objects with a simple
            identifier, called a <firstterm>tag</firstterm>. These identifiers
            are <ulink url="http://www.ietf.org/rfc/rfc2396.txt">URIs</ulink>,
            using a subset of the <quote><userinput>tag</userinput></quote>
            URI scheme. YAML tags use only the domain based form,
            <userinput>tag:</userinput><varname>domain</varname><userinput
            >,</userinput><varname>date</varname><userinput>:</userinput
            ><varname>identifier</varname>,
            for example, <userinput>tag:yaml.org,2002:str</userinput>. YAML
            presentations provide several <link
            linkend="syntax-tag">mechanisms</link> to make this less
            verbose. Tags may be minted by those who own the domain at the
            specified date. The day must be omitted if it is the 1st of the
            month, and the month and day must be omitted for January 1st.
            The year is never omitted. Thus, each YAML tag has a single
            globally unique representation. More information on this URI
            scheme can be found at <ulink url="http://www.taguri.org"/>
            (<ulink url="http://yaml.org/spec/taguri.txt">mirror</ulink>).
          </para>

          <para>
            <anchor id="model-private"/>YAML tags can be either globally
            unique, or private to a single representation graph. Private tags
            start with <userinput>tag:private.yaml.org,2002:</userinput>.
            Clearly private tags are not globally unique, since the domain
            name and the date are fixed.
          </para>

          <para>
            YAML does not mandate any special relationship between different
            tags that begin with the same substring. Tags ending URI fragments
            (containing <quote><userinput>#</userinput></quote>) are no
            exception. Tags that share the same base URI but differ in their
            fragment part are considered to be different, independent tags. By
            convention, fragments are used to identify different
            <quote>versions</quote> of a tag, while
            <quote><userinput>/</userinput></quote> is used to define nested
            tag <quote>namespace</quote> hierarchies. However, this is merely
            a convention, and each tag may employ its own rules.
            For example,
            <userinput>tag:perl.yaml.org,2002:</userinput> tags
            use <quote><userinput>::</userinput></quote> to express namespace
            hierarchies,
            <userinput>tag:java.yaml.org,2002:</userinput> tags
            use <quote><userinput>.</userinput></quote>, etc.
          </para>

          <para>
            YAML tags are used to associate meta information with each node.
            In particular, each tag is required to specify a the <link
            linkend="model-node">kind</link> (scalar, sequence, or mapping)
            it applies to. Scalar tags must also provide mechanism for
            converting values to a <link linkend="model-canonical">canonical
            form</link> for supporting <link
            linkend="model-equality">equality testing</link>. Furthermore, a
            tag may provide additional information such as the set of
            allowed values for validation, a mechanism for <link
            linkend="model-resolve">implicit typing</link>, or any other
            data that is applicable to all of the tag's nodes.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-equality" />Equality</title>

          <para>
            Since YAML mappings require key uniqueness, representations must
            include a mechanism for testing the equality of nodes. This is
            non-trivial since YAML <link
            linkend="model-presentation">presentations</link> allow various
            ways to write a given <link linkend="model-scalar">scalar</link>.
            For example, the integer ten can be written as
            <userinput>10</userinput> or <userinput>0xA</userinput> (hex). If
            both forms are used as a key in the same mapping, only a YAML
            processor which <quote>knows</quote> about integer tags and their
            presentation formats would correctly flag the duplicate key
            as an error.
          </para>

          <variablelist>
            <varlistentry>
              <term>
                <anchor id="model-canonical" />
                <firstterm>canonical form</firstterm>
              </term>
              <listitem>
                <para>
                  YAML supports the need for scalar equality by requiring that
                  every scalar <link linkend="model-tag">tag</link> have a
                  mechanism to produce a canonical form
                  of its scalars. By canonical form, we mean a Unicode
                  character string which represents the scalar's content and
                  can be used for equality testing. While this requirement is
                  stronger than a well defined equality operator, it has other
                  uses, such as the production of digital signatures.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <anchor id="model-equal" />
                <firstterm>equality</firstterm>
              </term>
              <listitem>
                <para>
                   Two nodes must have the same <link
                   linkend="model-tag">tag</link> and value to be equal. Since
                   each tag applies to exactly one kind, this implies that the
                   two nodes must have the same kind to be equal. Two <link
                   linkend="model-scalar">scalar</link> nodes are equal only
                   when their <link linkend="model-canonical">canonical</link>
                   values are character-by-character equivalent. Equality of
                   <link linkend="model-collection">collections</link> is
                   defined recursively. Two <link
                   linkend="model-sequence">sequences</link> are equal only
                   when they have the same length and each node in one
                   sequence is equal to the corresponding node in the other
                   sequence. Two <link linkend="model-mapping">mappings</link>
                   are equal only when they have equal sets of keys, and each
                   key in this set is associated with equal values in both
                   mappings.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <anchor id="model-identity" />
                <firstterm>identity</firstterm>
              </term>
              <listitem>
                <para>
                  Node equality should not be confused with node
                  <firstterm>identity</firstterm>. Two nodes are identical
                  only when they represent the same native object. Typically,
                  this corresponds to a single memory address. During
                  <ulink linkend="model-serialize">serialization</ulink>, equal
                  scalar nodes may be treated as if they were identical. In
                  contrast, the separate identity of two distinct, but equal,
                  collection nodes must be preserved.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="model-serialize" />Event Tree Serialization</title>

        <para>
          To express a YAML representation using a serial API, it necessary to
          impose an order on mapping keys and employ alias nodes to indicate a
          subsequent occurrence of a previously encountered node. The result of
          this serialization process is a tree structure, where each branch
          has an ordered set of children. This tree can be traversed for a
          serial event based API. Construction of native structures from the
          serial interface should not use key order or anchors for the
          preservation of important data.
        </para>

        <figure>
          <title>YAML Serialization</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="serialize2.eps" format="eps" />
            </imageobject>
          </mediaobject>
        </figure>

        <sect3>
          <title><anchor id="model-key-order" />Key Order</title>

          <para>
            In the representation model, keys in a
            <link linkend="model-mapping">mapping</link> do not have order.
            To serialize a mapping, it is necessary to impose an ordering on
            its keys. This order should not be used when composing a
            representation graph from serialized events.
          </para>

          <para>
            In every case where node order is significant, a sequence must be
            used. For example, an ordered mapping can be represented by a
            sequence of mappings, where each mapping is a single key/value
            pair. YAML presentations provide convenient shorthand syntax
            for this case.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-alias" />Anchors and Aliases</title>

          <para>
            In the representation model, a node may appear in more than one
            collection. When serializing such nodes, the first occurrence of
            the node is serialized with an <firstterm>anchor</firstterm> and
            subsequent occurrences are serialized as an
            <firstterm>alias</firstterm> which specifies the same anchor.
            Anchors need not be unique within a serialization. When composing a
            representation graph from serialized events, alias nodes refer to
            the most recent node in the serialization having the specified
            anchor.
          </para>

          <para>
            An anchored node need not have an alias referring to it. It is
            therefore possible to provide an anchor for all nodes in
            serialization. After composing a representation graph, the
            anchors are discarded. Hence, anchors must not be used for
            encoding application data.
          </para>
        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="model-presentation" />Character Stream
        Presentation</title>

        <para>
          YAML presentations make use of styles, comments, directives and
          other syntactical details. Although the processor may provide this
          information, these features should not be used when constructing
          native structures.
        </para>

        <figure>
          <title>YAML Presentation</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="present2.eps" format="eps" />
            </imageobject>
          </mediaobject>
        </figure>

        <sect3>
          <title><anchor id="model-style" />Node Styles</title>

          <para>
            In the syntax, each node has an additional
            <firstterm>style</firstterm> property, depending on its <link
            linkend="model-node">node</link>. There are two types of styles,
            <firstterm>block</firstterm> and <firstterm>flow</firstterm>.
            Block styles use indentation to denote nesting and scope within
            the presentation. In contrast, flow styles rely on explicit
            markers to denote nesting and scope.
          </para>

          <para>
            YAML provides several shorthand forms for collection styles,
            allowing for compact nesting of collections in common cases. For
            compact set notation, null mapping values may be omitted. For
            compact ordered mapping notation, a mapping with a single
            key:&nbsp;value pair may be specified directly inside a flow
            sequence collection. Also, simple block collections may begin
            in-line rather than the next line.
          </para>

          <para>
            YAML provides a rich set of scalar style variants. Scalar block
            styles include the literal and folded styles; scalar flow styles
            include the plain, single quoted and double quoted styles. These
            styles offer a range of trade-offs between expressive power and
            readability.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-comment" />Throwaway Comments</title>

          <para>
            The syntax allows optional <firstterm>comment</firstterm> blocks
            to be interleaved with the node blocks. Comment blocks may appear
            before or after any node block. A comment block can't appear
            inside a scalar node value.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-directive" />Document Directives</title>

          <para>
            Each document may be associated with a set of directives. A
            <firstterm>directive</firstterm> is a key:&nbsp;value pair where
            both the key and the value are simple strings. Directives are
            instructions to the YAML processor, allowing for extending YAML in
            the future. This version of YAML defines a single directive,
            <quote><userinput>YAML</userinput></quote>. Additional directives
            may be added in future versions of YAML. A processor should ignore
            unknown directives with an appropriate warning. There is no
            provision for specifying private directives. This is intentional.
          </para>

          <para>
            The <quote><userinput>YAML</userinput></quote> directive specifies
            the version of YAML the document adheres to. This specification
            defines version <userinput>1.0</userinput>. A version 1.0
            processor should accept documents with an explicit
            <quote><userinput>%YAML:1.0</userinput></quote> directive, as well
            as documents lacking a <quote><userinput>YAML</userinput></quote>
            directive. Documents with a directive specifying a higher minor
            version (e.g. <quote><userinput>%YAML:1.1</userinput></quote>)
            should be processed with an appropriate warning. Documents with a
            directive specifying a higher major version (e.g.
            <quote><userinput>%YAML:2.0</userinput></quote>) should be
            rejected with an appropriate error message.
          </para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="model-complete"/>Completeness</title>

      <para>
        The process of converting YAML information from a character
        stream presentation to a native data structure has several
        potential failure points. The character stream may be ill-formed,
        implicit tags may be unresolvable, tags may be unrecognized,
        the content may be invalid, and a native type may be unavailable.
        Each of these failures results with an incomplete conversion.
      </para>

      <para><anchor id="model-partial" />
        A <firstterm>partial representation</firstterm> need not specify the
        tag of each node, and the canonical form of scalar values need not
        be available. This weaker representation is useful for cases of
        incomplete knowledge of tags used in the document.
      </para>

      <figure>
        <title>YAML Completeness</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="validity2.eps" format="eps" />
          </imageobject>
        </mediaobject>
      </figure>

      <sect2>
        <title><anchor id="model-well-formed" />Well-Formed</title>
        <para>
          A <firstterm>well-formed</firstterm> character stream must match
          the productions specified in the next chapter. A YAML processor
          should reject <firstterm>ill-formed</firstterm> input. A
          processor may recover from syntax errors, but it must provide a
          mechanism for reporting such errors.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-resolve" />Resolved</title>

        <para>
          It is not required that all tags in a complete YAML representation
          be explicitly specified in the character stream presentation. In
          this case, these <firstterm>implicit tags</firstterm> must be
          <firstterm>resolved</firstterm>.
        </para>

        <para>
          When resolving tags, a YAML processor must only rely upon
          representation details, with one notable exception. It may
          consider whether a scalar was written in the plain style when
          resolving the scalar's tag. Other than this exception, the
          processor must not rely upon presentation or serialization
          details. In particular, it must not consider key order, anchors,
          styles, spacing, indentation or comments.
        </para>

        <para>
          The plain scalar style exception allows unquoted values to signify
          numbers, dates, or other typed data, while quoted values are
          treated as generic strings. With this exception, a processor may
          match plain scalars against a set of regular expressions, to
          provide automatic resolution of such types without an explicit tag.
        </para>

        <para>
          If a document contains <firstterm>unresolved</firstterm> nodes,
          the processor is unable to compose a complete representation
          graph. However, the processor may compose an <link
          linkend="model-partial">partial representation</link>, based on
          each node's <link linkend="model-node">kind</link> (mapping,
          sequence, scalar) and allowing for unresolved tags.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-recognized" />
               <anchor id="model-valid" />Recognized and Valid</title>

        <para>
          To be <firstterm>valid</firstterm>, a node must have a tag which
          is <firstterm>recognized</firstterm> by the processor and its
          value must satisfy the constraints imposed by its tag. If a
          document contains a scalar node with an
          <firstterm>unrecognized</firstterm> tag or an
          <firstterm>invalid</firstterm> value, only a <link
          linkend="model-partial">partial representation</link> may be
          composed. In contrast, a processor can always compose a complete
          YAML representation for an unrecognized or an invalid collection,
          since collection <link linkend="model-equality">equality</link>
          does not depend upon the collection's data type.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-available"/>Available</title>
        <para>
          In a given processing environment, there may not be an
          <firstterm>available</firstterm> native type corresponding to a
          given tag. If a node's tag is <firstterm>unavailable</firstterm>,
          a YAML processor will not be able to construct a native data
          structure for it. In this case, a complete YAML representation may
          still be composed, and an application may wish to use this
          representation directly.
        </para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="syntax" />Syntax</title>

    <para>
      Following are the BNF productions defining the syntax of YAML
      character streams. The productions introduce the relevant character
      classes, describe the processing of white space, and then follow
      with the decomposition of the stream into logical chunks. To make
      this chapter easier to follow, production names use Hungarian-style
      notation:
    </para>

    <variablelist>
      <varlistentry>
        <term>
          <para>
            <userinput>c-</userinput>
          </para>
        </term>

        <listitem>
          <para>
            a production matching one or more characters starting and ending
            with a special character
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <para>
            <userinput>b-</userinput>
          </para>
        </term>

        <listitem>
          <para>
            a production matching a single line break
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <para>
            <userinput>nb-</userinput>
          </para>
        </term>

        <listitem>
          <para>
            a production matching one or more characters starting and ending
            with a non-break character
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <para>
            <userinput>s-</userinput>
          </para>
        </term>

        <listitem>
          <para>
            a production matching one or more characters starting and ending
            with a space character
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <para>
            <userinput>ns-</userinput>
          </para>
        </term>

        <listitem>
          <para>
            a production matching one or more characters starting and ending
            with a non-space character
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <para>
            <varname>X</varname><userinput>-</userinput
              ><varname>Y</varname><userinput>-</userinput>
          </para>
        </term>

        <listitem>
          <para>
            a production matching a sequence of one or more characters,
            starting with an <varname>X</varname><userinput>-</userinput>
            character and ending with a
            <varname>Y</varname><userinput>-</userinput> character
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <para>
            <userinput>l-</userinput>
          </para>
        </term>

        <listitem>
          <para>
            a production matching one or more lines (shorthand for
            <userinput>i-b-</userinput>)
          </para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>
      Productions are generally introduced in a "bottom-up" order; more basic
      productions are specified before the more complex productions using them.
      Examples accompanying the productions list sample YAML text side-by-side
      with equivalent YAML text using only flow collections and double-quoted
      scalars. All implicit tags are resolved assuming the use of the
      <userinput>!map</userinput>, <userinput>!seq</userinput>,
      <userinput>!str</userinput> and <userinput>!int</userinput> tags.
    </para>

    <sect1>
      <title><anchor id="syntax-char" />Characters</title>

      <sect2>
        <title><anchor id="syntax-char-set" />Character Set</title>

        <para>
          YAML streams use a subset of the Unicode character set. On input,
          a YAML processor must accept all printable ASCII characters, the
          space, tab, line break, and all Unicode characters beyond 0x9F. On
          output, a YAML processor must only produce those acceptable
          characters, and should also <link
          linkend="syntax-escape">escape</link> all non-printable Unicode
          characters.
        </para>

        <para>
          The allowed character range explicitly excludes the surrogate
          block <userinput>[#xD800-#xDFFF]</userinput>, DEL
          <userinput>0x7F</userinput>, the C0 control block
          <userinput>[#x0-#x1F]</userinput>, the C1 control block
          <userinput>[#x80-#x9F]</userinput>, <userinput>#xFFFE</userinput>
          and <userinput>#xFFFF</userinput>. Note that in UTF-16, characters
          above <userinput>#xFFFF</userinput> are represented with a
          surrogate pair. When present, DEL and characters in the C0 and C1
          control block must be represented in a YAML stream using escape
          sequences.
        </para>

        <productionset>
          <production id="c-printable">
            <lhs>c-printable</lhs>
            <rhs>
              &nbsp;&nbsp;#x9 | #xA | #xD<sbr />
              | [#x20-#x7E] | #x85<sbr />
              | [#xA0-#xD7FF]<sbr />
              | [#xE000-#xFFFD]<sbr />
              | [#x10000-#x10FFFF]
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-encode" />Character Encoding</title>

        <para>
          A YAML processor must support the UTF-16 and UTF-8 character
          encodings.  If an input stream does not begin with a <link
          linkend="c-byte-order-mark">byte order mark</link>, the encoding
          shall be UTF-8.  Otherwise it shall be UTF-16 (LE or BE), as
          signaled by the byte order mark. Since YAML files may only contain
          printable characters, this does not raise any ambiguities. For
          more information about the byte order mark and the Unicode
          character encoding schemes see the Unicode <ulink
          url="http://www.unicode.org/unicode/faq/utf_bom.html">FAQ</ulink>.
        </para>

        <productionset>
          <production id="c-byte-order-mark">
            <lhs>c-byte-order-mark</lhs>
            <rhs>
              #xFEFF
            </rhs>
          </production>
        </productionset>

        <para>
          In the examples, byte order mark characters are represented as
          <quote><userinput>&hArr;</userinput></quote>.  Note that in the
          interest of simplicity, a byte order mark should only appear for
          UTF16 encoding and that UTF32 is explicitly not supported.
        </para>

        <example>
          <title>Byte Order Mark</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>&hArr;</hl1><sbr />
# Legend:
#   <hl1><link linkend="c-byte-order-mark">c-byte-order-mark</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting># The stream contains<sbr />
# no document, only
# a prefix.
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-indicator" />Indicator Characters</title>

        <para>
          Indicators are characters that have special semantics used to
          describe the structure and content of a YAML document. Indicators can
          be separated into two groups: <link
          linkend="c-top-indicators">Top</link> indicators denote the structure
          of the character stream, while <link
          linkend="c-sub-indicators">sub</link> indicators only have special
          semantics in the context of a particular structure.
        </para>
          
        <productionset>
          <production id="c-sequence-start">
            <lhs>c-sequence-start</lhs>
            <rhs>
              <quote>[</quote>
            </rhs>
          </production>

          <production id="c-sequence-end">
            <lhs>c-sequence-end</lhs>
            <rhs>
              <quote>]</quote>
            </rhs>
          </production>

          <production id="c-mapping-start">
            <lhs>c-mapping-start</lhs>
            <rhs>
              <quote>{</quote>
            </rhs>
          </production>

          <production id="c-mapping-end">
            <lhs>c-mapping-end</lhs>
            <rhs>
              <quote>}</quote>
            </rhs>
          </production>

          <production id="c-sequence-entry">
            <lhs>c-sequence-entry</lhs>
            <rhs>
              <quote>-</quote>
            </rhs>
          </production>

          <production id="c-mapping-key">
            <lhs>c-mapping-key</lhs>
            <rhs>
              <quote>?</quote>
            </rhs>
          </production>

          <production id="c-mapping-value">
            <lhs>c-mapping-value</lhs>
            <rhs>
              <quote>:</quote>
            </rhs>
          </production>

          <production id="c-collect-entry">
            <lhs>c-collect-entry</lhs>
            <rhs>
              <quote>,</quote>
            </rhs>
          </production>

          <production id="c-throwaway">
            <lhs>c-throwaway</lhs>
            <rhs>
              <quote>#</quote>
            </rhs>
          </production>

          <production id="c-anchor">
            <lhs>c-anchor</lhs>
            <rhs>
              <quote>&amp;</quote>
            </rhs>
          </production>

          <production id="c-alias">
            <lhs>c-alias</lhs>
            <rhs>
              <quote>*</quote>
            </rhs>
          </production>

          <production id="c-tag">
            <lhs>c-tag</lhs>
            <rhs>
              <quote>!</quote>
            </rhs>
          </production>

          <production id="c-literal">
            <lhs>c-literal</lhs>
            <rhs>
              <quote>|</quote>
            </rhs>
          </production>

          <production id="c-folded">
            <lhs>c-folded</lhs>
            <rhs>
              <quote>&gt;</quote>
            </rhs>
          </production>

          <production id="c-single-quote">
            <lhs>c-single-quote</lhs>
            <rhs>
              <quote>'</quote>
            </rhs>
          </production>

          <production id="c-double-quote">
            <lhs>c-double-quote</lhs>
            <rhs>
              <quote>"</quote>
            </rhs>
          </production>

          <production id="c-directive">
            <lhs>c-directive</lhs>
            <rhs>
              <quote>%</quote>
            </rhs>
          </production>

          <production id="c-reserved">
            <lhs>c-reserved</lhs>
            <rhs>
              <quote>@</quote> | <quote>`</quote>
            </rhs>
          </production>

          <production id="c-top-indicators">
            <lhs>c-top-indicators</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal
                  def="#c-sequence-start"><quote>[</quote></nonterminal>
              | <nonterminal
                  def="#c-sequence-end"><quote>]</quote></nonterminal>
              | <nonterminal
                  def="#c-mapping-start"><quote>{</quote></nonterminal>
              | <nonterminal
                  def="#c-mapping-end"><quote>}</quote></nonterminal><sbr />
              | <nonterminal
                  def="#c-sequence-entry"><quote>-</quote></nonterminal>
              | <nonterminal
                  def="#c-mapping-key"><quote>?</quote></nonterminal>
              | <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
              | <nonterminal
                  def="#c-collect-entry"><quote>,</quote></nonterminal><sbr />
              | <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal>
              | <nonterminal def="#c-anchor"><quote>&amp;</quote></nonterminal>
              | <nonterminal def="#c-alias"><quote>*</quote></nonterminal>
              | <nonterminal def="#c-tag"><quote>!</quote></nonterminal><sbr />
              | <nonterminal def="#c-literal"><quote>|</quote></nonterminal>
              | <nonterminal def="#c-folded"><quote>&gt;</quote></nonterminal>
              | <nonterminal
                def="#c-single-quote"><quote>'</quote></nonterminal>
              | <nonterminal
                def="#c-double-quote"><quote>"</quote></nonterminal><sbr />
              | <nonterminal
                def="#c-directive"><quote>%</quote></nonterminal>
              | <nonterminal def="#c-reserved"><quote>@</quote>
              | <quote>`</quote></nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Top Indicator Characters</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>--- <hl1>%</hl1>YAML<hl1>:</hl1>1.0<sbr />
<hl1>#</hl1> top level block map<hl4>:</hl4>
flow seq<hl1>:</hl1> <hl1>&amp;</hl1>anchor <hl1>[</hl1> one<hl1>,</hl1> 1<hl4>,</hl4>200 <hl1>]</hl1>
flow map<hl1>:</hl1> <hl1>{</hl1> one<hl1>:</hl1> 1<hl1>,</hl1> 1,200<hl1>:</hl1> 2 <hl1>}</hl1>
block seq<hl1>:</hl1> <hl1>!</hl1>seq
<hl1>-</hl1> one
<hl1>-</hl1> <hl4>-</hl4>1<hl4>,</hl4>200
<hl1>?</hl1> alias
<hl1>:</hl1> <hl1>*</hl1>anchor
literal<hl1>:</hl1> <hl1>|</hl1>
  #<hl4>!</hl4>/usr/bin/perl
  print <hl4>'</hl4>Hello<hl4>,</hl4> world<hl4>!</hl4><hl4>'</hl4><hl4>,</hl4> <hl4>"</hl4>\n<hl4>"</hl4>;
folded<hl1>:</hl1> <hl1>&gt;</hl1>
  Line-wrapped
  paragraphs <hl4>&amp;</hl4>
  WIKI-style
  formatting:
&nbsp;
    <hl4>*</hl4> false &rArr; anything<hl4>,</hl4>
    <hl4>*</hl4> 1<hl4>,</hl4>200 <hl4>&gt;</hl4> <hl4>-</hl4>7
&nbsp;
single quoted<hl1>:</hl1>
  <hl1>"</hl1><hl4>*</hl4>p<hl4>[</hl4>1<hl4>]</hl4> is a C expression<hl1>"</hl1>
double quoted<hl1>:</hl1>
  <hl1>'</hl1><hl4>"</hl4>s<hl4>"</hl4> is a C string<hl1>'</hl1>
...
# Legend:
#   <hl1><link linkend="c-top-indicators">c-top-indicators</link></hl1>
#   <hl4>not top indicators</hl4>
</programlisting>
              </member>
              <member>
<programlisting>--- %YAML:1.0<sbr />
!map {
  !str "flow seq": &amp;anchor
    !seq [ !str "one", !int "1200" ],
  !str "flow map":
    !map {
      !str "one": !int "1",
      !int "1200": !int "2",
    }
  !str "block seq":
    !seq [ !str "one", !int 1200 ]
  !str "alias": *anchor
  !str "literal": !str
    "#!/usr/bin/perl\n\
    print 'Hello, world!', \"\\n\";\n"
  !str "folded": !str
    "Line-wrapped paragraphs &amp;\
    WIKI-style formatting:\n\
    \n\
    \  * false \u21d2 anything,\n\
    \  * 1,200 &gt; -7\n"
  !str "single quoted":
    !str "*p[1] is a C expression"
  !str "double quoted":
    !str "\"s\" is a C string"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="c-domain">
            <lhs>c-domain</lhs>
            <rhs>
              <quote>.</quote>
            </rhs>
          </production>

          <production id="c-date">
            <lhs>c-date</lhs>
            <rhs>
              <quote>,</quote>
            </rhs>
          </production>

          <production id="c-path">
            <lhs>c-path</lhs>
            <rhs>
              <quote>/</quote>
            </rhs>
          </production>

          <production id="c-prefix">
            <lhs>c-prefix</lhs>
            <rhs>
              <quote>^</quote>
            </rhs>
          </production>

          <production id="c-escape">
            <lhs>c-escape</lhs>
            <rhs>
              <quote>\</quote>
            </rhs>
          </production>

          <production id="c-strip">
            <lhs>c-strip</lhs>
            <rhs>
              <quote>-</quote>
            </rhs>
          </production>

          <production id="c-keep">
            <lhs>c-keep</lhs>
            <rhs>
              <quote>+</quote>
            </rhs>
          </production>

          <production id="c-sub-indicators">
            <lhs>c-sub-indicators</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal
                def="#c-domain"><quote>.</quote></nonterminal>
              | <nonterminal def="#c-date"><quote>,</quote></nonterminal>
              | <nonterminal def="#c-path"><quote>/</quote></nonterminal>
              | <nonterminal
                def="#c-prefix"><quote>^</quote></nonterminal><sbr />
              | <nonterminal
                def="#c-escape"><quote>\</quote></nonterminal>
              | <nonterminal def="#c-strip"><quote>-</quote></nonterminal>
              | <nonterminal def="#c-keep"><quote>+</quote></nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Sub Indicator Characters</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---
!clarkevans<hl1>.</hl1>com<hl1>,</hl1>2002<hl1>/</hl1>graph<hl1>/</hl1><hl1>^</hl1>shape<sbr />
- !<hl1>^</hl1>label
  text: "Multi<hl1>\</hl1>nLine"
 
- !<hl1>^</hl1>label
  text: |<hl1>+</hl1>
    To <hl4>/</hl4>tmp or to c:<hl4>\</hl4>temp<hl4>,</hl4>
    that is the question<hl4>.</hl4><hl4>.</hl4><hl4>.</hl4>
 
- !<hl1>^</hl1>label
  text: &gt;<hl1>-</hl1>
    <hl4>-</hl4>1<hl4>.</hl4>0<hl4>^</hl4>2 = <hl4>+</hl4>2<hl4>,</hl4>000<hl4>/</hl4>2<hl4>,</hl4>000
 
...
# Legend:
#   <hl1><link linkend="c-sub-indicators">c-sub-indicators</link></hl1>
#   <hl4>not sub indicators</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!clarkevans.com,2002/graph/shape [
  !clarkevans.com,2002/graph/label {
    !str "text":
      !str "Multi\nLine"
  },
  !clarkevans.com,2002/graph/label {
    !str "text":
      !str "To /tmp or to c:\\temp,\n\
          that is the question...\n\n"
  },
  !clarkevans.com,2002/graph/label {
    !str "text":
      !str "-1.0^2 = +2,000/2,000"
  }
]
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-break" />Line Break Characters</title>

        <para>
          The Unicode standard defines several line break <link
          linkend="b-char">characters</link>. These line breaks can be grouped
          into two categories. <link linkend="b-specific">Specific</link> line
          breaks have well-defined semantics for breaking text into lines and
          paragraphs, and must be preserved by the YAML processor. <link
          linkend="b-generic">Generic</link> line breaks do not carry a meaning
          beyond <quote>ending a line</quote> and are
          <firstterm>normalized</firstterm> by the YAML processor: inside
          scalar text content, each such line break must be translated into a
          single <link linkend="b-line-feed">LF</link> character (this does not
          apply to <link linkend="syntax-escape">escaped</link> characters).
          This normalization functionality is indicated by the use of the <link
          linkend="b-as-line-feed"><userinput>b-as-line-feed</userinput></link>
          production defined below. Outside scalar text content, YAML allows
          any line break to be used to terminate lines, and in most cases also
          allows such line breaks to be preceded by trailing <link
          linkend="s-b-seperated-comment">comment</link> characters. On output,
          a YAML processor is free to present line breaks using whatever
          convention is most appropriate, though specific line breaks must be
          preserved in scalar content. These rules are compatible with
          Unicode's newline <ulink
          url="http://www.unicode.org/unicode/reports/tr13/"
          >guidelines</ulink>.
        </para>

        <productionset>
          <production id="b-line-feed">
            <lhs>b-line-feed</lhs>
            <rhs>
              #xA /* LF */
            </rhs>
          </production>

          <production id="b-carriage-return">
            <lhs>b-carriage-return</lhs>
            <rhs>
              #xD /* CR */
            </rhs>
          </production>

          <production id="b-next">
            <lhs>b-next</lhs>
            <rhs>
              #x85 /* NEL */
            </rhs>
          </production>

          <production id="b-line-separator">
            <lhs>b-line-separator</lhs>
            <rhs>
              #x2028 /* LS */
            </rhs>
          </production>

          <production id="b-paragraph-separator">
            <lhs>b-paragraph-separator</lhs>
            <rhs>
              #x2029 /* PS */
            </rhs>
          </production>

          <production id="b-char">
            <lhs>b-char</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#b-line-feed"/><sbr />
              | <nonterminal def="#b-carriage-return"/><sbr />
              | <nonterminal def="#b-next"/><sbr />
              | <nonterminal def="#b-line-separator"/><sbr />
              | <nonterminal def="#b-paragraph-separator"/>
            </rhs>
          </production>

          <production id="b-generic">
            <lhs>b-generic</lhs>
            <rhs>
              &nbsp;&nbsp;( <nonterminal def="#b-carriage-return"/>
              <nonterminal def="#b-line-feed"/> )<sbr />
              | <nonterminal def="#b-carriage-return"/><sbr />
              | <nonterminal def="#b-line-feed"/><sbr />
              | <nonterminal def="#b-next"/>
            </rhs>
          </production>

          <production id="b-specific">
            <lhs>b-specific</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#b-line-separator"/><sbr />
              | <nonterminal def="#b-paragraph-separator"/>
            </rhs>
          </production>

          <production id="b-any">
            <lhs>b-any</lhs>
            <rhs>
              <nonterminal def="#b-generic"/>
              | <nonterminal def="#b-specific"/>
            </rhs>
          </production>

          <production id="b-as-line-feed">
            <lhs>b-as-line-feed</lhs>
            <rhs>
              <nonterminal def="#b-generic" />
            </rhs>
          </production>

          <production id="b-normalized">
            <lhs>b-normalized</lhs>
            <rhs>
              <nonterminal def="#b-as-line-feed" />
              | <nonterminal def="#b-specific" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Line Break Characters</title>

          <para>
            In the examples, line break characters are represented as follows:
            <quote><userinput>&darr;</userinput></quote> or no glyph for a
            <link linkend="b-generic">generic</link> line break,
            <quote><userinput>&dArr;</userinput></quote> for a <link
            linkend="b-line-separator">line separator</link> and
            <quote><userinput>&para;</userinput></quote> for a <link
            linkend="b-paragraph-separator">paragraph separator</link>.
          </para>

          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
Generic line break (no glyph)
Generic line break (glyphed)<hl1>&darr;</hl1>
Line seperator<hl2>&dArr;</hl2>
Paragraph seperator<hl2>&para;</hl2>
...
# Legend:
#   <hl1><link linkend="b-generic">b-generic</link></hl1>
#   <hl2><link linkend="b-specific">b-specific</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>--- !str<sbr />
"Generic line break (no glyph)\n\
Generic line break (explicit)\n\
Line seperator\u2028\
Paragraph seperator\u2029"
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-misc-chars" />Miscellaneous
        Characters</title>

        <para>
          YAML makes use of the following common character range
          definitions:
        </para>

        <productionset>
          <production id="nb-char">
            <lhs>nb-char</lhs>
            <rhs>
              <nonterminal def="#c-printable"/> - <nonterminal def="#b-char"/>
            </rhs>
          </production>

          <production id="s-char">
            <lhs>s-char</lhs>
            <rhs>
              &nbsp;&nbsp;#x9 /* TAB */<sbr />
              | #x20 /* SP */
            </rhs>
          </production>

          <production id="ns-char">
            <lhs>ns-char</lhs>
            <rhs>
              <nonterminal def="#nb-char"/> - <nonterminal def="#s-char"/>
            </rhs>
          </production>

          <production id="ns-ascii-letter">
            <lhs>ns-ascii-letter</lhs>
            <rhs>
              &nbsp;&nbsp;[#x41-#x5A] /* A-Z */<sbr />
              | [#x61-#x7A] /* a-z */
            </rhs>
          </production>

          <production id="ns-decimal-digit">
            <lhs>ns-decimal-digit</lhs>
            <rhs>
              [#x30-#x39] /* 0-9 */
            </rhs>
          </production>
          <production id="ns-hex-digit">
            <lhs>ns-hex-digit</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#ns-decimal-digit"/><sbr />
              | [#x41-#x46] /* A-F */<sbr />
              | [#x61-#x66] /* a-f */
            </rhs>
          </production>
          <production id="ns-word-char">
            <lhs>ns-word-char</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#ns-decimal-digit"/><sbr />
              | <nonterminal def="#ns-ascii-letter"/> | <quote>-</quote>
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-escape" />Escaped Characters</title>

        <para>
          Non-<link linkend="c-printable">printable</link> characters must
          be encoded in the YAML character stream using escape sequences.
          YAML escape sequences are based on the <link
          linkend="c-escape"><quote>\</quote></link> notation used by most
          modern computer languages. To allow long lines to be broken in
          arbitrary locations, an <link linkend="c-b-escaped">escaped line
          break</link> is completely ignored. Escape sequences are only
          interpreted in two contexts, in <link
          linkend="syntax-double">double quoted</link> scalars and in <link
          linkend="syntax-tag">tags</link>. In all other contexts, the
          <quote>\</quote> character has no special meaning.
        </para>

        <productionset>
          <production id="c-b-escaped">
            <lhs>c-b-escaped</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <nonterminal def="#b-any" /> /* ignored */
            </rhs>
          </production>

          <production id="ns-esc-escape">
            <lhs>ns-esc-escape</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-esc-double-quote">
            <lhs>ns-esc-double-quote</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-esc-bel">
            <lhs>ns-esc-bel</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>a</quote>
            </rhs>
          </production>

          <production id="ns-esc-backspace">
            <lhs>ns-esc-backspace</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>b</quote>
            </rhs>
          </production>

          <production id="ns-esc-esc">
            <lhs>ns-esc-esc</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>e</quote>
            </rhs>
          </production>

          <production id="ns-esc-form-feed">
            <lhs>ns-esc-form-feed</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>f</quote>
            </rhs>
          </production>

          <production id="ns-esc-line-feed">
            <lhs>ns-esc-line-feed</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>n</quote>
            </rhs>
          </production>

          <production id="ns-esc-return">
            <lhs>ns-esc-return</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>r</quote>
            </rhs>
          </production>

          <production id="ns-esc-tab">
            <lhs>ns-esc-tab</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>t</quote>
            </rhs>
          </production>

          <production id="ns-esc-vertical-tab">
            <lhs>ns-esc-vertical-tab</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>v</quote>
            </rhs>
          </production>

          <production id="ns-esc-caret">
            <lhs>ns-esc-caret</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>^</quote>
            </rhs>
          </production>

          <production id="ns-esc-null">
            <lhs>ns-esc-null</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>0</quote>
            </rhs>
          </production>

          <production id="ns-esc-space">
            <lhs>ns-esc-space</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              #20 /* SP */
            </rhs>
          </production>

          <production id="ns-esc-non-breaking-space">
            <lhs>ns-esc-non-breaking-space</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>_</quote>
            </rhs>
          </production>

          <production id="ns-esc-next">
            <lhs>ns-esc-next</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>N</quote>
            </rhs>
          </production>

          <production id="ns-esc-line-separator">
            <lhs>ns-esc-line-separator</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>L</quote>
            </rhs>
          </production>

          <production id="ns-esc-paragraph-separator">
            <lhs>ns-esc-paragraph-separator</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>P</quote>
            </rhs>
          </production>

          <production id="ns-esc-8-bit">
            <lhs>ns-esc-8-bit</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>x</quote> ( <nonterminal def="#ns-hex-digit" /> x 2 )
            </rhs>
          </production>

          <production id="ns-esc-16-bit">
            <lhs>ns-esc-16-bit</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>u</quote> ( <nonterminal def="#ns-hex-digit" /> x 4 )
            </rhs>
          </production>

          <production id="ns-esc-32-bit">
            <lhs>ns-esc-32-bit</lhs>
            <rhs>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
              <quote>U</quote> ( <nonterminal def="#ns-hex-digit" /> x 8 )
            </rhs>
          </production>

          <production id="ns-esc-sequence">
            <lhs>ns-esc-sequence</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#ns-esc-escape" /><sbr />
              | <nonterminal def="#ns-esc-double-quote" /><sbr />
              | <nonterminal def="#ns-esc-bel" /><sbr />
              | <nonterminal def="#ns-esc-backspace" /><sbr />
              | <nonterminal def="#ns-esc-esc" /><sbr />
              | <nonterminal def="#ns-esc-form-feed" /><sbr />
              | <nonterminal def="#ns-esc-line-feed" /><sbr />
              | <nonterminal def="#ns-esc-return" /><sbr />
              | <nonterminal def="#ns-esc-tab" /><sbr />
              | <nonterminal def="#ns-esc-vertical-tab" /><sbr />
              | <nonterminal def="#ns-esc-caret" /><sbr />
              | <nonterminal def="#ns-esc-null" /><sbr />
              | <nonterminal def="#ns-esc-space" /><sbr />
              | <nonterminal def="#ns-esc-non-breaking-space" /><sbr />
              | <nonterminal def="#ns-esc-next" /><sbr />
              | <nonterminal def="#ns-esc-line-separator" /><sbr />
              | <nonterminal def="#ns-esc-paragraph-separator" /><sbr />
              | <nonterminal def="#ns-esc-8-bit" /><sbr />
              | <nonterminal def="#ns-esc-16-bit" /><sbr />
              | <nonterminal def="#ns-esc-32-bit" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Escaped Characters</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>--- !foo.bar/<hl1>\^</hl1>baz<sbr />
"Fun with <hl1>\\</hl1>
<hl1>\"</hl1> <hl1>\a</hl1> <hl1>\b</hl1> <hl1>\e</hl1> <hl1>\f</hl1> <hl1>\&darr;</hl1>
<hl1>\n</hl1> <hl1>\r</hl1> <hl1>\t</hl1> <hl1>\v</hl1> <hl1>\0</hl1> <hl1>\&dArr;</hl1>
<hl1>\&nbsp;</hl1> <hl1>\_</hl1> <hl1>\N</hl1> <hl1>\L</hl1> <hl1>\P</hl1> <hl1>\&para;</hl1>
<hl1>\x41</hl1> <hl1>\u0041</hl1> <hl1>\U00000041</hl1>"
...
# Legend:
#   <hl1><link linkend="ns-esc-sequence">ns-esc-sequence</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>--- !foo.bar/\x5ebaz<sbr />
"Fun with \x5C
\x22 \x07 \x08 \x1B \0C
\x0A \x0D \x09 \x0B \x00
\x20 \xA0 \x85 \u2028 \u2029
A A A"
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Invalid Escaped Characters</title>
          <simplelist type="horiz" columns="2">
            <member>
<screen>---
"Bad escapes: <hl1>\c</hl1> <hl1>\xq-</hl1>"
...
# Legend:
#   <hl1>invalid escape sequences</hl1>
</screen>
              </member>
              <member>
<screen>ERROR:
- <hl1>c</hl1> is an invalid escaped character.
- <hl1>q</hl1> and <hl1>-</hl1> are invalid hecadecimal
  digits (applies to \x, \u and \U).
</screen>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-primitives" />Syntax Primitives</title>

      <sect2>
        <title><anchor id="syntax-context" />Production Context</title>

        <para>
          As YAML's syntax is designed for maximal readability, it makes heavy
          use of the context that each syntactical construct appears in. This
          is expressed using parameterized BNF productions. The set of
          parameters and the range of allowed values depends on the specific
          production. The full list of possible parameters and their values is:
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <para>
                Indentation: <varname>n</varname> or <varname>m</varname>
              </para>
            </term>

            <listitem>
              <para>
                Since the YAML stream depends upon indentation level to
                delineate blocks, many productions are parameterized by it. In
                some cases, the notations
                <userinput>production(&lt;n)</userinput>,
                <userinput>production(&les;n)</userinput> and
                <userinput>production(&gt;n)</userinput> are used; these are
                shorthands for <quote><userinput>production(m)</userinput> for
                some specific <varname>m</varname></quote> where
                0&nbsp;&les;&nbsp;<varname>m</varname
                >&nbsp;&lt;&nbsp;<varname>n</varname>,
                0&nbsp;&les;&nbsp;<varname>m</varname
                >&nbsp;&les;&nbsp;<varname>n</varname> and
                <varname>m</varname>&nbsp;&gt;&nbsp;<varname>n</varname>,
                respectively. Similarly, the
                <userinput>production(&ges;0)</userinput> notation is used to
                indicate an arbitrary indentation level, and is a shorthand for
                <quote><userinput>production(m)</userinput> for some specific
                <varname>m</varname></quote> where
                <varname>m</varname>&nbsp;&ges;&nbsp;0.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <para>
                Context: <varname>c</varname>
              </para>
            </term>

            <listitem>
              <para>
                YAML supports two main contexts, <firstterm>block</firstterm>
                and <firstterm>flow</firstterm>. In the block contexts,
                indentation is used to delineate structure. Due to the fact
                that the <link linkend="c-sequence-entry"
                ><quote><userinput>-</userinput></quote></link> sequence entry
                indicator is perceived as an indentation character, some
                productions distinguish between the
                <firstterm>block-in</firstterm> context (inside block
                sequences) and the <firstterm>block-out</firstterm> context
                (outside block sequences). In the flow contexts, explicit
                markers are used to delineate structure. As plain scalars have
                no such markers, they are the most context sensitive
                constructs, distinguishing between being nested inside a flow
                collection (<firstterm>flow-in</firstterm> context) or being
                outside one (<firstterm>flow-out</firstterm> context). YAML
                also provides for a terse and intuitive syntax using plain
                scalars as flow mapping keys (<firstterm>flow-key</firstterm>
                context). Such scalars are the most restricted, for readability
                and implementation reasons.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <para>
                Style: <varname>s</varname>
              </para>
            </term>

            <listitem>
              <para>
                Typically, each presentation style is specified using a
                distinct set of productions. However, for some scalar styles it
                is better have a single productions set parameterized by the
                style rather than having two mostly-identical sets of
                productions. Thus, quoted scalar productions may be
                <firstterm>single</firstterm> or <firstterm>double</firstterm>,
                and block scalar productions may be
                <firstterm>literal</firstterm> or
                <firstterm>folded</firstterm>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <para>
                Chomping (trailing line breaks): <varname>t</varname>
              </para>
            </term>

            <listitem>
              <para>
                Block scalars offer three possible mechanisms for
                <firstterm>chomping</firstterm> any trailing line breaks:
                <firstterm>strip</firstterm>, <firstterm>clip</firstterm> and
                <firstterm>keep</firstterm>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2>
        <title><anchor id="syntax-indent" />Indentation Levels</title>

        <para>
          In a YAML character stream, structure is often determined from
          indentation, where indentation is defined as a line break character
          followed by zero or more space characters. Tab characters are not
          allowed in indentation since different systems treat tabs
          differently. To maintain portability, YAML's tab policy is
          conservative; they must not be used. Note that most modern editors
          may be configured so that pressing the tab key results in the
          insertion of an appropriate number of spaces.
        </para>
          
        <example>
          <title>Invalid Use of Tabs</title>

          <para>
            In the examples, tab characters are represented as the glyph
            <quote><userinput>&rarr;</userinput></quote>.
          </para>

          <simplelist type="horiz" columns="2">
            <member>
<screen>---
tabs:<hl2>&rarr;</hl2># <hl2>&rarr;</hl2> Dos and don'ts.
<hl1>&rarr;</hl1>- Indented by a tab (<hl2>&rarr;</hl2>).
 <hl1>&rarr;</hl1> - Mixed indentation.
...
</screen>
            </member>
            <member>
<screen>ERROR:
  Tabs <hl1>must not</hl1> appear in
  indentation. They <hl2>may</hl2>
  appear anywhere else - in
  content, comments, etc.
</screen>
            </member>
          </simplelist>
        </example>

        <para>
          The indentation level is always non-zero, except for the top level
          node of each document. This node is commonly indented by zero spaces
          (not indented). When such top level block scalar node is not
          indented, all lines up to the next document separator, document
          terminator, or end of the stream are assumed to be content lines.
          Note this includes lines beginning with a
          <quote><userinput>#</userinput></quote> character.
          In general, a node must be more indented than its parent node. All
          sibling nodes must use the exact same indentation level, however the
          content of each sibling node could be further indented independently.
        </para>

        <para>
          The <quote><userinput>-</userinput></quote> <link
          linkend="c-sequence-entry">sequence entry</link>,
          <quote><userinput>?</userinput></quote> <link
          linkend="c-mapping-key">mapping key</link> and
          <quote><userinput>:</userinput></quote> <link
          linkend="c-mapping-value">mapping value</link> indicators are
          perceived by people to be part of the indentation. Hence the
          indentation rules are slightly more flexible when dealing with these
          indicators. First, a block sequence need not be indented relative to
          its parent node, unless that node is also a block sequence. Second,
          compact in-line notations allow a nested collection to begin
          immediately following the indicator (where the indicator is counted
          as part of the indentation), providing for a compact and intuitive
          collection nesting notation.
        </para>

        <para>
          Indentation is used exclusively to delineate structure and is
          otherwise ignored; in particular, indentation characters must never
          be considered part of the document's content.
        </para>

        <productionset>
          <production id="s-indentation(n)">
            <lhs>s-indentation(n)</lhs>
            <rhs>
              #x20 x n
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Indentation Spaces</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1>   </hl1># Indented text and empty comments<sbr />
<hl1>   </hl1>
---
No indent spaces:
<hl1> </hl1>By one space: &gt;
<hl1>    </hl1>By four
<hl1>    </hl1><hl4>  </hl4>spaces
<hl1> </hl1>Flow style:&rarr;[
<hl1>  </hl1><hl4> </hl4>one,
<hl1>  </hl1>two
<hl1>  </hl1><hl4>&rarr;</hl4>three
<hl1>  </hl1><hl4>  </hl4>]
...
# Legend:
#   <hl1><link linkend="s-indentation(n)">s-indentation</link></hl1>
#   <hl4>not indentation spaces</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "No indent spaces":
    !map {
      !str "By one space":
        !str "By four\n  spaces",
      !str "Flow style":
        !seq [
          !str "one",
          !str "two three"
        ]
    }
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-comment" />Throwaway comments</title>

        <para>
          Throwaway comments have no effect whatsoever on the document's
          representation graph. The usual purpose of a comment is to
          communicate between the human maintainers of the file. A typical
          example is comments in a configuration file. An explicit throwaway
          comment is marked by a <link
          linkend="c-throwaway"><quote><userinput>#</userinput></quote></link>
          indicator and always spans to the end of a line. Explicit comments
          can be indented on their own line, or may, in some cases, follow
          other syntax elements (with leading spaces). Outside text content,
          empty lines or lines containing only white space are taken to be
          implicit throwaway comment lines. A throwaway comment may appear
          before a document's top level node or following any node. It may
          not appear inside a scalar node, but may precede or follow it.
        </para>

        <productionset>
          <production id="s-discarded-spaces">
            <lhs>s-discarded-spaces</lhs>
            <rhs>
              <nonterminal def="#s-char" />+
            </rhs>
          </production>

          <production id="c-nb-throwaway-text">
            <lhs>c-nb-throwaway-text</lhs>
            <rhs>
              <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal>
              <nonterminal def="#nb-char" />*
            </rhs>
          </production>

          <production id="b-ignored-any">
            <lhs>b-ignored-any</lhs>
            <rhs>
              <nonterminal def="#b-any" />
            </rhs>
          </production>

          <production id="c-b-throwaway-comment">
            <lhs>c-b-throwaway-comment</lhs>
            <rhs>
              <nonterminal def="#c-nb-throwaway-text" />?
              <nonterminal def="#b-ignored-any" />
            </rhs>
          </production>

          <production id="s-b-seperated-comment">
            <lhs>s-b-seperated-comment</lhs>
            <rhs>
              ( <nonterminal def="#s-discarded-spaces" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#c-nb-throwaway-text" />? )?<sbr />
              <nonterminal def="#b-ignored-any" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Trailing Comments</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
    <HL><hl1><hl3># Comment Line</hl3>&darr;</hl1></HL>
Block: |<HL><hl2>    <hl3># Comment</hl3>&darr;</hl2></HL>
  The
  <hl4># of elements</hl4>
 <HL><hl1><hl3># Is commented</hl3>&darr;</hl1></HL>
Flow:<HL><hl2>    <hl3># Comment</hl3>&darr;</hl2></HL>
  The<hl4> # of elements</hl4>
  <HL><hl1><hl3># Is commented</hl3>&darr;</hl1></HL>
...
# Legend:
#   <hl1><link linkend="c-b-throwaway-comment">c-b-throwaway-comment</link></hl1>
#   <hl2><link linkend="s-b-seperated-comment">s-b-seperated-comment</link></hl2>
#   <hl3><link linkend="c-nb-throwaway-text">c-nb-throwaway-text</link></hl3>
#   <hl4>not a comment</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "Block":
    !str "The # of elements",
  !str "Flow":
    !str "The # of elements"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="l-empty-comment(n)">
            <lhs>l-empty-comment(n)</lhs>
            <rhs>
              <nonterminal def="#s-indentation(n)" /><sbr />
              <nonterminal def="#b-ignored-any" />
            </rhs>
          </production>

          <production id="l-text-comment(n)">
            <lhs>l-text-comment(n)</lhs>
            <rhs>
              <nonterminal def="#s-indentation(n)" /><sbr />
              <nonterminal def="#c-b-throwaway-comment" />
            </rhs>
          </production>

          <production id="l-comment">
            <lhs>l-comment</lhs>
            <rhs>
                &nbsp;&nbsp;<nonterminal def="#l-empty-comment(n)"
                  >l-empty-comment(&ge;0)</nonterminal><sbr />
                | <nonterminal
                  def="#l-text-comment(n)">l-text-comment(&ge;0)</nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Comment Lines</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl2>    &darr;</hl2><sbr />
<hl1>  # Comment&dArr;</hl1>
---
<hl1># YAML can be easily quoted:</hl1>
Quoted YAML: |+
<hl4>  # YAML quoted as</hl4>
<hl4>  # literal text</hl4>
<hl4>&darr;</hl4>
  key: value
<hl4>&darr;</hl4>
<hl1># Quoting need not be indented:</hl1>
<hl2>&darr;</hl2>
--- |
<hl4># YAML quoted as</hl4>
<hl4># literal text</hl4>
<hl4>&darr;</hl4>
<hl4>key: value</hl4>
<hl4>&darr;</hl4>
...
# Legend:
#   <hl1><link linkend="l-text-comment(n)">l-text-comment</link></hl1>
#   <hl2><link linkend="l-empty-comment(n)">l-empty-comment</link></hl2>
#   <hl4>not a comment line</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "Quoted YAML":
    !str "# YAML quoted as\n\
          # literal text\n\n\
          key: value\n\n"
}
...
---
!str "# YAML quoted as\n\
      # literal text\n\n\
      key: value\n\n"
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-separate" />Seperation Spaces</title>

        <para>
          When tokens may be separated by white space, YAML usually allows
          ending the line (with an optional trailing <link
          linkend="syntax-comment">comment</link>) and continuing in the next
          (indented) line. Simple keys, however, require separation spaces to
          be confined within the current line. Space separation functionality
          is indicated by the use of the <link
          linkend="s-seperate-spaces(n,c)"><userinput
          >s-seperate-spaces(n,c)</userinput></link> production. Seperation
          spaces are used exclusively to delineate structure and are otherwise
          ignored; in particular, such characters must never be considered part
          of the document's content.
        </para>

        <productionset>
          <production id="s-seperate-spaces(n,c)">
            <lhs>s-seperate-spaces(n,c)</lhs>
            <rhs>
              <varname>c</varname> = block-out &rArr;
              <nonterminal def="#s-seperate-span-spaces(n)" /><sbr />
              <varname>c</varname> = block-in&nbsp; &rArr;
              <nonterminal def="#s-seperate-span-spaces(n)" /><sbr />
              <varname>c</varname> = flow-out&nbsp; &rArr;
              <nonterminal def="#s-seperate-span-spaces(n)" /><sbr />
              <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr;
              <nonterminal def="#s-seperate-span-spaces(n)" /><sbr />
              <varname>c</varname> = flow-key&nbsp; &rArr;
              <nonterminal def="#s-discarded-spaces" />
            </rhs>
          </production>

          <production id="s-seperate-span-spaces(n)">
            <lhs>s-seperate-span-spaces(n)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#s-discarded-spaces" /><sbr />
              | ( <nonterminal def="#s-b-seperated-comment" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-comment" />*<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-indentation(n)" />
              <nonterminal def="#s-discarded-spaces" />? )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Seperation Spaces</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<hl1> </hl1>%YAML:1.0<hl1> </hl1>!map<sbr />
block sequence:<hl1> </hl1>&amp;anchor<hl1> </hl1>!seq
-<hl1>&rarr;</hl1>!str<hl1> </hl1>|-
 block (literal) entry
-<hl1> </hl1>flow (plain) entry
flow sequence<hl1> </hl1>:<hl1>&rarr; # Two entries
    </hl1>[<hl1>&rarr;</hl1>entry<hl1> </hl1>,<hl1>&dArr;
    </hl1>entry]
?<hl1> </hl1>&gt;-
    flow mapping
:<hl1>&para;
    # Key:
    </hl1>{key:<hl1>&darr;
    # Value:
    </hl1>value,}
...
# Legend:
#   <hl1><link linkend="s-seperate-spaces(n,c)">s-seperate-spaces</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>--- %YAML:1.0<sbr />
!map {
  !str "block sequence":
    !seq [
      !str "block (literal) entry",
      !str "flow (plain) entry",
    ],
  !str "flow sequence":
    !seq [
      !str "entry",
      !str "entry",
    ],
  !str "flow mapping":
    !map {
      !str "key":
        !str "value"
    }
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-fold" />Line Folding</title>

        <para>
          Line folding allows long lines to be broken for presentation, while
          retaining the original semantics of a single long line. When folding
          is done, any line break ending an <link
          linkend="l-empty-line(n,c)">empty line</link> is preserved, as are
          any <link linkend="b-specific">specific</link> line breaks. Hence,
          folding only applies to generic line breaks that end non-empty
          content lines. If the following line is not empty, the generic line
          break is converted to a single space (<userinput>#x20</userinput>).
          If the following line is empty, the generic line break is ignored.
          Folding functionaility is implied by using the <link
          linkend="b-as-space">b-as-space</link> and <link
          linkend="b-ignored-generic">b-ignored-generic</link> productions.
        </para>
          
        <productionset>
          <production id="b-as-space">
            <lhs>b-as-space</lhs>
            <rhs>
              <nonterminal def="#b-generic" />
            </rhs>
          </production>

          <production id="b-ignored-generic">
            <lhs>b-ignored-generic</lhs>
            <rhs>
              <nonterminal def="#b-generic" />
            </rhs>
          </production>

          <production id="b-l-folded-specific(n,c)">
            <lhs>b-l-folded-specific(n,c)</lhs>
            <rhs>
              <nonterminal def="#b-specific" /><sbr />
              <nonterminal def="#l-empty-line(n,c)" />*
            </rhs>
          </production>

          <production id="b-l-folded-as-space(n,c)">
            <lhs>b-l-folded-as-space(n,c)</lhs>
            <rhs>
              <nonterminal def="#b-as-space" /><sbr />
            </rhs>
          </production>

          <production id="b-l-folded-trimmed(n,c)">
            <lhs>b-l-folded-trimmed(n,c)</lhs>
            <rhs>
              <nonterminal def="#b-ignored-generic" /><sbr />
              <nonterminal def="#l-empty-line(n,c)" />+
            </rhs>
          </production>

          <production id="b-l-folded-break(n,c)">
            <lhs>b-l-folded-break(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#b-l-folded-specific(n,c)" /><sbr />
              | <nonterminal def="#b-l-folded-as-space(n,c)" /><sbr />
              | <nonterminal def="#b-l-folded-trimmed(n,c)" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Folded Line Breaks</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
Flow:
 First<hl1>&darr;</hl1>
 line<hl2>&darr;
&darr;</hl2>
 Second<hl1>&darr;</hl1>
 line<hl3>&para;
 &darr;</hl3>
 Third<hl1>&darr;</hl1>
 line
Block: &gt;
 First<hl1>&darr;</hl1>
 line<hl2>&darr;
&darr;</hl2>
 Second<hl1>&darr;</hl1>
 line<hl3>&para;
 &darr;</hl3>
 Third<hl1>&darr;</hl1>
 line
...
# Legend:
#   <hl1><link linkend="b-l-folded-as-space(n,c)">b-l-folded-as-space</link></hl1>
#   <hl2><link linkend="b-l-folded-trimmed(n,c)">b-l-folded-trimmed</link></hl2>
#   <hl3><link linkend="b-l-folded-specific(n,c)">b-l-folded-specific</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "Flow":
    !str "First line\
          Second line\P\n\
          Third line",
  !str "Block":
    !str "First line\
          Second line\P\n\
          Third line",
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          The above rules are common to both block and flow folded scalars.
          Folding does distinguish between block and flow contexts in the
          following way:
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <para>
                <anchor id="syntax-block-fold" />Block Folding
              </para>
            </term>

            <listitem>
              <para>
                In block contexts, folding does not apply to line breaks and
                empty lines preceding or following a text line that contains
                leading spaces. Note that such a line may consist of only such
                leading spaces; an empty line is confined to (optional)
                indentation spaces only. Further, the final line break and
                empty lines are subject to <link
                linkend="syntax-chomp">chomping</link>, and are never folded.
                The combined effect of these rules is that each "paragraph" is
                interpreted as a line, empty lines are used to present a line
                feed, the formatting of "more indented" lines is preserved, and
                final line breaks may be included or excluded from the content
                as appropriate.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <para>
                <anchor id="syntax-flow-fold" />Flow Folding
              </para>
            </term>

            <listitem>
              <para>
                Folding in flow contexts provides more relaxed, less powerful
                semantics. Such contexts typically depend on explicit
                indicators to convey structure, rather than indentation. Hence,
                in flow contexts, spaces preceding or following the text in a
                line are not considered to be part of the scalar content. Once
                all such spaces have been stripped from the content, folding
                proceeds as described above. In contrast with block contexts,
                all line breaks are folded, without exception, and a line
                consisting only of spaces is considered to be an empty line,
                regardless of the number of spaces. The combined effect of
                these processing rules is that each "paragraph" is interpreted
                as a line, empty lines are used to present a line feed, and
                text can be freely "indented" without affecting the scalar
                content.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <productionset>
          <production id="i-s-empty-line(n,c)">
            <lhs>i-s-empty-line(n,c)</lhs>
            <rhs>
              <varname>c</varname> = block-out &rArr;
              <nonterminal def="#i-s-empty-line-block(n)" /><sbr />
              <varname>c</varname> = block-in&nbsp; &rArr;
              <nonterminal def="#i-s-empty-line-block(n)" /><sbr />
              <varname>c</varname> = flow-out&nbsp; &rArr;
              <nonterminal def="#i-s-empty-line-flow(n)" /><sbr />
              <varname>c</varname> = flow-in&nbsp;&nbsp; &rArr;
              <nonterminal def="#i-s-empty-line-flow(n)" />
            </rhs>
          </production>

          <production id="i-s-empty-line-block(n)">
            <lhs>i-s-empty-line-block(n)</lhs>
            <rhs>
              <nonterminal
                def="#s-indentation(n)">s-indentation(&les;n)</nonterminal>
            </rhs>
          </production>

          <production id="i-s-empty-line-flow(n)">
            <lhs>i-s-empty-line-flow(n)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#s-indentation(n)"
                >s-indentation(&les;n)</nonterminal><sbr />
              | ( <nonterminal def="#s-indentation(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#s-discarded-spaces" /> )
            </rhs>
          </production>

          <production id="l-empty-specific(n,c)">
            <lhs>l-empty-specific(n,c)</lhs>
            <rhs>
              <nonterminal def="#i-s-empty-line(n,c)" /><sbr />
              <nonterminal def="#b-specific" />
            </rhs>
          </production>

          <production id="l-empty-generic(n,c)">
            <lhs>l-empty-generic(n,c)</lhs>
            <rhs>
              <nonterminal def="#i-s-empty-line(n,c)" /><sbr />
              <nonterminal def="#b-as-line-feed" />
            </rhs>
          </production>

          <production id="l-empty-line(n,c)">
            <lhs>l-empty-line(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#l-empty-specific(n,c)" /><sbr />
              | <nonterminal def="#l-empty-generic(n,c)" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Folded Empty Lines</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
Block (folded): &gt;
  Some
<hl1>&darr;</hl1>
<HL><hl1><hl2> </hl2>&dArr;</hl1></HL>
<HL><hl1><hl2>  </hl2>&darr;</hl1></HL>
<HL><hl4><hl2>  </hl2> &dArr;</hl4></HL>
  Text
Flow (plain):
  Some
<hl1>&darr;</hl1>
<HL><hl1><hl2> </hl2>&dArr;</hl1></HL>
<HL><hl1><hl2> </hl2> &darr;</hl1></HL>
<HL><hl1><hl2> </hl2>  &dArr;</hl1></HL>
  Text
...
# Legend:
#   <hl1><link linkend="l-empty-line(n,c)">l-empty-line</link></hl1>
#   <hl2><link linkend="s-indentation(n)">s-indentation</link></hl2>
#   <hl4>not empty line</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "Block (folded)":
    !str "Some\n\L\n \LText\n"
  !str "Flow (plain)":
    !str "Some\n\L\n\LText"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-chomp" />Block Line Chomping</title>

        <para>
          YAML allows empty comment lines to follow a block scalar content, in
          order to visually separate it from the following node. To allow the
          representation of trailing empty lines in the content of block
          scalars, YAML supports three different <quote>chomping</quote>
          mechanisms for such content:
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <para>
                <anchor id="syntax-strip" />strip
              </para>
            </term>

            <listitem>
              <para>
                The line break character of the last non-empty line, if any,
                and any trailing empty lines are not considered to be a part of
                the scalar's content. This behavior is specified using the
                <link
                linkend="c-strip"><quote><userinput>-</userinput></quote></link>
                chomp indicator.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <para>
                <anchor id="syntax-clip" />clip
              </para>
            </term>

            <listitem>
              <para>
                The line break character of the last non-empty line, if any, is
                considered to be a part of the scalar's content. Any trailing
                empty lines are not considered to be a part of the value. This
                is the default behavior.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <para>
                <anchor id="syntax-keep" />keep
              </para>
            </term>

            <listitem>
              <para>
                The line break character of the last non-empty line, if any,
                and any trailing empty lines are considered to be a part of the
                scalar's content. This behavior is specified using the <link
                linkend="c-keep"><quote><userinput>+</userinput></quote></link>
                chomp indicator.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>
          Block scalars are clipped, unless an explicit chomp <link
          linkend="c-chomp-indicator(t)">indicator</link> is specified. When
          this functionality is implied, the <link
          linkend="b-chomped-break(t)">b-chomped-break(t)</link> and <link
          linkend="l-trail-chomped(n,t)">l-trail-chomped(n,t)</link>
          productions are used.
        </para>

        <productionset>
          <production id="b-chomped-break(t)">
            <lhs>b-chomped-break(t)</lhs>
            <rhs>
              <varname>t</varname> = strip &rArr;
              <nonterminal def="#b-chomped-strip" /><sbr />
              <varname>t</varname> = clip&nbsp; &rArr;
              <nonterminal def="#b-chomped-keep" /><sbr />
              <varname>t</varname> = keep&nbsp; &rArr;
              <nonterminal def="#b-chomped-keep" />
            </rhs>
          </production>

          <production id="b-chomped-strip">
            <lhs>b-chomped-strip</lhs>
            <rhs>
              <nonterminal def="#b-ignored-any" />
            </rhs>
          </production>

          <production id="b-chomped-keep">
            <lhs>b-chomped-keep</lhs>
            <rhs>
              <nonterminal def="#b-normalized" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Final Chomped Lines Breaks</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
# Clipped line breaks:
clip: |
  Text line<hl2>&darr;</hl2>
  <hl4>&darr;</hl4>
 <hl4>&dArr;</hl4>
<hl4>&para;</hl4>
 # Stripped line breaks:
<hl4>&darr;</hl4>
strip: >-
  Text line<hl2>&para;</hl2>
  <hl4>&darr;</hl4>
 <hl4>&dArr;</hl4>
<hl4>&para;</hl4>
# Keep everything:
<hl4>&dArr;</hl4>
keep: |+
  Text line<hl1>&dArr;</hl1>
  <hl4>&darr;</hl4>
 <hl4>&dArr;</hl4>
<hl4>&para;</hl4>
 # That's all.
<hl4>&para;</hl4>
...
# Legend:
#   <hl1><link linkend="b-chomped-strip">b-chomped-strip</link></hl1>
#   <hl2><link linkend="b-chomped-keep">b-chomped-keep</link></hl2>
#   <hl4>not chomped line break</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "clip":
    !str "Text line\n",
  !str "strip":
    !str "Text line",
  !str "keep":
    !str "Text line\L\n\L\P"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="l-trail-comments">
            <lhs>l-trail-comments</lhs>
            <rhs>
              <nonterminal def="#l-text-comment(n)"
                >l-text-comment(&lt;n)</nonterminal>
              <nonterminal def="#l-comment" />*
            </rhs>
          </production>

          <production id="l-trail-chomped(n,t)">
            <lhs>l-trail-chomped(n,t)</lhs>
            <rhs>
              <varname>t</varname> = strip &rArr;
              <nonterminal def="#l-trail-chomped-strip(n)" /><sbr />
              <varname>t</varname> = clip&nbsp; &rArr;
              <nonterminal def="#l-trail-chomped-strip(n)" /><sbr />
              <varname>t</varname> = keep&nbsp; &rArr;
              <nonterminal def="#l-trail-chomped-keep(n)" />
            </rhs>
          </production>

          <production id="l-trail-chomped-strip(n)">
            <lhs>l-trail-chomped-strip(n)</lhs>
            <rhs>
              <nonterminal def="#l-empty-comment(n)" />*<sbr />
              <nonterminal def="#l-trail-comments" />?
            </rhs>
          </production>

          <production id="l-trail-chomped-keep(n)">
            <lhs>l-trail-chomped-keep(n)</lhs>
            <rhs>
              <nonterminal def="#l-empty-line(n,c)"
                >l-empty-line(n,block)</nonterminal>*<sbr />
              <nonterminal def="#l-trail-comments" />?
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Trailing Chomped Empty Lines</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
# Clip trailing lines:
clip: |
  Text line&darr;
<hl1>  &darr;</hl1>
<hl1> &dArr;</hl1>
<hl1>&para;</hl1>
 # Strip final break:
<hl4>&darr;</hl4>
strip: >-
  Text line&para;
<hl1>  &darr;</hl1>
<hl1> &dArr;</hl1>
<hl1>&para;</hl1>
# Keep everything:
<hl4>&dArr;</hl4>
keep: |+
  Text line&dArr;
<hl2>  &darr;</hl2>
<hl2> &dArr;</hl2>
<hl2>&para;</hl2>
 # That's all.
<hl4>&para;</hl4>
...
# Legend:
#   <hl1><link linkend="l-trail-chomped-strip(n)">l-trail-chomped-strip</link></hl1>
#   <hl2><link linkend="l-trail-chomped-keep(n)">l-trail-chomped-keep</link></hl2>
#   <hl4>not trailing empty line</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "clip":
    !str "Text line\n",
  !str "strip":
    !str "Text line",
  !str "keep":
    !str "Text line\L\n\L\P"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-nodes" />Nodes</title>

      <para>
        The YAML character stream consists mainly of a sequence of nodes, each
        presenting a single serialization node. Each node may have two optional
        <link linkend="syntax-properties">properties</link>, <link
        linkend="syntax-anchor">anchor</link> and <link
        linkend="syntax-tag">tag</link>, in addition to its <link
        linkend="syntax-content">content</link>.
      </para>

      <sect2>
        <title><anchor id="syntax-anchor" />Node Anchor</title>

        <para>
          The anchor node property marks a node for future reference. Anchors
          are presented in the character stream using the anchor indicator
          <link linkend="c-anchor"
          ><quote><userinput>&amp;</userinput></quote></link>. An <link
          linkend="syntax-alias">alias</link> node can then be used to indicate
          additional inclusions of the anchored node by specifying its anchor.
          An anchored node need not be referenced by any alias node; in
          particular, it is valid for all nodes to be anchored. Note that the
          anchor is not part of the YAML representation encoded in the
          character stream. Specifically, a YAML processor must not use the
          anchor's name when composing the representation, and the processor
          need not preserve the anchor once the representation is composed.
        </para>

        <productionset>
          <production id="c-ns-anchor-property">
            <lhs>c-ns-anchor-property</lhs>
            <rhs>
              <nonterminal def="#c-anchor"><quote>&amp;</quote></nonterminal>
              <nonterminal def="#ns-anchor-name" />
            </rhs>
          </production>

          <production id="ns-anchor-name">
            <lhs>ns-anchor-name</lhs>
            <rhs>
              <nonterminal def="#ns-char" />+
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Anchor Property</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting># Clipped line breaks:<sbr />
first occurence: <HL><hl1>&amp;<hl2>id!12[3#4]</hl2></hl1></HL>
    Some text
second occurence: <HL><hl4>*<hl2>id!12[3#4]</hl2></hl4></HL>
...
# Legend:
#   <hl1><link linkend="c-ns-anchor-property">c-ns-anchor-property</link></hl1>
#   <hl2><link linkend="ns-anchor-name">ns-anchor-name</link></hl2>
#   <hl4>not anchor property</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "first occurence":
    &amp;anchor !str "Some text\n",
  !str "second occurence":
    *anchor
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-tag" />Node Tag</title>

        <para>
          The tag node property identifies the type of data presented by the
          node through a <link linkend="model-tag">URI</link>. Unlike <link
          linkend="syntax-anchor">anchors</link>, tags are part of the
          document's representation graph. The YAML processor is responsible
          for <link linkend="model-resolve">resolving</link> tags which are not
          present in the character stream. Tags are presented in the character
          stream using the tag indicator, <link
          linkend="c-tag"><quote><userinput>!</userinput></quote></link>. YAML
          tags are written using a shorthand syntax rather than the full URI
          notation. In addition, YAML provides a prefix mechanism for compact
          tag presentation,
        </para>

        <example>
          <title>Tag Property</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
explicit string: <hl1>!str</hl1> '12'
explicit integer: <hl1>!int</hl1> '12'
...
# Legend:
#   <hl1><link linkend="c-ns-tag-property">c-ns-tag-property</link></hl1>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "explicit string":
    !str "12",
  !str "explicit int":
    !int "12"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <sect3>
          <title><anchor id="syntax-tag-escape" />Tag Escaping</title>

          <para>
            YAML allows arbitrary Unicode characters to be used in a tag by
            using <link linkend="syntax-escape">escape sequences</link>. The
            processor must expand such escape sequences before reporting the
            tag to the application. It is an error for a tag to contain invalid
            escape sequences.
          </para>

          <para>
            Sometimes it may be helpful for a YAML tag to be expanded to its
            full URI form. A YAML processor may provide a mechanism to
            perform such expansion. Since URIs support a limited ASCII-based
            character set, this expansion requires all characters outside
            this set to be encoded in UTF-8 and the resulting bytes to be
            encoded using <quote><userinput>%</userinput></quote> notation
            with upper-case hexadecimal digits. Further details on the URI
            encoding requirements are given in <ulink
            url="http://www.ietf.org/rfc/rfc2396.txt">RFC2396</ulink>.
          </para>

          <productionset>
            <production id="ns-tag-char">
              <lhs>ns-tag-char</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal def="#ns-esc-sequence" /><sbr />
                | ( <nonterminal def="#ns-char" />
                - <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
                - <nonterminal def="#c-prefix"><quote>^</quote></nonterminal> )
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Tag Escaping</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
# The following nodes have
# the same tag URI:
# 'tag:domain.tld,2002/a%3C%0A%25b'.
- !domain.tld,2002/a<hl1>&lt;</hl1><hl1>\n</hl1><hl1>%</hl1>b a
- !domain.tld,2002/a<hl1>\x3c</hl1><hl1>\x0A</hl1><hl1>%</hl1>b b
...
# Legend:
#   Unconventional <hl1><link linkend="ns-tag-char">ns-tag-char</link></hl1>s
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !domain.tld,2002/a\x3c\x0A%b "a"
  !domain.tld,2002/a\x3c\x0A%b "b"
]
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-tag-prefix" />Tag Prefixing</title>

          <para>
            YAML provides a convenient prefix mechanism for the common case
            where a node and (most of) its descendants have tags whose
            shorthand forms share a common prefix. If a node's tag property is
            of the form
            <varname>prefix</varname><userinput>^</userinput><varname
            >suffix</varname>, the <quote><userinput>^</userinput></quote>
            character is discarded from the tag. If a descendant node's tag
            property is of the form
            <userinput>^</userinput><varname>foo</varname>, it is treated as if
            it was written <varname>prefix</varname><varname>foo</varname>
            where <varname>prefix</varname> comes from the most recent ancestor
            that established a prefix. Note that this mechanism is purely
            syntactical and does not imply any additional semantics. In
            particular, the prefix must not be assumed to be an identifier for
            anything. It is possible to include a
            <quote><userinput>^</userinput></quote> character in a tag by <link
            linkend="syntax-escape">escaping</link> it. It is an error for a
            node's tag property to contain more than one unescaped
            <quote><userinput>^</userinput></quote> character, or for the tag
            property to begin with <quote><userinput>^</userinput></quote>
            unless the node is a descendant of an ancestor that established a
            tag prefix.
          </para>

          <productionset>
            <production id="c-ns-tag-property">
              <lhs>c-ns-tag-property</lhs>
              <rhs>
                <nonterminal def="#c-tag"><quote>!</quote></nonterminal><sbr />
                ( <nonterminal def="#c-ns-private-tag" /><sbr />
                | <nonterminal def="#ns-global-tag" /><sbr />
                | ( Prefix-of-above?<sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                  def="#c-prefix"><quote>^</quote></nonterminal><sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;Suffix-of-above ) )
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Private Tags</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting># The tag URI is:<sbr />
# 'tag:domain.tld,2002:invoice'
--- !<hl1>domain.tld,2002/</hl1><hl3>^</hl3><hl2>invoice</hl2>
  # The tag URI is:
  # 'tag:yaml.org,2002:seq'.
  customers: !<hl4>seq</hl4>
    # The tag URI is:
    # 'tag:domain.tld,2002:customer'
    - !<hl3>^</hl3><hl2>customer</hl2>
      given : Chris
      family : Dumars
...
# Legend:
#   <hl1>prefix</hl1>
#   <hl3><link linkend="c-prefix">c-prefix</link></hl3>
#   <hl2>suffix</hl2>
#   <hl4>neither</hl4>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!domain.tld,2002/invoice {
  !str "customers":
    !seq [
      !domain.tld,2002/customer {
        !str "given":
          !str "Chris",
        !str "family":
          !str "Dumars"
      }
    ]
}
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-tag-short" />Tag Shorthands</title>

          <para>
            To increase readability, YAML does not use the full tag URI
            notation in the character stream. Instead, it provides several
            shorthand notations for different groups of tags. If a tag may
            be written using more than one shorthand, the shortest format
            must be used. A processor need not expand shorthand tags to a
            full URI form. However, in such a case the processor must still
            perform <link linkend="syntax-escape">escaping</link>. These
            rules ensure that each tag's shorthand is globally unique.
          </para>

          <itemizedlist>
            <listitem>
              <para>
                If a tag property is of the form
                <userinput>!</userinput><varname>foo</varname>, it is a
                shorthand for the <link
                linkend="model-private">private</link> tag URI
                <userinput>tag:private.yaml.org,2002:</userinput
                ><varname>foo</varname>. The semantics of private tags
                may be different in each document.
              </para>
            </listitem>
          </itemizedlist>

            <productionset>
              <production id="c-ns-private-tag">
                <lhs>c-ns-private-tag</lhs>
                <rhs>
                  <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
                  <nonterminal def="#ns-tag-char" />+
                </rhs>
              </production>
            </productionset>

            <example>
              <title>Private Tags</title>
              <simplelist type="horiz" columns="2">
                <member>
<programlisting># In both documents, the tag URI is:<sbr />
# 'tag:private.yaml.org,2002:ball'
# However, the tag semantics in
# each document are unrelated.
---
pool: !<hl1>!ball</hl1>
  number: 8
---
bearing: !<hl1>!ball</hl1>
  material: steel
...
# Legend:
#   <hl1><link linkend="c-ns-private-tag">c-ns-private-tag</link></hl1>
</programlisting>
                </member>
                <member>
<programlisting>---<sbr />
!map {
  !str "pool":
    !!ball {
      !str "number":
        !int "8"
    }
  }
...
---
!map {
  !str "bearing":
    !!ball {
      !str "material":
        !str "steel"
    }
}
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <itemizedlist>
            <listitem>
              <para>
                If a tag property <varname>foo</varname> contains no <link
                linkend="c-path"><quote><userinput>/</userinput></quote></link>
                and no <quote><userinput>:</userinput></quote> characters, it
                is a shorthand for the tag URI
                <userinput>tag:yaml.org,2002:</userinput
                ><varname>foo</varname>. The <userinput>yaml.org</userinput>
                domain is used to define the core and universal YAML data
                types.
              </para>
            </listitem>
          </itemizedlist>

          <productionset>
            <production id="ns-core-tag">
              <lhs>ns-core-tag</lhs>
              <rhs>
                ( <nonterminal def="#ns-tag-char" />
                - <quote>:</quote>
                - <nonterminal def="#c-path"><quote>/</quote></nonterminal>
                - <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
                )<sbr />
                ( <nonterminal def="#ns-tag-char" />
                - <quote>:</quote>
                - <nonterminal def="#c-path"><quote>/</quote></nonterminal>
                )*
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Core Tags</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting># The URI is:<sbr />
# 'tag:yaml.org,2002:str'
--- !<hl1>seq</hl1>
- !<hl1>str</hl1> Unicode string
...
# Legend:
#   <hl1><link linkend="ns-core-tag">ns-core-tag</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !str "Unicode string"
]
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <itemizedlist>
            <listitem>
              <para>
                If the tag property is of the form
                <varname>vocabulary</varname><userinput
                >/</userinput><varname>foo</varname> where
                <varname>vocabulary</varname> is a single word, it is a
                shorthand for the tag URI
                <userinput>tag:</userinput><varname>vocabulary</varname
                ><userinput>.yaml.org,2002:</userinput><varname>foo</varname>.
                Each domain
                <varname>vocabulary</varname><userinput>.yaml.org</userinput>
                is used for tags specific to the given vocabulary, such as a
                particular programming language.
              </para>
            </listitem>
          </itemizedlist>

          <productionset>
            <production id="ns-vocabulary-tag">
              <lhs>ns-vocabulary-tag</lhs>
              <rhs>
                <nonterminal def="#ns-word-char" />+
                <nonterminal def="#c-path"><quote>/</quote></nonterminal>
                <nonterminal def="#ns-tag-char" />*
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Vocabulary Tags</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
# The URI is:
# 'tag:perl.yaml.org,2002:Text::Tabs'
- !<hl1>perl/Text::Tabs</hl1> {}
...
# Legend:
#   <hl1><link linkend="ns-vocabulary-tag">ns-vocabulary-tag</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !perl/Text::Tabs {
  }
]
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Invalid Vocabulary Tags</title>
            <simplelist type="horiz" columns="2">
              <member>
<screen>---
- !private/ball ""
...
</screen>
              </member>
              <member>
<screen>ERROR:
  To keep shorthands unique, use the
  shortest applicable form (!!ball).
</screen>
              </member>
            </simplelist>
          </example>

          <itemizedlist>
            <listitem>
              <para>
                Otherwise, the tag property must be of the form
                <varname>domain</varname><userinput
                >,</userinput><varname>date</varname><userinput
                >/</userinput><varname>foo</varname>, which is a shorthand for
                the tag URI <userinput>tag:</userinput><varname>domain</varname
                ><userinput>,</userinput><varname>date</varname><userinput
                >/</userinput><varname>foo</varname>. To ensure uniqueness, the
                day must be omitted if it is the 1st of the month, and the
                month and day must be omitted for January 1st. Such tags may be
                freely minted at any time by the owners of the domain at the
                specified date.
              </para>
            </listitem>
          </itemizedlist>

          <productionset>
            <production id="ns-domain-year">
              <lhs>ns-domain-year</lhs>
              <rhs>
                <nonterminal def="#ns-decimal-digit" /> x 4
              </rhs>
            </production>

            <production id="ns-domain-month">
              <lhs>ns-domain-month</lhs>
              <rhs>
                <nonterminal def="#ns-decimal-digit" /> x 2
              </rhs>
            </production>

            <production id="ns-domain-day">
              <lhs>ns-domain-day</lhs>
              <rhs>
                <nonterminal def="#ns-decimal-digit" /> x 2
              </rhs>
            </production>

            <production id="ns-domain-tag">
              <lhs>ns-domain-tag</lhs>
              <rhs>
                <nonterminal def="#ns-word-char" />+<sbr />
                (
                <nonterminal def="#c-domain"><quote>.</quote></nonterminal>
                <nonterminal def="#ns-word-char" />+ )<sbr />
                <nonterminal def="#c-date"><quote>,</quote></nonterminal>
                <nonterminal def="#ns-domain-year" /><sbr />
                ( <quote>-</quote>
                <nonterminal def="#ns-domain-month" /><sbr />
                &nbsp;&nbsp;( <quote>-</quote>
                <nonterminal def="#ns-domain-day" /> )? )?<sbr />
                <nonterminal def="#c-path"><quote>/</quote></nonterminal>
                <nonterminal def="#ns-tag-char" />*
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Domain Tags</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
# The URI is:
# 'tag:clarkevans.com,2003-02:graph'
- !<hl1>clarkevans.com,2003-02/graph</hl1>
...
# Legend:
#   <hl1><link linkend="ns-domain-tag">ns-domain-tag</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !clarkevans.com,2003-02/graph ""
]
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Invalid Domain Tags</title>
            <simplelist type="horiz" columns="2">
              <member>
<screen>---
- !clarkevans.com,2003-02-01/graph ""
- !clarkevans.com,2003-01/graph ""
...
</screen>
              </member>
              <member>
<screen>ERROR:
  To keep shorthands unique, it is
  forbidden to explicitly specify
  the 1st of the month or January 1st.
</screen>
              </member>
            </simplelist>
          </example>

          <itemizedlist>
            <listitem>
              <para>
                The above are all the valid tag shorthand notations. In
                particular, YAML forbids using a URI scheme other than
                <quote><userinput>tag:</userinput></quote>, and the complete
                tag URI must not be presented.
              </para>
            </listitem>
          </itemizedlist>

          <productionset>
            <production id="ns-global-tag">
              <lhs>ns-global-tag</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal def="#ns-core-tag" /><sbr />
                | <nonterminal def="#ns-vocabulary-tag" /><sbr />
                | <nonterminal def="#ns-domain-tag" />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Invalid Tag Presentation</title>
            <simplelist type="horiz" columns="2">
              <member>
<screen>---
- !http://www.yaml.org/bing invalid
- !tag:yaml.org,2002:str invalid
...
</screen>
              </member>
              <member>
<screen>ERROR:
  Only the tag shorthand is allowed
  in the character stream. URIs,
  including tag: URIs, are forbidden.
</screen>
              </member>
            </simplelist>
          </example>
        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="syntax-properties" />Node Properties</title>

        <para>
          Node properties may be specified in any order before the node's
          content, and any or both may be omitted from the presentation stream.
          A node without an anchor can not be referenced by <link
          linkend="syntax-alias">alias</link> nodes. A node without a tag is
          subject to <link linkend="model-resolve">tag resolution</link>.
        </para>

        <productionset>
          <production id="c-ns-properties(n,c)">
            <lhs>c-ns-properties(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;( <nonterminal def="#c-ns-tag-property" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;(
              <nonterminal def="#s-seperate-spaces(n,c)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#c-ns-anchor-property" /> )? )<sbr />
              | ( <nonterminal def="#c-ns-anchor-property" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;(
              <nonterminal def="#s-seperate-spaces(n,c)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#c-ns-tag-property" /> )? )
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Node Properties</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>--- <hl1>!seq</hl1><sbr />
anchored: <hl1>&amp;anchor
  !str</hl1> Some text
<hl1>!str</hl1> alias: <hl4>*anchor</hl4>
...
# Legend:
# <hl1><link linkend="c-ns-properties(n,c)">c-ns-properties</link></hl1>
# <hl4>not properties</hl4>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!seq [
  !str "anchored":
    !str &amp;anchor "Some text",
  !str "alias":
    *anchor
]
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-content" />Node Content</title>

        <para>
          Node content may be presented in either a flow or a block style.
          Block content always extends to the end of a line and uses
          indentation to denote structure, while flow content ends at some
          non-space character within a line and uses indicators to denote
          structure. Each kind of content (scalar, sequence or mapping)
          provides several presentation styles. Scalar content may be presented
          in one of two block styles and three flow styles. In contrast,
          collection content may be presented in a single flow style or a
          single block style. However, each of the collection kinds provides
          several compact syntax forms for common cases. The following figure
          lists all the combinations of content kind and style:
        </para>

        <figure>
          <title>Kind/Style Combinations</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="styles2.eps" format="eps" />
            </imageobject>
          </mediaobject>
        </figure>

        <productionset>
          <production id="ns-flow-scalar(n,c)">
            <lhs>ns-flow-scalar(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#c-double-quoted(n,c)" /><sbr />
              | <nonterminal def="#c-single-quoted(n,c)" /><sbr />
              | <nonterminal def="#ns-plain(n,c)" />
            </rhs>
          </production>

          <production id="c-flow-collection(n,c)">
            <lhs>c-flow-collection(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#c-flow-sequence(n,c)" /><sbr />
              | <nonterminal def="#c-flow-mapping(n,c)" />
            </rhs>
          </production>

          <production id="ns-flow-content(n,c)">
            <lhs>ns-flow-content(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#ns-flow-scalar(n,c)" /><sbr />
              | <nonterminal def="#c-flow-collection(n,c)" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Node Content</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
flow styles:
  scalars:
    plain: !str <hl1>some text</hl1>&darr;
    quoted:
      single: <hl1>'some text'</hl1>&darr;
      double: <hl1>"some text"</hl1>&darr;
  collections:
    sequence: !seq <HL><hl2>[ !str entry,
      <hl4># Mapping entry:&darr;</hl4>
        key: value ]</hl2></HL>&darr;
    mapping: <hl2>{ key: value }</hl2>&darr;
...
Legend:
#   <hl1><link linkend="ns-flow-scalar(n,c)">ns-flow-scalar</link></hl1>
#   <hl2><link linkend="c-flow-collection(n,c)">c-flow-collection</link></hl2>
#   <hl4><link linkend="c-b-throwaway-comment">not content</link></hl4>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "flow styles":
    !map {
      !str "scalars":
        !map {
          !str "plain":
            !str "some text",
          !str "quoted":
            !map {
              !str "single":
                !str "some text",
              !str "double":
                !str "some text"
            }
        },
      !str "collections":
        !map {
          !str "sequence":
            !seq [
              !str "entry",
              !map {
                !str "key":
                  !str "value"
              }
            ],
          !str "mapping":
            !map {
              !str "key":
                !str "value"
            }
        }
    },
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="c-l-block-scalar(n)">
            <lhs>c-l-block-scalar(n)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#c-l-folded(n)" /><sbr />
              | <nonterminal def="#c-l-literal(n)" />
            </rhs>
          </production>

          <production id="c-l-block-collection(n,c)">
            <lhs>c-l-block-collection(n,c)</lhs>
            <rhs>
              <nonterminal def="#c-b-throwaway-comment" /><sbr />
              <nonterminal def="#l-comment" />*<sbr />
              ( <nonterminal def="#l-block-sequence(n,c)" /><sbr />
              | <nonterminal def="#l-block-mapping(n)" /> )
            </rhs>
          </production>

          <production id="c-l-block-content(n,c)">
            <lhs>c-l-block-content(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#c-l-block-scalar(n)" /><sbr />
              | <nonterminal def="#c-l-block-collection(n,c)" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Node Content</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
block styles:
  scalars:
    literal: <hl1>|
      #!/usr/bin/perl
      print "Hello, world!\n";&darr;</hl1>
    folded: <hl1>&gt;
      Which of the following is the
      currency used in Albania?
        A [ ] Kwacha
        B [ ] Lek
      Etc.&darr;</hl1>
  collections: !seq
    sequence: !seq <HL><hl2><hl4># Entry:&darr;</hl4>
      - entry
      <hl4># Mapping entry:&darr;</hl4>
      - key: value&darr;</hl2></HL>
    mapping: !map<hl2>&darr;
      key: value&darr;</hl2>
...
Legend:
#   <hl1><link linkend="c-l-block-scalar(n)">c-l-block-scalar</link></hl1>
#   <hl2><link linkend="c-l-block-collection(n,c)">c-l-block-collection</link></hl2>
#   <hl4><link linkend="c-b-throwaway-comment">not content</link></hl4>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "block styles":
    !map {
      !str "scalars":
        !map {
          !str "literal":
            !str "#!/usr/bin/perl\n\
              print \"Hello,
              world!\\n\";\n",
          !str "folded":
            !str "Which of the
              following is the
              currency used in
              Albania?\n\
              \  A [ ] Kwacha\n\
              \  B [ ] Lek\n\
              Etc.\n"
        },
      !str "collections":
        !map {
          !str "sequence":
            !seq [
              !str "entry",
              !map {
                !str "key":
                  !str "value"
              }
            ],
          !str "mapping":
            !map {
              !str "key":
                !str "value"
            }
        }
    }
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-alias" />Alias Node</title>

        <para>
          Subsequent occurrences of a previously serialized node are presented
          as alias nodes. The first occurrence of the node must be marked by an
          <link linkend="syntax-anchor">anchor</link> to allow subsequent
          occurrences to be presented as alias nodes. An alias refers to the
          most recent <link linkend="model-key-order">preceding</link> node
          having the same anchor. It is an error to have an alias use an anchor
          that does not occur previously in the serialization of the document.
          It is not an error to specify an anchor that is not used by any alias
          node. Note that an alias node may not specify any properties or
          content, as these were already specified at the first occurrence of
          the node.
        </para>

        <productionset>
          <production id="c-ns-alias-node">
            <lhs>c-ns-alias-node</lhs>
            <rhs>
              <nonterminal def="#c-alias"><quote>*</quote></nonterminal>
              <nonterminal def="#ns-anchor-name" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Alias Node</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
anchor : <hl4>&amp;A001</hl4> Anchored scalar
override : <hl4>&amp;A001</hl4> The alias node below
  is a repeated use of this text.
alias : <hl1>*A001</hl1>
...
# Legend:
#   <hl1><link linkend="c-ns-alias-node">c-ns-alias-node</link></hl1>
#   <hl4>not alias node</hl4>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "anchor":
    &amp;B002 !str "Anchored scalar",
  !str "override":
    &amp;C003 !str "The alias node
      below is a repeated use of this
      text.",
  !str alias: *C003,
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-complete-node" />Complete Node</title>

        <para>
          A complete node consists of the node properties followed by the
          node's content. Both the properties and the content are optional. A
          node with empty content is considered to be in the plain scalar
          style. To prevent ambiguities, a node used as a a simple key may not
          be completely empty. An alias node is considered to be a second
          occurrence of the complete node (both properties and content). Inside
          a flow collection, only flow node styles may be used. In contrast,
          block collections may contain both block style nodes and flow style
          nodes followed by a line break (with an optional comment).
        </para>

        <productionset>
          <production id="s-l-empty-node">
            <lhs>s-l-empty-node</lhs>
            <rhs>
              /* implicit empty plain content */<sbr />
              ( <nonterminal def="#s-discarded-spaces" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#c-nb-throwaway-text" />? )?<sbr />
              <nonterminal def="#b-ignored-any" /><sbr />
              <nonterminal def="#l-comment" />*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Completely Empty Node</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
completely empty:<hl1>&darr;</hl1>
with spaces:<hl1> &darr;</hl1>
with comments:<hl1> # empty plain&darr;
  # scalar value&darr;</hl1>
...
# Legend:
#   <hl1><link linkend="s-l-empty-node">s-l-empty-node</link></hl1>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "completely empty":
    !str "",
  !str "with spaces":
    !str "",
  !str "with comment":
    !str "",
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="ns-flow-node(n,c)">
            <lhs>ns-flow-node(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal def="#c-ns-alias-node" /><sbr />
              | ( ( <nonterminal def="#c-ns-properties(n,c)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#s-seperate-spaces(n,c)" /> )?<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#ns-flow-content(n,c)" /> )<sbr />
              | <nonterminal def="#c-ns-properties(n,c)" /><sbr />
              &nbsp;&nbsp;/* implicit empty plain content */
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Node in Flow Context</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
{
  <hl1>content</hl1>: <hl1>"foo"</hl1>,
  <hl1>anchored</hl1>: <hl1>&amp;a0 # for alias
    bar</hl1>,
  <hl1>alias</hl1>: <hl1>*a0</hl1>,
  <hl1>empty</hl1>: # implicit
    <hl1>!str</hl1> # plain content
}
...
# Legend:
#   <hl1><link linkend="ns-flow-node(n,c)">ns-flow-node</link></hl1>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "content":
    !str "foo",
  !str "anchored":
    &amp;a1 !str "bar",
  !str "alias":
    *anchor,
  !str "empty":
    !str ""
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="ns-l-flow-in-block(n,c)">
            <lhs>ns-l-flow-in-block(n,c)</lhs>
            <rhs>
              <nonterminal def="#ns-flow-node(n,c)"
                  >ns-flow-node(n,flow-out)</nonterminal><sbr />
              <nonterminal def="#s-b-seperated-comment" /><sbr />
              <nonterminal def="#l-comment" />*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Flow Node in Block Context</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
<hl4>content</hl4>: <hl1>"foo"&darr;</hl1>
<hl4>anchored</hl4>: <hl1>&amp;a0 # for alias
    bar&darr;</hl1>
<hl4>alias</hl4>: <hl1>*a0&darr;</hl1>
<hl4>empty</hl4>: <hl1># implicit
  !str # plain content&darr;</hl1>
<hl4>in seq</hl4>:
- <hl1>"content"&darr;</hl1>
- <hl1>!str # implicit plain content&darr;</hl1>
...
# Legend:
#   <hl1><link linkend="ns-l-flow-in-block(n,c)">ns-l-flow-in-block</link></hl1>
#   <hl4>not flow-in-block</hl4>
# TODO: [ a, b ]#ERROR no space
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "content":
    !str "foo",
  !str "anchored":
    &amp;a1 !str "bar",
  !str "alias":
    *anchor,
  !str "empty":
    !str "",
  !str "seq":
    !seq [
      !str "content",
      !str "",
    ]
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="ns-l-block-in-block(n,c)">
            <lhs>ns-l-block-in-block(n,c)</lhs>
            <rhs>
              ( <nonterminal
                  def="#c-ns-properties(n,c)" /><sbr />
              &nbsp;&nbsp;<nonterminal
                def="#s-seperate-spaces(n,c)" /> )?<sbr />
              <nonterminal def="#c-l-block-content(n,c)" />
            </rhs>
          </production>

          <production id="ns-l-block-node(n,c)">
            <lhs>ns-l-block-node(n,c)</lhs>
            <rhs>
              &nbsp;&nbsp;<nonterminal
                def="#ns-l-block-in-block(n,c)" /><sbr />
              | <nonterminal def="#ns-l-flow-in-block(n,c)" />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Block Node in Block Context</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---<sbr />
folded: <hl1>!str
    >-
  Word-wrapped
  text lines.&darr;
&darr;</hl1>
literal: <hl1>|
  #!/usr/bin/perl
  print "Source code\n";&darr;</hl1>
sequence:<hl1>&darr;
- One
- Two&darr;</hl1>
mapping: # Key order need
  <hl1>!car   # not be preserved.
    make: Ferrari
    color: red
    price: If you have to ask...&darr;</hl1>
...
# Legend:
#   <hl1><link linkend="ns-l-block-in-block(n,c)">ns-l-block-in-block</link></hl1>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "folded":
    !str "Word-wrapped text lines.",
  !str "literal":
    !str "#!/usr/bin/perl\n\
         print \"Source code\\n\";\n",
  !str "sequence":
    !seq [
      !str "One",
      !str "Two",
    ]
  !str "mapping":
    !car {
      !str "make":
        !str "Ferrari",
      !str "color":
        !str "red",
      !str "price":
        !str "If you have to ask..."
    }
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-scalar" />Scalar Content</title>

      <para>
        YAML provides three flow styles and two block styles to choose from for
        presenting scalar contents, depending upon the readability
        requirements. Throwaway <link linkend="syntax-comment">comments</link>
        may precede or follow scalar content, but may not appear inside it.
        The comment lines following plain or block scalar content must be
        less indented than the content itself. Empty lines in a scalar content
        that are followed by a non-empty content line are interpreted as
        content rather than as implicit comments. Such lines may be less
        indented than the non-empty content lines.
      </para>

      <sect2>
        <title><anchor id="syntax-flow-scalars" />Flow Scalar Styles</title>

        <para>
          All flow scalar styles may span multiple lines, except for when used
          in simple keys. Content line breaks are subject to flow line <link
          linkend="syntax-flow-fold">folding</link>. This allows flow scalar
          content to be broken anywhere a single space character
          (<userinput>#x20</userinput>) separates non-space characters, at the
          cost of requiring an empty line to present each <link
          linkend="b-line-feed">line feed</link> character.
        </para>

        <sect3>
          <title><anchor id="syntax-double" />Double Quoted</title>

          <para>
            The double quoted flow scalar style is indicated by surrounding
            <link linkend="c-double-quote"><quote><userinput
            >"</userinput></quote></link> characters. This is the only style
            capable of expressing arbitrary Unicode strings, at the cost of
            some verbosity: escaping line breaks and the printable <link
            linkend="c-escape"><quote><userinput>\</userinput></quote></link>
            and <link linkend="c-double-quote"
            ><quote><userinput>"</userinput></quote></link> characters. It is
            an error for double quoted content to contain invalid escape
            sequences. If a line break is <link
            linkend="syntax-escape">escaped</link> it is excluded from the
            content, while white space preceding the break is preserved. This
            allows double quoted content to be broken at arbitrary positions.
          </para>

          <productionset>
            <production id="nb-double-char">
              <lhs>nb-double-char</lhs>
              <rhs>
                &nbsp;&nbsp;( <nonterminal def="#nb-char" />
                - <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
                - <nonterminal def="#c-double-quote"
                    ><quote>"</quote></nonterminal> )<sbr />
                | <nonterminal def="#ns-esc-sequence" />
              </rhs>
            </production>

            <production id="ns-double-char">
              <lhs>ns-double-char</lhs>
              <rhs>
                <nonterminal def="#nb-double-char" />
                - <nonterminal def="#s-char" />
              </rhs>
            </production>

            <production id="ns-nb-double-chunk">
              <lhs>nb-ns-double-chunk</lhs>
              <rhs>
                <nonterminal def="#ns-double-char" />
                <nonterminal def="#nb-double-char" />*
              </rhs>
            </production>

            <production id="nb-ns-double-chunk">
              <lhs>nb-ns-double-chunk</lhs>
              <rhs>
                <nonterminal def="#nb-double-char" />*
                <nonterminal def="#ns-double-char" />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Double Quoted Characters</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
"<hl1>T</hl1><hl2>\"</hl2><hl1>'</hl1>"
...
# Legend:
#   <hl1><link linkend="ns-double-char">ns-double-char</link></hl1>
#   <hl2><link linkend="ns-esc-sequence">ns-esc-sequence</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!str "T\"'"
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="s-l-double-folded(n)">
              <lhs>s-l-double-folded(n)</lhs>
              <rhs>
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                <nonterminal def="#b-l-folded-break(n,c)"
                  >b-l-folded-break(n,flow)</nonterminal>
              </rhs>
            </production>

            <production id="b-l-double-escaped(n)">
              <lhs>s-l-double-escaped(n)</lhs>
              <rhs>
                <nonterminal def="#c-b-escaped" />
                <nonterminal def="#l-empty-line(n,c)"
                  >l-empty-line(n,flow)</nonterminal>*
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Double Quoted Line Breaks</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
 "<hl1>  &darr;
   &darr;</hl1>
  A  <hl2>\&darr;</hl2>
   B<hl1>&dArr;</hl1>
  C<hl2>\&dArr;
 &darr;</hl2>
  "
...
# Legend:
# <hl1><link linkend="s-l-double-folded(n)">s-l-double-folded</link></hl1>
# <hl2><link linkend="b-l-double-escaped(n)">b-l-double-escaped</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!str "\nA  B\LC\n"
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="nb-l-double-first(n)">
              <lhs>nb-l-double-first(n)</lhs>
              <rhs>
                <nonterminal def="#nb-ns-double-chunk" />?<sbr />
                ( <nonterminal def="#s-l-double-folded(n)" /><sbr />
                | ( <nonterminal def="#s-char" />*<sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                  def="#b-l-double-escaped(n)" /> ) )
              </rhs>
            </production>

            <production id="ns-l-double-folded(n)">
              <lhs>ns-l-double-folded(n)</lhs>
              <rhs>
                <nonterminal def="#ns-double-char" /><sbr />
                <nonterminal def="#nb-ns-double-chunk" />?<sbr />
                <nonterminal def="#s-l-double-folded(n)" /><sbr />
              </rhs>
            </production>

            <production id="ns-l-double-escaped(n)">
              <lhs>ns-l-double-escaped(n)</lhs>
              <rhs>
                <nonterminal def="#ns-nb-double-chunk" />?<sbr />
                <nonterminal def="#b-l-double-escaped(n)" /><sbr />
              </rhs>
            </production>

            <production id="l-double-inner(n)">
              <lhs>ns-l-double-inner(n)</lhs>
              <rhs>
                <nonterminal def="#s-indentation(n)" />
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                ( <nonterminal
                    def="#ns-l-double-folded(n)" /><sbr />
                | <nonterminal
                  def="#ns-l-double-escaped(n)" /> )
              </rhs>
            </production>

            <production id="i-nb-double-last(n)">
              <lhs>i-nb-double-last(n)</lhs>
              <rhs>
                <nonterminal def="#s-indentation(n)" />
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                <nonterminal def="#ns-nb-double-chunk" />?
              </rhs>
            </production>

            <production id="nb-double-multi(n)">
              <lhs>nb-double-multi(n)</lhs>
              <rhs>
                <nonterminal def="#nb-l-double-first(n)" /><sbr />
                ( <nonterminal def="#l-double-inner(n)" /><sbr />
                - <nonterminal def="#c-forbidden-line" /> )*<sbr />
                <nonterminal def="#i-nb-double-last(n)" />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Multi Line Double Quoted Scalars</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
- "<hl1>Some&darr;
 &darr;</hl1>
<hl3>  quoted text</hl3>"
- "<hl1>Some \&dArr;</hl1>
<hl2>   quoted text&darr;
    &darr;</hl2>
<hl3> </hl3>"
- "<hl1>\&darr;</hl1>
<hl2>  Some&darr;</hl2>
<hl2>  quoted\&darr;</hl2>
<hl3> \ text</hl3>"
...
# Legend:
# <hl1><link linkend="nb-l-double-first(n)">nb-l-double-first</link></hl1>
# <hl2><link linkend="l-double-inner(n)">l-double-inner</link></hl2>
# <hl3><link linkend="i-nb-double-last(n)">i-nb-double-last</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !str "Some\nquoted text",
  !str "Some quoted text\n",
  !str "Some quoted text",
]
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Invalid Double Quoted Inner Lines</title>
            <simplelist type="horiz" columns="2">
              <member>
<screen>"
<hl4>---&darr;</hl4>
<hl4>... </hl4>Text
"
</screen>
              </member>
              <member>
<screen>ERROR:
  Unindented content lines must not
  begin with a document start --- or
  end ... indication.
</screen>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="nb-double-single">
              <lhs>nb-double-single(n)</lhs>
              <rhs>
                <nonterminal def="#nb-double-char" />*
              </rhs>
            </production>

            <production id="nb-double-any(n)">
              <lhs>nb-double-any(n)</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal
                  def="#nb-double-single" /><sbr />
                | <nonterminal def="#nb-double-multi(n)" />
              </rhs>
            </production>

            <production id="nb-double-text(n,c)">
              <lhs>nb-double-text(n,c)</lhs>
              <rhs>
                <varname>c</varname> = flow-out &rArr;
                <nonterminal def="#nb-double-any(n)" /><sbr />
                <varname>c</varname> = flow-in&nbsp; &rArr;
                <nonterminal def="#nb-double-any(n)" /><sbr />
                <varname>c</varname> = flow-key &rArr;
                <nonterminal def="#nb-double-single" />
              </rhs>
            </production>

            <production id="c-double-quoted(n,c)">
              <lhs>c-double-quoted(n,c)</lhs>
              <rhs>
                <nonterminal
                  def="#c-double-quote"><quote>"</quote></nonterminal>
                <nonterminal def="#nb-double-text(n,c)" />
                <nonterminal
                  def="#c-double-quote"><quote>"</quote></nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>One Line Double Quoted Scalars</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
"<hl1>key\n</hl1>" :
  "<hl1> value </hl1>"
...
# Legend:
# <hl1><link linkend="nb-double-single">nb-double-single</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "key\n":
    !str " value "
}
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-single" />Single Quoted</title>

          <para>
            The single quoted flow scalar style is indicated by surrounding
            <link linkend="c-single-quote"><quote><userinput
            >'</userinput></quote></link> characters. Therefore, within a
            single quoted scalar such characters need to be <link
            linkend="ns-quoted-quote">repeated</link>. No other form of
            escaping is done. In particular, the <link
            linkend="c-single-quote"><quote><userinput
            >\</userinput></quote></link> and <link
            linkend="c-single-quote"><quote><userinput
            >"</userinput></quote></link> characters may be freely used. This
            restricts single quoted scalars to printable characters.
          </para>

          <productionset>
            <production id="ns-quoted-quote">
              <lhs>ns-quoted-quote</lhs>
              <rhs>
                <nonterminal
                  def="#c-single-quote"><quote>'</quote></nonterminal>
                <nonterminal
                  def="#c-single-quote"><quote>'</quote></nonterminal>
              </rhs>
            </production>

            <production id="nb-single-char">
              <lhs>nb-single-char</lhs>
              <rhs>
                &nbsp;&nbsp;( <nonterminal def="#nb-char" />
                - <nonterminal def="#c-single-quote"
                    ><quote>"</quote></nonterminal> )<sbr />
                | <nonterminal def="#ns-quoted-quote" />
              </rhs>
            </production>

            <production id="ns-single-char">
              <lhs>ns-single-char</lhs>
              <rhs>
                <nonterminal def="#nb-single-char" />
                - <nonterminal def="#s-char" />
              </rhs>
            </production>

            <production id="ns-nb-single-chunk">
              <lhs>nb-ns-single-chunk</lhs>
              <rhs>
                <nonterminal def="#ns-single-char" />
                <nonterminal def="#nb-single-char" />*
              </rhs>
            </production>

            <production id="nb-ns-single-chunk">
              <lhs>nb-ns-single-chunk</lhs>
              <rhs>
                <nonterminal def="#nb-single-char" />*
                <nonterminal def="#ns-single-char" />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Single Quoted Characters</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
'<hl1>T</hl1><hl1>\</hl1><hl1>"</hl1><hl2>''</hl2>'
...
# Legend:
#   <hl1><link linkend="ns-single-char">ns-single-char</link></hl1>
#   <hl2><link linkend="ns-quoted-quote">ns-quoted-quote</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!str "T\\\"'"
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="nb-l-single-first(n)">
              <lhs>nb-l-single-first(n)</lhs>
              <rhs>
                <nonterminal def="#nb-ns-single-chunk" />?<sbr />
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                <nonterminal def="#b-l-folded-break(n,c)"
                  >b-l-folded-break(n,flow)</nonterminal>
              </rhs>
            </production>

            <production id="l-single-inner(n)">
              <lhs>l-single-inner(n)</lhs>
              <rhs>
                <nonterminal def="#s-indentation(n)" /><sbr />
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                ( <nonterminal def="#ns-single-char" /><sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#nb-ns-single-chunk" />?<sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#s-discarded-spaces" />? )?<sbr />
                <nonterminal def="#b-l-folded-break(n,c)"
                  >b-l-folded-break(n,flow)</nonterminal>
              </rhs>
            </production>

            <production id="i-nb-single-last(n)">
              <lhs>i-nb-single-last(n)</lhs>
              <rhs>
                <nonterminal def="#s-indentation(n)" /><sbr />
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                <nonterminal def="#ns-nb-single-chunk" />?
              </rhs>
            </production>

            <production id="nb-single-multi(n)">
              <lhs>nb-single-multi(n)</lhs>
              <rhs>
                <nonterminal def="#nb-l-single-first(n)" /><sbr />
                ( <nonterminal def="#l-single-inner(n)" /><sbr />
                - <nonterminal def="#c-forbidden-line" /> )*<sbr />
                <nonterminal def="#i-nb-single-last(n)" />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Multi Line Single Quoted Scalars</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
- '<hl1>Some&darr;
 &darr;</hl1>
<hl3>  quoted text</hl3>'
- '<hl1>Some&dArr;</hl1>
<hl2>   quoted text&darr;
    &darr;</hl2>
<hl3> </hl3>'
- '<hl1>\&darr;</hl1>
<hl2>  Some&darr;</hl2>
<hl2>  quoted\&darr;</hl2>
<hl3> \ text</hl3>'
...
# Legend:
# <hl1><link linkend="nb-l-single-first(n)">nb-l-single-first</link></hl1>
# <hl2><link linkend="l-single-inner(n)">l-single-inner</link></hl2>
# <hl3><link linkend="i-nb-single-last(n)">i-nb-single-last</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !str "Some\nquoted text",
  !str "Some\Lquoted text\n",
  !str "\\ Some quoted\\ \\ text",
]
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Invalid Single Quoted Inner Lines</title>
            <simplelist type="horiz" columns="2">
              <member>
<screen>'
<hl4>---&darr;</hl4>
<hl4>... </hl4>Text
'
</screen>
              </member>
              <member>
<screen>ERROR:
  Unindented content lines must not
  begin with a document start --- or
  end ... indication.
</screen>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="nb-single-single">
              <lhs>nb-single-single(n)</lhs>
              <rhs>
                <nonterminal def="#nb-single-char" />*
              </rhs>
            </production>

            <production id="nb-single-any(n)">
              <lhs>nb-single-any(n)</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal
                  def="#nb-single-single" /><sbr />
                | <nonterminal def="#nb-single-multi(n)" />
              </rhs>
            </production>

            <production id="nb-single-text(n,c)">
              <lhs>nb-single-text(n,c)</lhs>
              <rhs>
                <varname>c</varname> = flow-out &rArr;
                <nonterminal def="#nb-single-any(n)" /><sbr />
                <varname>c</varname> = flow-in&nbsp; &rArr;
                <nonterminal def="#nb-single-any(n)" /><sbr />
                <varname>c</varname> = flow-key &rArr;
                <nonterminal def="#nb-single-single" />
              </rhs>
            </production>

            <production id="c-single-quoted(n,c)">
              <lhs>c-single-quoted(n,c)</lhs>
              <rhs>
                <nonterminal
                  def="#c-single-quote"><quote>"</quote></nonterminal>
                <nonterminal def="#nb-single-text(n,c)" />
                <nonterminal
                  def="#c-single-quote"><quote>"</quote></nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>One Line Single Quoted Scalars</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
'<hl1>"key\n"</hl1>' :
  '<hl1> value </hl1>'
...
# Legend:
# <hl1><link linkend="nb-single-single">nb-single-single</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "\"key\\n\"":
    !str " value "
}
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-plain" />Plain</title>

          <para>
            The plain flow scalar style uses no identifying markers, and is
            therefore the most readable, and most limited, flow scalar style.
            The exact restrictions on plain content depend on the parsing
            context. There are three different such contexts. Plain content
            outside a flow collection (flow-out context) is the least
            restricted plain scalar format. While it can't start or end with
            line break or white space characters, or start with most <link
            linkend="syntax-indicator">indicators</link>, it may contain any
            indicator except <link linkend="c-throwaway"
            ><quote>&nbsp;<userinput>#</userinput></quote></link> and <link
            linkend="c-mapping-value"
            ><quote><userinput>:</userinput>&nbsp;</quote></link>. Plain
            scalars used inside flow collections (flow-in context) are further
            restricted not to contain flow indicators. Finally, plain simple
            keys (flow-key context) are further restricted to a single line.
            When a node has no explicit content specified, it is assumed to be
            written in the plain style with the empty string as its content.
          </para>

          <productionset>
            <production id="nb-plain-char(c)">
              <lhs>nb-plain-char(c)</lhs>
              <rhs>
                <varname>c</varname> = flow-out &rArr; <nonterminal
                def="#nb-plain-char-out" /><sbr />
                <varname>c</varname> = flow-in&nbsp; &rArr; <nonterminal
                def="#nb-plain-char-key" /><sbr />
                <varname>c</varname> = flow-key &rArr; <nonterminal
                def="#nb-plain-char-key" />
              </rhs>
            </production>

            <production id="nb-plain-char-out">
              <lhs>nb-plain-char-out</lhs>
              <rhs>
                &nbsp;&nbsp;( <nonterminal def="#nb-char" />
                - <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
                - <nonterminal
                  def="#c-throwaway"><quote>#</quote></nonterminal> )<sbr />
                | ( <nonterminal
                  def="#ns-plain-char(c)">ns-plain-char(flow-out)</nonterminal>
                <nonterminal
                  def="#c-throwaway"><quote>#</quote></nonterminal> )<sbr />
                | ( <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
                <nonterminal def="#ns-plain-char(c)"
                    >ns-plain-char(flow-out)</nonterminal> )
              </rhs>
            </production>

            <production id="nb-plain-char-key">
              <lhs>nb-plain-char-key</lhs>
              <rhs>
                &nbsp;&nbsp;( <nonterminal def="#nb-char" />
                - <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
                - <nonterminal
                  def="#c-throwaway"><quote>#</quote></nonterminal>
                - <nonterminal
                  def="#c-collect-entry"><quote>,</quote></nonterminal><sbr />
                &nbsp;&nbsp;- <nonterminal
                  def="#c-sequence-start"><quote>[</quote></nonterminal>
                - <nonterminal
                  def="#c-sequence-end"><quote>]</quote></nonterminal>
                - <nonterminal
                  def="#c-mapping-start"><quote>{</quote></nonterminal>
                - <nonterminal
                  def="#c-mapping-end"><quote>}</quote></nonterminal> )<sbr />
                | ( <nonterminal
                  def="#ns-plain-char(c)">ns-plain-char(flow-key)</nonterminal>
                <nonterminal
                  def="#c-throwaway"><quote>#</quote></nonterminal> )<sbr />
                | ( <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
                <nonterminal
                  def="#ns-plain-char(c)">ns-plain-char(flow-key)</nonterminal>
                )<sbr />
                | ( <nonterminal
                  def="#c-collect-entry"><quote>,</quote></nonterminal>
                <nonterminal def="#ns-plain-char(c)"
                  >ns-plain-char(flow-key)</nonterminal> )
              </rhs>
            </production>

            <production id="ns-plain-char(c)">
              <lhs>ns-plain-char(c)</lhs>
              <rhs>
                <nonterminal def="#nb-plain-char(c)" />
                - <nonterminal def="#s-char" />
              </rhs>
            </production>

            <production id="ns-plain-first-char(c)">
              <lhs>ns-plain-first-char(c)</lhs>
              <rhs>
                &nbsp;&nbsp;( <nonterminal def="#ns-plain-char(c)" /><sbr />
                &nbsp;&nbsp;- <nonterminal def="#c-top-indicators" /> )<sbr />
                | ( ( <nonterminal
                  def="#c-sequence-entry"><quote>-</quote></nonterminal>
                | <nonterminal
                  def="#c-mapping-key"><quote>?</quote></nonterminal>
                | <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
                | <nonterminal
                  def="#c-collect-entry"><quote>,</quote></nonterminal>
                )<sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                  def="#ns-plain-char(c)" /> )
              </rhs>
            </production>

            <production id="nb-ns-plain-chunk(c)">
              <lhs>nb-ns-plain-chunk(c)</lhs>
              <rhs>
                <nonterminal def="#nb-plain-char(c)" />*
                <nonterminal def="#ns-plain-char(c)" />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Plain Characters</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
- <hl1>T</hl1><hl2>"</hl2><hl2>!</hl2>
- <hl1>?T</hl1><hl2>\</hl2><hl2>'</hl2>
- # Implicit empty plain
...
# Legend:
#   <hl1><link linkend="ns-plain-first-char(c)">ns-plain-first-char</link></hl1>
#   <hl2><link linkend="ns-plain-char(c)">ns-plain-char</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !str "T\"!",
  !str "?T\\'",
  !str ""
]
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Invalid Plain Characters</title>
            <simplelist type="horiz" columns="2">
              <member>
<screen>---
first characters: [
  -'17', <hl4>'</hl4>text, <hl4>- </hl4>text
]
outside flow:
  no <hl4> #</hl4>
  no <hl4>: </hl4>
in flow or key: [
  no <hl4> #</hl4> <hl4>, </hl4> <hl4>: </hl4>
  no <hl4>[</hl4> <hl4>]</hl4> <hl4>{</hl4> <hl4>}</hl4>
]
...
</screen>
              </member>
              <member>
<screen>ERROR:
  Plain scalars must not start with
  certain indicators and must not
  contain certain characters or
  character combinations.
</screen>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="ns-plain-single(c)">
              <lhs>ns-plain-single(c)</lhs>
              <rhs>
                <nonterminal def="#ns-plain-first-char(c)" /><sbr />
                <nonterminal def="#nb-ns-plain-chunk(c)" />?
              </rhs>
            </production>

            <production id="s-ns-plain-next(n,c)">
              <lhs>s-ns-plain-next(n,c)</lhs>
              <rhs>
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                <nonterminal
                  def="#b-l-folded-break(n,c)"
                  >b-l-folded-break(n,flow)</nonterminal>+<sbr />
                <nonterminal def="#s-indentation(n)" /><sbr />
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                <nonterminal def="#ns-plain-char(c)" /><sbr />
                <nonterminal def="#nb-ns-plain-chunk(c)" />?
              </rhs>
            </production>

            <production id="ns-plain-multi(n,c)">
              <lhs>ns-plain-multi(n,c)</lhs>
              <rhs>
                <nonterminal def="#ns-plain-single(c)" /><sbr />
                <nonterminal def="#s-ns-plain-next(n,c)" />*
              </rhs>
            </production>

            <production id="ns-plain(n,c)">
              <lhs>ns-plain(n,c)</lhs>
              <rhs>
                <varname>c</varname> = flow-out &rArr; <nonterminal
                def="#ns-plain-multi(n,c)" />?<sbr />
                <varname>c</varname> = flow-in&nbsp; &rArr; <nonterminal
                def="#ns-plain-multi(n,c)" />?<sbr />
                <varname>c</varname> = flow-key &rArr; <nonterminal
                  def="#ns-plain-single(c)"
                      >ns-plain-single(c)</nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Plain Scalars</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
{
  <hl1>key</hl1> :
   <hl1>some</hl1><hl2>  &darr;
  &darr;
    text</hl2><hl2>&dArr;
     value</hl2>
}
...
# Legend:
#   <hl1><link linkend="ns-plain-single(c)">ns-plain-single</link></hl1>
#   <hl2><link linkend="s-ns-plain-next(n,c)">s-ns-plain-next</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "key":
    !str "some\ntext\Lvalue"
}
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="syntax-block-scalars" />Block Scalar Styles</title>

        <sect3>
          <title><anchor
            id="syntax-block-header" />Block Header</title>

          <para>
            The presentation of a block scalar content is specified by several
            indicators given in a header preceding the content itself:
          </para>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  Style Indicator
                </para>
              </term>

              <listitem>
                <para>
                  Block scalars have two possible styles, indicated by <link
                  linkend="c-literal"
                    ><quote><userinput>|</userinput></quote></link> for literal
                  or <link linkend="c-literal"
                    ><quote><userinput>&gt;</userinput></quote></link> for
                  folded.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <productionset>
            <production id="c-style-indicator(s)">
              <lhs>c-style-indicator(s)</lhs>
              <rhs>
                s = literal &rArr; <nonterminal
                  def="#c-literal"><quote>|</quote></nonterminal><sbr />
                s = folded&nbsp; &rArr; <nonterminal
                  def="#c-folded"><quote>&gt;</quote></nonterminal>
              </rhs>
            </production>
          </productionset>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  Indentation Indicator
                </para>
              </term>

              <listitem>
                <para>
                  Typically, the indentation level of a block scalar content is
                  detected from its first non-empty content line. This
                  detection fails when this line contains leading white space
                  characters (note it may safely start with a
                  <quote><userinput>#</userinput></quote> character). When
                  detection fails, YAML requires that the indentation level for
                  the content be given explicitly. This level is specified as
                  the integer number of the additional indentation spaces used
                  for the content. If the block scalar begins with lines
                  containing only spaces, and no explicit indentation is given,
                  the processor assumes such lines are empty lines. It is an
                  error for any such leading empty line to contain more spaces
                  than the indentation level that is deduced from the first
                  non-empty content line. It is always valid to specify an
                  explicit indentation level for a block scalar node, though a
                  YAML processor should only do so in cases where detection
                  fails.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <productionset>
            <production id="c-indent-indicator(m)">
              <lhs>c-indent-indicator(m)</lhs>
              <rhs>
                explicit(m) &rArr;
                  <nonterminal def="#ns-decimal-digit" /><sbr />
                detect(m)&nbsp;&nbsp; &rArr; /* empty */
              </rhs>
            </production>
          </productionset>

          <variablelist>
            <varlistentry>
              <term>
                <para>
                  Chomp Indicator
                </para>
              </term>

              <listitem>
                <para>
                  By default, all block scalars are <link
                  linkend="syntax-clip">clipped</link>. An explicit indicator
                  is required in order to <link
                  linkend="syntax-strip">strip</link> the final generic line
                  break or <link linkend="syntax-keep">keep</link> all the
                  trailing empty lines as part of the content.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <productionset>
            <production id="c-chomp-indicator(t)">
              <lhs>c-chomp-indicator(t)</lhs>
              <rhs>
                <varname>t</varname> = strip &rArr;
                <nonterminal
                  def="#c-strip"><quote>-</quote></nonterminal><sbr />
                <varname>t</varname> = clip&nbsp; &rArr;
                  /* empty */<sbr />
                <varname>t</varname> = keep&nbsp; &rArr;
                <nonterminal
                  def="#c-keep"><quote>+</quote></nonterminal><sbr />
              </rhs>
            </production>
          </productionset>

          <para>
            Each block scalar content is prefixed by a header consisting of the
            above indicators, followed by an ignored line break (with an
            optional comment). The content is is ended by a less-indented line,
            the end of the characters stream, or by a document end or start
            <link linkend="c-forbidden-line">line</link>.
          </para>

          <productionset>
            <production id="c-b-block-header(s,m,t)">
              <lhs>c-b-block-header(s,m,t)</lhs>
              <rhs>
                <nonterminal def="#c-style-indicator(s)" /><sbr />
                ( ( <nonterminal def="#c-indent-indicator(m)" /><sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                  def="#c-chomp-indicator(t)" /> )<sbr />
                | ( <nonterminal def="#c-chomp-indicator(t)" /><sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                  def="#c-indent-indicator(m)" /> ) )<sbr />
                <nonterminal def="#s-b-seperated-comment" />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Block Headers</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
- |
- >+
- |2
- |2-
- >+2
...
# Legend:
#   <hl1><link linkend="c-b-block-header(s,m,t)">c-b-block-header</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq {
  !str "",
  !str "",
  !str "",
  !str "",
  !str "",
}
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Invalid Block Headers</title>
            <simplelist type="horiz" columns="2">
              <member>
<screen>---
- <hl4>+</hl4>|
- <hl4>2</hl4>>
- <hl4>2</hl4>|+
- <hl4>+2</hl4>>
...
</screen>
              </member>
              <member>
<screen>ERROR:
  The style indicator must be
  the first header character.
</screen>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-literal" />Literal</title>

          <para>
            The literal block scalar style is the simplest scalar style. No
            processing is performed on literal characters aside from line break
            <link linkend="syntax-break">normalization</link>, stripping
            away the <link linkend="syntax-indent">indentation</link>, and
            <link linkend="syntax-chomp">chomping</link>. The indentation is
            detected from the first non-empty content line. <link
            linkend="c-indent-indicator(m)">Explicit indentation</link>
            must be specified in case this yields the wrong result. Chomping
            must also be specified unless the default <link
            linkend="syntax-keep">keep</link> processing is used. Since
            escaping is not done, the literal style is restricted to <link
            linkend="c-printable">printable characters</link> and long lines
            cannot be wrapped. In exchange for these restrictions, literal
            content offers the most readable presentation for source code or
            other text containing with significant use of indicators, quotes,
            escape sequences, and line breaks. In particular, literal content
            lines may begin with a <quote><userinput>#</userinput></quote>
            character.
          </para>

          <productionset>
            <production id="i-nb-literal-text(n)">
              <lhs>i-nb-literal-text(n)</lhs>
              <rhs>
                &nbsp;&nbsp;( <nonterminal def="#s-indentation(n)" />
                <nonterminal def="#nb-char" />+ )<sbr />
                - <nonterminal def="#c-forbidden-line" />
              </rhs>
            </production>

            <production id="l-nb-literal-line(n)">
              <lhs>l-literal-line(n)</lhs>
              <rhs>
                <nonterminal def="#l-empty-line(n,c)"
                    >l-empty-line(n,block)</nonterminal>*<sbr />
                <nonterminal def="#i-nb-literal-text(n)" />
              </rhs>
            </production>

            <production id="l-literal-text(n,t)">
              <lhs>l-literal-text(n,t)</lhs>
              <rhs>
                ( ( <nonterminal def="#l-nb-literal-line(n)" /><sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                  def="#b-normalized" /> )*<sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#l-nb-literal-line(n)" /><sbr />
                &nbsp;&nbsp;<nonterminal def="#b-chomped-break(t)" /> )?<sbr />
                <nonterminal def="#l-trail-chomped(n,t)" />?
              </rhs>
            </production>

            <production id="c-l-literal(n)">
              <lhs>c-l-literal(n)</lhs>
              <rhs>
                <nonterminal def="#c-b-block-header(s,m,t)"
                  >c-b-block-header(literal,m,t)</nonterminal><sbr />
                <nonterminal def="#l-literal-text(n,t)"
                  >l-literal-text(n+m,t)</nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Literal Scalars</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
# Clipped
- <HL><hl1>|
<hl2> </hl2>Literal&darr;
<hl2> </hl2>&darr;
<hl2> </hl2> text&darr;
&dArr;
<hl3># Indented</hl3></hl1></HL>
- <HL><hl1>|2
<hl2>  </hl2> Literal&darr;
<hl2>  </hl2>&darr;
<hl2>  </hl2>text&darr;
&dArr;
<hl3># Kept</hl3></hl1></HL>
- <HL><hl1>|+
<hl2> </hl2>Literal&darr;
<hl2> </hl2> &darr;
<hl2> </hl2> text&darr;
&dArr;
<hl3># Stripped, indented</hl3></hl1></HL>
- <HL><hl1>|2- <hl3># Could be |-2</hl3>
<hl2>  </hl2># Literal&darr;
<hl2> </hl2>&darr;
<hl2>  </hl2>text&darr;
<hl2>  </hl2>&dArr;</hl1></HL>
...
# Legend:
#   <hl1><link linkend="c-l-literal(n)">c-l-literal</link></hl1>
#   <hl2><link linkend="s-indentation(n)">s-indentation(n)</link></hl2>
#   <hl3><link linkend="c-b-throwaway-comment">c-b-throwaway-comment</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq {
  !str "Literal\n\n text\n",
  !str " Literal\n\ntext\n",
  !str "Literal\n \n text\n\L",
  !str "# Literal\n\ntext"
}
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Invalid Literal Scalars</title>
            <simplelist type="horiz" columns="2">
              <member>
<screen>--- |
# Content, not comment
More content
<hl4>... </hl4>Oops!
...
</screen>
              </member>
              <member>
<screen>ERROR:
  Unindented content lines must not
  begin with a document start --- or
  end ... indication.
</screen>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-folded" />Folded</title>

          <para>
            The folded block scalar style is similar to the <link
            linkend="syntax-literal">literal</link> style. However, unlike a
            literal content, folded content is subject to block line <link
            linkend="syntax-fold">folding</link>. This allows long lines to be
            broken anywhere a space character (<userinput>#x20</userinput>)
            appears, at the cost of requiring an empty line to represent each
            <link linkend="b-line-feed">line feed</link> character.
          </para>

          <productionset>
            <production id="i-nb-folded-text(n)">
              <lhs>i-nb-folded-text(n)</lhs>
              <rhs>
                &nbsp;&nbsp;( <nonterminal def="#s-indentation(n)" />
                <nonterminal def="#ns-char" />
                <nonterminal def="#nb-char" />* )<sbr />
                - <nonterminal def="#c-forbidden-line" />
              </rhs>
            </production>

            <production id="l-nb-folded-lines(n)">
              <lhs>l-nb-folded-lines(n)</lhs>
              <rhs>
                <nonterminal def="#l-empty-line(n,c)"
                  >l-empty-line(n,block)</nonterminal>*<sbr />
                ( <nonterminal def="#i-nb-folded-text(n)" /><sbr />
                &nbsp;&nbsp;<nonterminal def="#b-l-folded-break(n,c)"
                  >b-l-folded-break(n,block)</nonterminal> )*<sbr />
                <nonterminal def="#i-nb-folded-text(n)" />
              </rhs>
            </production>

            <production id="l-nb-start-with-folded(n)">
              <lhs>l-nb-start-with-folded(n)</lhs>
              <rhs>
                <nonterminal def="#l-nb-folded-lines(n)" /><sbr />
                ( <nonterminal def="#b-normalized" /><sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#l-nb-start-with-spaced(n)" /> )?
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Folded Scalar Folded Lines</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>--- ><sbr />
<hl1>&darr;
  Folded&darr;
  text&darr;
  &darr;
  lines</hl1>&darr;
    Indented&darr;
    lines&darr;
<hl1>  Folded&darr;
  text&darr;
&darr;
  lines</hl1>&darr;
...
# Legend:
#   <hl1><link linkend="l-nb-folded-lines(n)">l-nb-folded-lines</link></hl1>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!str "\n\
      Folded text\n\
      lines\n\
      \  Indented\n\
      \  lines\n\
      Folded text\n\
      lines\n"
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="i-nb-indented-text(n)">
              <lhs>i-nb-indented-text(n)</lhs>
              <rhs>
                <nonterminal def="#s-indentation(n)" />
                <nonterminal def="#s-char" />
                <nonterminal def="#nb-char" />*
              </rhs>
            </production>

            <production id="l-nb-indented-lines(n)">
              <lhs>l-nb-indented-lines(n)</lhs>
              <rhs>
                <nonterminal def="#l-empty-line(n,c)"
                  >l-empty-line(n,block)</nonterminal>*<sbr />
                ( <nonterminal def="#i-nb-indented-text(n)" /><sbr />
                &nbsp;&nbsp;<nonterminal def="#b-normalized" /><sbr />
                &nbsp;&nbsp;<nonterminal def="#l-empty-line(n,c)"
                  >l-empty-line(n,block)</nonterminal>* )<sbr />
                <nonterminal def="#i-nb-indented-text(n)" />
              </rhs>
            </production>

            <production id="l-nb-start-with-spaced(n)">
              <lhs>l-nb-start-with-spaced(n)</lhs>
              <rhs>
                <nonterminal def="#l-nb-indented-lines(n)" /><sbr />
                ( <nonterminal def="#b-normalized" /><sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#l-nb-start-with-folded(n)" /> )?
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Folded Scalar Indented Lines</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>--- >2<sbr />
<HL><hl1>&darr;
<hl2>  </hl2>  Indented&darr;
<hl2>  </hl2>  lines</hl1></HL>&darr;
&darr;
  Folded&darr;
  lines&darr;
<HL><hl1><hl2>  </hl2>  </hl1></HL>&darr;
  &darr;
...
# Legend:
#   <hl1><link linkend="l-nb-indented-lines(n)">l-nb-indented-lines</link></hl1>
#   <hl2><link linkend="s-indentation(n)">s-indentation</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!str "\n\
      \  Indented\n\
      \  lines\n\
      \n\
      Folded lines\n\
      \  \n"
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="l-folded-text(n,t)">
              <lhs>l-folded-text(n,t)</lhs>
              <rhs>
                ( ( <nonterminal
                    def="#l-nb-start-with-folded(n)" /><sbr />
                &nbsp;&nbsp;| <nonterminal
                    def="#l-nb-start-with-spaced(n)" /> )<sbr />
                &nbsp;&nbsp;<nonterminal
                    def="#b-chomped-break(t)" /> )?<sbr />
                <nonterminal def="#l-trail-chomped(n,t)" />
              </rhs>
            </production>

            <production id="c-l-folded(n)">
              <lhs>c-l-folded(n)</lhs>
              <rhs>
                <nonterminal def="#c-b-block-header(s,m,t)"
                  >c-b-block-header(folded,m,t)</nonterminal><sbr />
                <nonterminal def="#l-folded-text(n,t)"
                  >l-folded-text(n+m,t)</nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Folded Scalars</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
# Clipped
- <HL><hl1>>
<hl2> </hl2>Folded&darr;
<hl2> </hl2>&darr;
<hl2> </hl2> text&darr;
&dArr;
<hl3># Indented</hl3></hl1></HL>
- <HL><hl1>>2
<hl2>  </hl2> Folded&darr;
<hl2>  </hl2>&darr;
<hl2>  </hl2>text&darr;
&dArr;
<hl3># Kept</hl3></hl1></HL>
- <HL><hl1>>+
<hl2> </hl2>Folded&darr;
<hl2> </hl2> &darr;
<hl2> </hl2> text&darr;
&dArr;
<hl3># Stripped, indented</hl3></hl1></HL>
- <HL><hl1>>2- <hl3># Could be >-2</hl3>
<hl2>  </hl2># Folded&darr;
<hl2> </hl2>&darr;
<hl2>  </hl2>text&darr;
<hl2>  </hl2>&dArr;</hl1></HL>
...
# Legend:
#   <hl1><link linkend="c-l-folded(n)">c-l-folded</link></hl1>
#   <hl2><link linkend="s-indentation(n)">s-indentation(n)</link></hl2>
#   <hl3><link linkend="c-b-throwaway-comment">c-b-throwaway-comment</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq {
  !str "Folded\n\n text\n",
  !str " Folded\n\ntext\n",
  !str "Folded\n \n text\n\L",
  !str "# Folded\ntext"
}
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-collect-nodes" />Collection Content</title>

      <para>
        YAML provides a single flow style and a single block style for each of
        the two collection kinds (sequence and mapping). In addition, YAML
        provides several compact syntax forms for improved readability of
        common special cases.
      </para>

      <sect2>
        <title><anchor id="syntax-sequence" />Sequence Styles</title>

        <para>
          Sequence content is an ordered collection of sub-nodes. Comments may
          be interleaved between the sub-nodes. Sequences may be presented in a
          flow style or a block style. YAML provides compact notations for
          nesting a collection in a block sequence and for nesting a
          single-pair mapping in a flow sequence.
        </para>

        <sect3>
          <title><anchor id="syntax-flow-sequence" />Flow Sequences</title>

          <para>
            When presented in a flow style, sequence content is denoted by
            <link linkend="c-sequence-start"
            ><quote><userinput>[</userinput></quote></link> and <link
            linkend="c-sequence-end"
            ><quote><userinput>]</userinput></quote></link> characters.
            Sequence entries are separated by a <link linkend="c-collect-entry"
            ><quote><userinput>,</userinput></quote></link> character. A final
            <quote><userinput>,</userinput></quote> character may follow the
            last sequence entry. This does not cause ambiguity since sequence
            entries may not be completely empty. YAML provides a compact form
            for the case where a flow sequence entry is a mapping with a single
            (key:&nbsp;value) pair, and neither the mapping node nor its single
            key node have any properties specified.
          </para>

          <productionset>
            <production id="in-flow(c)">
              <lhs>in-flow(c)</lhs>
              <rhs>
                <varname>c</varname> = flow-out &rArr; flow-in<sbr />
                <varname>c</varname> = flow-in&nbsp; &rArr; flow-in<sbr />
                <varname>c</varname> = flow-key &rArr; flow-key
              </rhs>
            </production>

            <production id="ns-flow-seq-entry(n,c)">
              <lhs>ns-flow-seq-entry(n,c)</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal def="#ns-flow-node(n,c)"
                  >ns-flow-node(n,<nonterminal
                    def="#in-flow(c)" />)</nonterminal><sbr />
                | <nonterminal def="#ns-flow-single-pair(n,c)"
                      >ns-flow-single-pair(n,<nonterminal
                        def="#in-flow(c)" />)</nonterminal>
              </rhs>
            </production>

            <production id="c-flow-sequence(n,c)">
              <lhs>c-flow-sequence(n,c)</lhs>
              <rhs>
                <nonterminal def="#c-sequence-start"
                  ><quote>[</quote></nonterminal><sbr />
                <nonterminal def="#s-seperate-spaces(n,c)" />?<sbr />
                ( <nonterminal def="#ns-flow-seq-entry(n,c)" /><sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#s-seperate-spaces(n,c)" />?<sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#c-collect-entry"><quote>,</quote></nonterminal>
                <nonterminal def="#s-seperate-spaces(n,c)" /> )*<sbr />
                ( <nonterminal
                  def="#ns-flow-seq-entry(n,c)" /><sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#s-seperate-spaces(n,c)" />? )?<sbr />
                <nonterminal
                  def="#c-sequence-end"><quote>]</quote></nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Flow Sequences</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
[ <hl1>one</hl1>, <hl1>!int "2"</hl1>, # scalars
  <hl2>three : 3</hl2>,     # pairs
  <hl1>[ four, ]</hl1>      # nested
]
...
# Legend:
#   <hl1><link linkend="ns-flow-seq-entry(n,c)">ns-flow-seq-entry</link></hl1>
#   <hl2><link linkend="ns-flow-single-pair(n,c)">ns-flow-single-pair(n,c)</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq {
  !str "one",
  !int "2",
  !map {
    !str "three":
      !int "3"
  },
  !seq [
    !str "four"
  ]
}
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-block-sequence" />Block Sequences</title>

          <para>
            When presented in the block style, each sequence entry is prefixed
            by a <link linkend="c-sequence-entry"
            ><quote><userinput>-</userinput></quote></link> character followed
            by white space. The <quote><userinput>-</userinput></quote>
            indicator is considered to be part of the entry's indentation, and
            hence it need not be more indented than the parent node, unless the
            parent node is also a block sequence. YAML also provides a compact
            in-line syntax to be used when the sequence entry is a collection
            without any node properties specified. In this case both the
            <quote><userinput>-</userinput></quote> indicator and the spaces
            following it are considered to be the indentation of the first
            entry of the contained collection.
          </para>

          <productionset>
            <production id="seq-spaces(n,c)">
              <lhs>seq-spaces(n,c)</lhs>
              <rhs>
                <varname>c</varname> = block-out &rArr; n-1<sbr />
                <varname>c</varname> = block-in&nbsp; &rArr; n
              </rhs>
            </production>

            <production id="s-l-block-seq-empty">
              <lhs>s-l-block-seq-empty</lhs>
              <rhs>
                /* implicit empty plain content */<sbr />
                <nonterminal def="#s-b-seperated-comment" /><sbr />
                <nonterminal def="#l-comment" />*
              </rhs>
            </production>

            <production id="s-l-block-seq-node(n,c)">
              <lhs>s-l-block-seq-node(n,c)</lhs>
              <rhs>
                <nonterminal def="#s-seperate-spaces(n,c)" /><sbr />
                <nonterminal def="#ns-l-block-node(n,c)" />
              </rhs>
            </production>

            <production id="s-l-block-same-line(n)">
              <lhs>s-l-block-same-line(n)</lhs>
              <rhs>
                <nonterminal def="#s-indentation(n)"
                      >s-indentation(m&gt;0)</nonterminal><sbr />
                ( <nonterminal def="#ns-l-in-line-sequence(n)"
                    >ns-l-in-line-sequence(n+1+m)</nonterminal><sbr />
                | <nonterminal def="#ns-l-in-line-mapping(n)"
                    >ns-l-in-line-mapping(n+1+m)</nonterminal> )
              </rhs>
            </production>

            <production id="s-l-block-in-line(n,c)">
              <lhs>s-l-block-in-line(n,c)</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal
                  def="#s-l-block-seq-empty" /><sbr />
                | <nonterminal
                  def="#s-l-block-seq-node(n,c)" /><sbr />
                | <nonterminal
                  def="#s-l-block-same-line(n)" /><sbr />
              </rhs>
            </production>

            <production id="l-block-sequence(n,c)">
              <lhs>l-block-sequence(n,c)</lhs>
              <rhs>
                ( <nonterminal def="#s-indentation(n)"
                  >s-indentation(seq-spaces(n,c))</nonterminal>
                <nonterminal
                  def="#c-sequence-entry"><quote>-</quote></nonterminal><sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#s-l-block-in-line(n,c)"
                    >s-l-block-in-line(seq-spaces(n,c),c)</nonterminal>
                  )+<sbr />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Block Sequences</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
# Note "-" is not indented.
block sequence:
# Scalars
-<hl1> # Implicit plain</hl1>
-<hl2> one</hl2>
-<hl2>&darr;
  !int
  "2"</hl2>
-<hl2> |
  Block (literal)</hl2>
-<hl2> # Nested, indented "-"
 - three
 -  four
# In-line collection:</hl2>
-<hl3> five: 5</hl3>
...
# Legend:
#   <hl1><link linkend="s-l-block-seq-empty">s-l-block-seq-empty</link></hl1>
#   <hl2><link linkend="s-l-block-seq-node(n,c)">s-l-block-seq-node</link></hl2>
#   <hl3><link linkend="s-l-block-same-line(n)">s-l-block-same-line</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "block sequence":
    !seq [
      !str "",
      !str "one",
      !int "2",
      !str "Block (literal)\n",
      !seq [
        !str "three",
        !str "four",
      ],
      !map {
        !str "five":
          !int "5"
      },
    ]
}
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="ns-l-in-line-sequence(n)">
              <lhs>ns-l-in-line-sequence(n)</lhs>
              <rhs>
                <nonterminal
                  def="#c-sequence-entry"><quote>-</quote></nonterminal>
                <nonterminal def="#s-l-block-in-line(n,c)"
                  >s-l-block-in-line(n,block-out)</nonterminal><sbr />
                <nonterminal def="#l-block-sequence(n,c)"
                  >l-block-sequence(n,block-out)</nonterminal>?
              </rhs>
            </production>
          </productionset>

          <example>
            <title>In-Line Nested Block Sequences</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
# In-line nested sequence.
-<hl1> - one</hl1>
<hl2>  - two
  - three</hl2>
...
# Legend:
#   <hl1><link linkend="s-l-block-in-line(n,c)">s-l-block-in-line</link></hl1>
#   <hl2><link linkend="l-block-sequence(n,c)">l-block-sequence</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !seq [
    !str "one",
    !str "two",
    !str "three"
  ]
]
...
</programlisting>
              </member>
            </simplelist>
          </example>

        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="syntax-mapping" />Mapping Styles</title>

        <para>
          The value of a mapping node is an unordered collection of
          (key:&nbsp;value) pairs. Of necessity, these pairs are presented in
          some order in the characters stream. This order must not be used in
          construction of the native data structures. It is an error for two
          <link linkend="model-equality">equal</link> key entries to appear in
          the same mapping value. In such a case the processor may continue,
          ignoring the second presented key and issuing an appropriate warning.
          This strategy preserves a consistent information model for streaming
          and random access applications. Key nodes are denoted by the <link
          linkend="c-mapping-key"
          ><quote><userinput>?</userinput></quote></link> character, and value
          nodes are denoted by the <link linkend="c-mapping-value"
          ><quote><userinput>:</userinput></quote></link> character. For
          compact presentation, YAML allows omitting the
          <quote><userinput>:</userinput></quote> indicator for empty plain
          value nodes that have no properties specified, and omitting the
          <quote><userinput>?</userinput></quote> indicator for simple keys.
          This causes potential ambiguity between plain scalars and mapping
          entries. To resolve this ambiguity without unbound lookahead, simple
          keys are always written in a flow presentation style, must not be
          completely empty, are restricted to a single line, and must not span
          more than a total of 1K (1024) presentation characters. Note that
          this restricts the total length of (flow) collections used as simple
          keys. These restrictions are indicated by the use of the
          <userinput>flow-key</userinput> production context.
        </para>

        <sect3>
          <title><anchor id="syntax-flow-mapping" />Flow Mappings</title>

          <para>
            When presented in a flow style, a mapping value is denoted by <link
            linkend="c-mapping-start"
            ><quote><userinput>{</userinput></quote></link> and <link
            linkend="c-mapping-end"
            ><quote><userinput>}</userinput></quote></link> characters. Mapping
            entries are separated by a <link linkend="c-collect-entry"
            ><quote><userinput>,</userinput></quote></link> character. A final
            <quote><userinput>,</userinput></quote> character may follow the
            last entry. This does not cause ambiguity since mapping entries may
            not be completely empty. Finally, YAML allows omitting the
            surrounding <quote><userinput>{</userinput></quote> and
            <quote><userinput>}</userinput></quote> for a mapping that has no
            properties specifies, contains a single key:&nbsp;value pair, and
            is nested inside a flow sequence.
          </para>

          <productionset>
            <production id="ns-flow-explicit-key(n,c)">
              <lhs>ns-flow-explicit-key(n,c)</lhs>
              <rhs>
                <nonterminal
                  def="#c-mapping-key"><quote>?</quote></nonterminal>
                <nonterminal def="#s-seperate-spaces(n,c)" /><sbr />
                <nonterminal def="#ns-flow-node(n,c)"
                  >ns-flow-node(n,<nonterminal
                    def="#in-flow(c)" />)</nonterminal><sbr />
              </rhs>
            </production>

            <production id="ns-flow-simple-key(n,c)">
              <lhs>ns-flow-simple-key(n,c)</lhs>
              <rhs>
                <nonterminal def="#ns-flow-node(n,c)"
                  >ns-flow-node(n,flow-key)</nonterminal><sbr />
              </rhs>
            </production>

            <production id="s-ns-flow-explicit-value(n,c)">
              <lhs>s-ns-flow-explicit-value(n,c)</lhs>
              <rhs>
                <nonterminal def="#s-seperate-spaces(n,c)" />?<sbr />
                <nonterminal
                  def="#c-mapping-value"><quote>:</quote></nonterminal>
                <nonterminal def="#s-seperate-spaces(n,c)" /><sbr />
                <nonterminal def="#ns-flow-node(n,c)"
                  >ns-flow-node(n,<nonterminal
                    def="#in-flow(c)" />)</nonterminal>?
              </rhs>
            </production>

            <production id="ns-flow-explicit-entry(n,c)">
              <lhs>ns-flow-explicit-entry(n,c)</lhs>
              <rhs>
                <nonterminal def="#ns-flow-explicit-key(n,c)" /><sbr />
                <nonterminal def="#s-ns-flow-explicit-value(n,c)" />?
              </rhs>
            </production>

            <production id="ns-flow-simple-entry(n,c)">
              <lhs>ns-flow-simple-entry(n,c)</lhs>
              <rhs>
                <nonterminal def="#ns-flow-simple-key(n,c)" /><sbr />
                <nonterminal def="#s-ns-flow-explicit-value(n,c)" />
              </rhs>
            </production>

            <production id="ns-flow-implicit-entry(n)">
              <lhs>ns-flow-implicit-entry(n)</lhs>
              <rhs>
                <nonterminal def="#ns-flow-simple-key(n,c)" /><sbr />
                /* implicit empty plain value */
              </rhs>
            </production>

            <production id="ns-flow-map-entry(n,c)">
              <lhs>ns-flow-map-entry(n,c)</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal
                  def="#ns-flow-explicit-entry(n,c)" /><sbr />
                | <nonterminal def="#ns-flow-simple-entry(n,c)" /><sbr />
                | <nonterminal def="#ns-flow-implicit-entry(n)" />
              </rhs>
            </production>

            <production id="c-flow-mapping(n,c)">
              <lhs>c-flow-mapping(n,c)</lhs>
              <rhs>
                <nonterminal def="#c-mapping-start"
                  ><quote>{</quote></nonterminal><sbr />
                <nonterminal def="#s-seperate-spaces(n,c)" />?<sbr />
                ( <nonterminal def="#ns-flow-map-entry(n,c)" /><sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#s-seperate-spaces(n,c)" />?<sbr />
                &nbsp;&nbsp;<nonterminal def="#c-collect-entry"
                  ><quote>,</quote></nonterminal>
                <nonterminal def="#s-seperate-spaces(n,c)" /> )*<sbr />
                ( <nonterminal
                  def="#ns-flow-map-entry(n,c)" /><sbr />
                &nbsp;&nbsp;<nonterminal
                  def="#s-seperate-spaces(n,c)" />? )?<sbr />
                <nonterminal
                  def="#c-mapping-end"><quote>}</quote></nonterminal>
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Flow Mappings</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
{ <hl1>? explicit
    key</hl1><hl3> : explicit
 value</hl3>, <hl1>? another
 explicit key</hl1> # implicit value
 , <hl2>simple key</hl2><hl3> :
  # explicit empty value</hl3>
 , <hl2>final simple key</hl2> # implicit value
}
...
# Legend:
#   <hl1><link linkend="ns-flow-explicit-key(n,c)">ns-flow-explicit-key</link></hl1>
#   <hl2><link linkend="ns-flow-simple-key(n,c)">ns-flow-simple-key</link></hl2>
#   <hl3><link linkend="s-ns-flow-explicit-value(n,c)">s-ns-flow-explicit-value</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "explicit key":
    !str "explicit value",
  !str "another explicit key":
    !str "",
  !str "simple key":
    !str "explicit value",
  !str "final simple key":
    !str ""
}
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="ns-flow-single-pair(n,c)">
              <lhs>ns-flow-single-pair(n,c)</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal
                  def="#ns-flow-explicit-entry(n,c)" /><sbr />
                | <nonterminal def="#ns-flow-simple-entry(n,c)" />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Single Pair Mappings in Flow Sequences</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
[ <hl2>simple key</hl2><hl3>: # explicit empty value</hl3>
, <hl2>simple key</hl2><hl3> : explicit value</hl3>,
  <hl1>? explicit
  key</hl1><hl3> : explicit value</hl3>,
  <hl1>? explicit
  key</hl1> # implicit empty value
]
...
# Legend:
#   <hl1><link linkend="ns-flow-explicit-key(n,c)">ns-flow-explicit-key</link></hl1>
#   <hl2><link linkend="ns-flow-simple-key(n,c)">ns-flow-simple-key</link></hl2>
#   <hl3><link linkend="s-ns-flow-explicit-value(n,c)">s-ns-flow-explicit-value</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq [
  !map {
    !str "simple key":
      !str "",
  },
  !map {
    !str "simple key":
      !str "explicit value",
  },
  },
  !map {
    !str "explicit key":
      !str "explicit value",
  },
  !map {
    !str "explicit key":
      !str "",
]
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-block-mapping" />Block Mappings</title>

          <para>
            When presented in a block style, each mapping entry starts on a
            seperate line. In contrast with block sequences, there is no
            mandatory indicator character prefixing each entry, as the <link
            linkend="c-mapping-key"
            ><quote><userinput>?</userinput></quote></link> character may be
            ommitted for simple keys.
          </para>

          <productionset>
            <production id="ns-l-block-explicit-key(n)">
              <lhs>ns-l-block-explicit-key(n)</lhs>
              <rhs>
                <nonterminal
                  def="#c-mapping-key"><quote>?</quote></nonterminal>
                <nonterminal def="#s-l-block-in-line(n,c)"
                  >s-l-block-in-line(n,block-out)</nonterminal><sbr />
              </rhs>
            </production>

            <production id="l-block-explicit-value(n)">
              <lhs>l-block-explicit-value(n)</lhs>
              <rhs>
                <nonterminal def="#s-indentation(n)" /><sbr />
                <nonterminal def="#c-mapping-value"
                  ><quote>:</quote></nonterminal>
                <nonterminal def="#s-l-block-in-line(n,c)"
                  >s-l-block-in-line(n,block-out)</nonterminal> 
              </rhs>
            </production>

            <production id="ns-l-block-explicit-entry(n)">
              <lhs>ns-l-block-explicit-entry(n)</lhs>
              <rhs>
                <nonterminal def="#ns-l-block-explicit-key(n)" /><sbr />
                <nonterminal def="#l-block-explicit-value(n)" />?
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Explicit Key Block Mapping Entries</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
mapping:
  <hl1>? >-
   explicit key&darr;</hl1>
<hl2>  : explicit value&darr;</hl2>
  <hl1>? another key
  # implicit empty value</hl1>
...
# Legend:
#   <hl1><link linkend="ns-l-block-explicit-key(n)">ns-l-block-explicit-key</link></hl1>
#   <hl2><link linkend="l-block-explicit-value(n)">l-block-explicit-value</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "mapping":
    !map {
      !str "explicit key":
        !str "explicit value",
      !str "another key":
        !str ""
    }
}
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="ns-block-simple-key(n)">
              <lhs>ns-block-simple-key(n)</lhs>
              <rhs>
                <nonterminal def="#ns-flow-node(n,c)"
                  >ns-flow-node(n,flow-key)</nonterminal><sbr />
                <nonterminal def="#s-seperate-spaces(n,c)"
                  >s-seperate-spaces(n,block-out)</nonterminal>?
                <nonterminal def="#c-mapping-value"
                  ><quote>:</quote></nonterminal>
              </rhs>
            </production>

            <production id="s-l-block-simple-value(n)">
              <lhs>s-l-block-simple-value(n)</lhs>
              <rhs>
                <nonterminal def="#s-seperate-spaces(n,c)"
                  >s-seperate-spaces(n,block-out)</nonterminal>?<sbr />
                <nonterminal def="#ns-l-block-node(n,c)"
                  >ns-l-block-node(n,block-out)</nonterminal>
              </rhs>
            </production>

            <production id="s-l-block-implicit-value(n)">
              <lhs>s-l-block-implicit-value(n)</lhs>
              <rhs>
                /* implicit empty plain content */<sbr />
                <nonterminal def="#s-b-seperated-comment" /><sbr />
                <nonterminal def="#l-comment" />*
              </rhs>
            </production>

            <production id="ns-l-block-simple-entry(n)">
              <lhs>ns-l-block-simple-entry(n)</lhs>
              <rhs>
                <nonterminal def="#ns-block-simple-key(n)" /><sbr />
                ( <nonterminal def="#s-l-block-simple-value(n)" /><sbr />
                | <nonterminal def="#s-l-block-implicit-value(n)" /> )
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Simple Key Block Mapping Entries</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
<hl1>simple key</hl1><hl2> : >-
  explicit value&darr;</hl2>
<hl1>another key</hl1><hl3>: # implicit value&darr;</hl3>
...
# Legend:
#   <hl1><link linkend="ns-block-simple-key(n)">ns-block-simple-key</link></hl1>
#   <hl2><link linkend="s-l-block-simple-value(n)">s-l-block-simple-value</link></hl2>
#   <hl3><link linkend="s-l-block-implicit-value(n)">s-l-block-implicit-value</link></hl3>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!map {
  !str "simple key":
    !str "explicit value",
  !str "another key":
    !str ""
}
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <productionset>
            <production id="ns-l-block-map-entry(n)">
              <lhs>ns-l-block-map-entry(n)</lhs>
              <rhs>
                &nbsp;&nbsp;<nonterminal
                  def="#ns-l-block-explicit-entry(n)" /><sbr />
                | <nonterminal def="#ns-l-block-simple-entry(n)" />
              </rhs>
            </production>

            <production id="l-block-mapping(n)">
              <lhs>l-block-mapping(n)</lhs>
              <rhs>
                ( <nonterminal def="#s-indentation(n)" /><sbr />
                &nbsp;&nbsp;<nonterminal def="#ns-l-block-map-entry(n)" /> )+
              </rhs>
            </production>

            <production id="ns-l-in-line-mapping(n)">
              <lhs>ns-l-in-line-mapping(n)</lhs>
              <rhs>
                <nonterminal def="#ns-l-block-map-entry(n)" /><sbr />
                <nonterminal def="#l-block-mapping(n)" />?
              </rhs>
            </production>
          </productionset>

          <example>
            <title>In-Line Block Mappings</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>---<sbr />
- <hl1>one: 1</hl1>
- mapping:
  ? <hl1>two: 2</hl1>
<hl2>    three: 3
    four: 4</hl2>
  : <hl1>five: 5</hl1>
<hl2>    six: 6
    seven: 7</hl2>
...
# Legend:
#   <hl1><link linkend="ns-l-block-map-entry(n)">ns-l-block-map-entry</link></hl1>
#   <hl2><link linkend="l-block-mapping(n)">l-block-mapping</link></hl2>
</programlisting>
              </member>
              <member>
<programlisting>---<sbr />
!seq {
  !map {
    !str "one":
      !int "1",
  },
  !map {
    !str "mapping":
      !map {
        ? !map {
          !str "two":
            !int "2",
          !str "three":
            !int 3,
          !str "four":
            !int 4,
        }
        : !map {
            !str "five":
              !int "5",
            !str "six":
              !int "6",
            !str "seven":
              !int "7"
          }
      }
  }
}
...
</programlisting>
              </member>
            </simplelist>
          </example>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-stream" />YAML Stream</title>

      <para>
        A YAML stream may contain several independent YAML documents. A
        document header line is used to denote the beginning of a new document.
        The header line is optional for the first document. A document trailer
        line may be used to denote the end of a document without starting the
        next one. Each document is a single node, preceded by optional
        processor directives. All documents in a single YAML stream must use
        the same character encoding.
      </para>

      <sect2>
        <title><anchor id="syntax-directive" />Directive</title>

        <para>
          <link linkend="model-directive">Directives</link> are instructions
          to the YAML processor. Like <link
          linkend="syntax-comment">throwaway comments</link>,
          directives are not reflected in the document's representation
          graph. Directives apply to a single document. It is an error for
          the same directive to be specified more than once for the same
          document.
        </para>

        <productionset>
          <production id="c-ns-directive">
            <lhs>c-ns-directive</lhs>
            <rhs>
              <nonterminal def="#c-directive"><quote>%</quote></nonterminal>
              <nonterminal def="#ns-directive-name" /><sbr />
              <nonterminal
                def="#c-mapping-value"><quote>:</quote></nonterminal>
              <nonterminal def="#ns-directive-value" />
            </rhs>
          </production>

          <production id="ns-directive-name">
            <lhs>ns-directive-name</lhs>
            <rhs>
              ( <nonterminal def="#ns-char" />
              - <nonterminal
                def="#c-mapping-value"><quote>:</quote></nonterminal> )+
            </rhs>
          </production>

          <production id="ns-directive-value">
            <lhs>ns-directive-value</lhs>
            <rhs>
              <nonterminal def="#ns-char" />+
            </rhs>
          </production>
        </productionset>

        <example>
          <title>In-Line Block Mappings</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>--- <HL><hl1>%<hl2>YAML</hl2>:<hl3>1.0</hl3></hl1></HL> !map {}<sbr />
...
# Legend:
#   <hl1><link linkend="c-ns-directive">c-ns-directive</link></hl1>
#   <hl2><link linkend="ns-directive-name">ns-directive-name</link></hl2>
#   <hl3><link linkend="ns-directive-value">ns-directive-value</link></hl3>
</programlisting>
            </member>
            <member>
<programlisting>--- %YAML:1.0<sbr />
!map {
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-boundaries" />Document Boundaries</title>

        <para>
          Each document may be prefixed by an optional byte order mark to
          indicate the character <link linkend="syntax-encode">encoding</link>,
          optional comments, and a header line. All documents in a stream must
          use the same character encoding. If no byte order mark is given for
          the first document, it is assumed to be in UTF-8 encoding. If no byte
          order mark is given for a subsequent document, it is assumed to be in
          the same encoding as the first document. The header line is denoted
          by <link linkend="c-document-start"
          ><quote><userinput>---</userinput></quote></link> followed by
          seperation spaces. YAML allows omitting the the header line of the
          first document. In this case, the processor must behave as if a
          header line containing
          <quote><userinput>---&darr;</userinput></quote> was specified.
        </para>

        <productionset>
          <production id="l-document-prefix">
            <lhs>l-document-prefix</lhs>
            <rhs>
              <nonterminal def="#c-byte-order-mark" />?<sbr />
              <nonterminal def="#l-comment" />*
            </rhs>
          </production>

          <production id="c-document-start">
            <lhs>c-document-start</lhs>
            <rhs>
              <quote>-</quote> <quote>-</quote> <quote>-</quote>
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Document Prefix</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting><hl1># Prefix before 1st document&darr;</hl1><sbr />
<hl2>---</hl2> First Document
<hl3>&hArr;# Prefix before 2nd document&darr;</hl3>
Second Document
# Legend:
#   <hl1><link linkend="l-document-prefix">l-document-prefix</link></hl1>
#   <hl2><link linkend="c-document-start">c-document-start</link></hl2>
#   <hl3><link linkend="c-byte-order-mark">c-byte-order-mark</link></hl3>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!str "First Document"
...
---
!str "Second Document"
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          When YAML is used as the format of a communication stream, it is
          useful to be able to indicate the end of a document without closing
          the data stream, independent of starting the next document. Lacking
          such a marker, the YAML processor reading the stream would be forced
          to wait for the header of the next document (that may be long time in
          coming) in order to detect the end of the previous document. To
          support this scenario, a YAML document may be terminated by an
          optional explicit end line denoted by <link linkend="c-document-end"
          ><quote><userinput>...</userinput></quote></link>, followed by
          optional comments.
        </para>

        <productionset>
          <production id="c-document-end">
            <lhs>c-document-end</lhs>
            <rhs>
              <quote>.</quote> <quote>.</quote> <quote>.</quote>
            </rhs>
          </production>

          <production id="l-document-suffix">
            <lhs>l-document-suffix</lhs>
            <rhs>
              <nonterminal def="#c-document-end" /><sbr />
              <nonterminal def="#s-b-seperated-comment" /><sbr />
              <nonterminal def="#l-comment" />*
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Document Suffix</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>First Document<sbr />
<HL><hl1><hl2>...</hl2> # Suffix following
# the first document.</hl1></HL>
--- Second Document
<HL><hl1><hl2>...</hl2> # Suffix following
# the second document</hl1></HL>
# Legend:
#   <hl1><link linkend="l-document-suffix">l-document-suffix</link></hl1>
#   <hl2><link linkend="c-document-end">c-document-end</link></hl2>
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!str "First Document"
...
---
!str "Second Document"
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <para>
          Since <quote><userinput>---</userinput></quote> and
          <quote><userinput>...</userinput></quote> indicate document
          boundaries, non-indented content lines are forbidden from starting
          with these character strings, unless they are followed by a non-space
          character.
        </para>

        <productionset>
          <production id="c-forbidden-line">
            <lhs>c-forbidden-line</lhs>
            <rhs>
                ( <nonterminal def="#c-document-start" /><sbr />
                | <nonterminal def="#c-document-end" /> )<sbr />
                ( <nonterminal def="#s-char" />
                | <nonterminal def="#b-any" />
                | &lt;EOF&gt; )
              </rhs>
            </production>
          </productionset>
        </sect2>

        <sect2>
          <title><anchor id="syntax-document" />Documents Stream</title>

          <para>
            A sequence of bytes is a YAML stream if, taken as a whole, it
            complies with the <link linkend="l-yaml-stream"
            ><userinput>l-yaml-stream</userinput></link> production. The stream
            consists of a sequence of disjoint documents. The first document may
            omit the header line. Note that the stream may contain no documents,
            even if it contains a non-empty document prefix. A completely empty
            stream is a valid YAML stream containing no documents.
          </para>

          <productionset>
            <production id="l-implicit-document">
              <lhs>l-implicit-document</lhs>
              <rhs>
                <nonterminal def="#l-document-prefix" />?<sbr />
                /* implicit "---&darr;" header line */<sbr />
                <nonterminal def="#s-discarded-spaces" />?<sbr />
                ( <nonterminal def="#c-ns-directive" /><sbr />
                &nbsp;&nbsp;<nonterminal def="#s-seperate-spaces(n,c)"
                  >s-seperate-spaces(0,block-out)</nonterminal> )*<sbr />
                <nonterminal def="#ns-l-block-node(n,c)"
                  >ns-l-block-node(0,block-out)</nonterminal><sbr />
                <nonterminal def="#l-document-suffix" />?<sbr />
              </rhs>
            </production>
          </productionset>

          <example>
            <title>Shortest Empty Scalar Implicit Document</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>>&darr;<sbr />
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!str ""
...
</programlisting>
              </member>
            </simplelist>
          </example>

          <example>
            <title>Short Empty Scalar Implicit Document</title>
            <simplelist type="horiz" columns="2">
              <member>
<programlisting>""&darr;<sbr />
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!str ""
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Longer Empty Scalar Implicit Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>!str&darr;<sbr />
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!str ""
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Implicit Flow Scalar Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting># Implicit documents may be prefixed<sbr />
  %YAML:1.0 # and may have directives.
    Text # The node itself must not
         # be completely empty.
... # The document suffix
    # is also optional.
</programlisting>
            </member>
            <member>
<programlisting>--- %YAML:1.0<sbr />
!str "Text"
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Implicit Block Scalar Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>><sbr />
    This folded text is
    indented by 4 spaces
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!str "This folded text is
    indented by 4 spaces"
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Implicit Flow Collection Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>{ key: value }<sbr />
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "key":
    !str "value"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Implicit Block Collection Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>!seq<sbr />
- entry
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!seq [
  !str "entry"
]
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="l-explicit-document">
            <lhs>l-explicit-document</lhs>
            <rhs>
              <nonterminal def="#l-document-prefix" />?<sbr />
              <nonterminal def="#c-document-start" /><sbr />
              ( <nonterminal def="#s-seperate-spaces(n,c)"
                >s-seperate-spaces(0,block-out)</nonterminal><sbr />
              &nbsp;&nbsp;<nonterminal def="#c-ns-directive" /> )*<sbr />
              ( ( <nonterminal def="#s-seperate-spaces(n,c)"
                >s-seperate-spaces(0,block-out)</nonterminal><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-l-block-node(n,c)"
                >ns-l-block-node(0,block-out)</nonterminal> )<sbr />
              | <nonterminal def="#s-l-empty-node" /> )<sbr />
              <nonterminal def="#l-document-suffix" />?<sbr />
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Shortest Explicit Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>---&darr;<sbr />
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!str ""
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Explicit Flow Scalar Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting># The header may be prefixed<sbr />
# with comments
---
  Text
... # The suffix is
    # also optional.
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!str "Text"
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Explicit Block Scalar Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>--- %YAML:1.0 # Directives are optional.<sbr />
  >
Top level text need
not be indented, and
can't contain a line
starting with --- or
with ...
... # Such a line will
    # end the document.
</programlisting>
            </member>
            <member>
<programlisting>--- %YAML:1.0<sbr />
!str
"Top level text need
not be indented, and
can't contain a line
starting with --- or
with ...\n"
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Explicit Flow Collection Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>--- [ entry ]<sbr />
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!seq [
  !str "entry"
]
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Explicit Block Collection Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting>--- !map<sbr />
key: value
...
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "key":
    !str "value"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <productionset>
          <production id="l-yaml-stream">
            <lhs>l-yaml-stream</lhs>
            <rhs>
              ( <nonterminal def="#l-document-prefix" /><sbr />
              | ( <nonterminal def="#l-implicit-document" />?<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal
                def="#l-explicit-document" />* ) )<sbr />
              &lt;EOF&gt;
            </rhs>
          </production>
        </productionset>

        <example>
          <title>Stream Without Document</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting># This stream contains no document.<sbr />
&darr;
# All it contains is a prefix.
</programlisting>
            </member>
            <member>
<programlisting>&darr;<sbr />
# No document here.
&darr;
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Stream With Multiple Documents</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting># HTTP log file:<sbr />
{ at: 2001-08-12 09:25:00.00 Z,
  type: GET, HTTP: "1.0",
  url: /index.html }
---
at: 2001-08-12 09:25:10.00 Z
type: GET
HTTP: '1.0'
url: '/toc.html'
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "at":
    !timestamp
      "2001-08-12 09:25:00.00 Z"
  !str "type":
    !str "GET",
  !str "HTTP":
    !str "1.0",
  !str "url":
    !str "/index.html"
}
...
---
!map {
  !str "at":
    !timestamp
      "2001-08-12 09:25:10.00 Z"
  !str "type":
    !str "GET",
  !str "HTTP":
    !str "1.0",
  !str "url":
    !str "/toc.html"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>

        <example>
          <title>Communication Channel in YAML</title>
          <simplelist type="horiz" columns="2">
            <member>
<programlisting># A communication channel<sbr />
# based on a YAML stream:
---
sent at: 2002-06-06 11:46:25.10 Z
payload: Whatever
# Receiver can process this as
# soon as the following is sent:
...
# Even if the next message
# is sent long after:
---
sent at: 2002-06-06 12:05:53.47 Z
payload: Whatever
...
</programlisting>
            </member>
            <member>
<programlisting>---<sbr />
!map {
  !str "sent at":
    !timestamp
      "2002-06-06 11:46:25.10 Z",
  !str "payload":
    !str "Whatever"
}
...
---
!map {
  !str "sent at":
    !timestamp
      "2002-06-06 12:05:53.47 Z"
  !str "payload":
    !str "Whatever"
}
...
</programlisting>
            </member>
          </simplelist>
        </example>
      </sect2>
    </sect1>
  </chapter>

  <appendix>
    <title><anchor id="tag-repository" />Tag Repository</title>

    <para>
      Following is a description of the three mandatory core tags. YAML
      requires support for the <link linkend="type-seq">seq</link>, <link
      linkend="type-map">map</link> and <link linkend="type-str">str</link>
      tags. YAML also provides a set of universal tags, that are not
      mandatory, in the YAML tag repository available at <ulink
      url="http://yaml.org/spec/type.html" />. These tags represent native data
      types in most programming languages, or are useful in a wide range of
      applications. Therefore, applications are strongly encouraged to make
      use of them whenever they are appropriate, in order to improve
      interoperability between YAML systems.
    </para>

    <sect1>
      <title><anchor id="type-seq" />Sequence</title>

      <variablelist>
        <varlistentry>
          <term>
            <para>
              URI:
            </para>
          </term>

          <listitem>
            <para>
              <userinput>tag:yaml.org,2002:seq</userinput>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Shorthand:
            </para>
          </term>

          <listitem>
            <para>
              <userinput>!seq</userinput>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Kind:
            </para>
          </term>

          <listitem>
            <para>
              Sequence.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Definition:
            </para>
          </term>

          <listitem>
            <para>
              Collections indexed by sequential integers starting with zero.
              Example bindings include the Perl array, Python's list or
              tuple, and Java's array or vector.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Resolution and Validation:
            </para>
          </term>


          <listitem>
            <para>
              This tag accepts all sequence values. It is is typically used as
              the fall-back tag for <link
              linkend="syntax-sequence">sequence</link> nodes.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
        <title><userinput>!seq</userinput> Examples</title>
<programlisting># The following are equal seqs<sbr />
# with different identities.
flow: [ one, two ]
spanning: [ one,
     two ]
block:
  - one
  - two
</programlisting>
      </example>
    </sect1>

    <sect1>
      <title><anchor id="type-map" />Mapping</title>

      <variablelist>
        <varlistentry>
          <term>
            <para>
              URI:
            </para>
          </term>

          <listitem>
            <para>
              <userinput>tag:yaml.org,2002:map</userinput>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Shorthand:
            </para>
          </term>

          <listitem>
            <para>
              <userinput>!map</userinput>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Kind:
            </para>
          </term>

          <listitem>
            <para>
              Mapping.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Definition:
            </para>
          </term>

          <listitem>
            <para>
              Associative container, where each key is unique in the
              association and mapped to exactly one value. Example bindings
              include the Perl hash, Python's dictionary, and Java's Hashtable.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Resolution and Validation:
            </para>
          </term>


          <listitem>
            <para>
              This tag accepts all mapping values. It is is typically used as
              the fall-back tag for <link
              linkend="syntax-mapping">mapping</link> nodes.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
        <title><userinput>!map</userinput> Examples</title>
<programlisting># The following are equal maps<sbr />
# with different identities.
flow: { one: 1, two: 2 }
block:
    one: 1
    two: 2
</programlisting>
      </example>
    </sect1>

    <sect1>
      <title><anchor id="type-str" />String</title>

      <variablelist>
        <varlistentry>
          <term>
            <para>
              URI:
            </para>
          </term>

          <listitem>
            <para>
              <userinput>tag:yaml.org,2002:str</userinput>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Shorthand:
            </para>
          </term>

          <listitem>
            <para>
              <userinput>!str</userinput>
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Kind:
            </para>
          </term>

          <listitem>
            <para>
              Scalar.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Definition:
            </para>
          </term>

          <listitem>
            <para>
              Unicode strings, a sequence of zero or more Unicode characters.
              This type is usually bound to the native language's string or
              character array construct. Note that generic YAML tools should
              have an immutable (const) interface to such constructs even when
              the language default is mutable (such as in C/C++).
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Canonical Format:
            </para>
          </term>

          <listitem>
            <para>
              N/A (single format).
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>
            <para>
              Resolution and Validation:
            </para>
          </term>


          <listitem>
            <para>
              This tag accepts all scalar values. It is is typically used as
              the fall-back tag for <link linkend="syntax-scalar">scalar</link>
              nodes.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
        <title><userinput>!str</userinput> Examples</title>
<programlisting># Assuming an application<sbr />
# using implicit integers.
- 12     # An integer
# The following scalars
# are loaded to the
# string value '1' '2'.
- !str 12
- '12'
- "12"
- "\
 1\
 2"
# Otherwise, everything is a string:
- /foo/bar
- 192.168.1.1
</programlisting>
      </example>
    </sect1>
  </appendix>

  <appendix>
    <title><anchor id="bnf-reference" />BNF Productions</title>

    <para>
      This appendix repeats all the productions of the <link
      linkend="syntax">syntax</link> in a single continuous production set, for
      use as a quick reference.
    </para>

    <productionset>
      &productionsrecap;
    </productionset>
  </appendix>

  <index />
</book>
