<?xml version="1.0"?>
<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook V4.2//EN"
         "file:///usr/local/share/xml/docbook/4.2/docbookx.dtd"
[]>

<book status="draft">
  <bookinfo>
    <title>
      YAML Ain't Markup Language (<trademark>YAML</trademark>) 1.0
    </title>

    <subtitle>
      Release Canidate 2004-JAN-29
    </subtitle>

    <authorgroup>
      <author>
        <firstname>Oren</firstname>
        <surname>Ben-Kiki</surname>
        <email>oren@ben-kiki.org</email>
      </author>

      <author>
        <firstname>Clark</firstname>
        <surname>Evans</surname>
        <email>cce@clarkevans.com</email>
      </author>

      <author>
        <firstname>Brian</firstname>
        <surname>Ingerson</surname>
        <email>ingy@ttul.org</email>
      </author>
    </authorgroup>

    <copyright>
      <year>2001-2004</year>
      <holder>Oren Ben-Kiki</holder>
      <holder>Clark Evans</holder>
      <holder>Brian Ingerson</holder>
    </copyright>

    <releaseinfo id="releaseinfo">
      <emphasis>This version:</emphasis>
      <ulink url="http://www.yaml.org/spec/29jan2004.html" /><sbr />
      <emphasis>Latest version:</emphasis>
      <ulink url="http://www.yaml.org/spec" />
    </releaseinfo>

    <legalnotice>
      This document may be freely copied provided it is not modified.
    </legalnotice>

    <abstract>
      <title>Status of this Document</title>

      <para>
        This specification is a release candidate and reflects consensus
        reached by members of the yaml-core mailing list. Any questions
        regarding this draft should be raised on this list at <ulink
        url="http://lists.sourceforge.net/lists/listinfo/yaml-core"/>. With
        this release of the YAML specification, all further changes will be
        strictly limited to clarifications, or fixing bugs in productions.
        At this point, further enhancement or correction of logical flaws
        will be put off to the next version (1.1) of the YAML specification.
      </para>

      <para>
        We wish to thank implementers who have tirelessly tracked earlier
        versions of this specification, and our fabulous user community
        whose feedback has both validated and clarified our direction.
      </para>
    </abstract>

    <abstract>
      <title>Abstract</title>

      <para>
        <trademark>YAML</trademark> (rhymes with <quote>camel</quote>) is a
        human friendly, cross language, unicode based data serialization
        language designed around the common native structures of agile
        programming languages. It is broadly useful for programming needs
        ranging from configuration files to Internet messaging to object
        persistence to data auditing. Together with the <ulink
        url="http://www.unicode.org/">Unicode</ulink> standard for
        characters, this specification provides all the information
        necessary to understand YAML Version 1.0 and to construct programs
        that process YAML information.
      </para>
    </abstract>

  </bookinfo>

  <chapter>
    <title><anchor id="intro"/>Introduction</title>

    <para>
      "YAML Ain't Markup Language" (abbreviated YAML) is a data
      serialization language designed to be human friendly and work well
      with modern programming languages for common everyday tasks. This
      specification is both an introduction to the YAML language and the
      concepts supporting it; and also a complete reference of the
      information needed to develop applications for processing YAML.
    </para>

    <para>
      Open, interoperable and readily understandable tools have advanced
      computing immensely. YAML was designed from the start to be useful and
      friendly to the people working with data. It uses printable unicode
      characters, some of which provide structural information and the rest
      representing the data itself. YAML achieves a unique cleanness by
      minimizing the amount of structural characters, and allowing the data
      to show itself in a natural and meaningful way. For example,
      indentation is used for structure, colons separate pairs, and dashes
      are used for bulleted lists.
    </para>

    <para>
      Although there are many flavors of data structures, they can all be
      adequately represented with three basic primitives: mappings
      (hashes/dictionaries), sequences (arrays/lists) and scalars
      (strings/numbers). YAML leverages these primitives and adds a simple
      typing system and aliasing mechanism to form a complete language for
      serializing any data structure. While most programming languages
      can use YAML for data serialization, YAML excels in those languages
      that are fundamentally built around the three basic primitives. These
      include the new wave of agile languages such as Perl, Python, PHP,
      Ruby and Javascript.
    </para>

    <para>
      There are hundreds of different languages for programming, but only a
      handful of languages for storing and transferring data. Although its
      potential is unlimited, YAML was created to work well for common use
      cases such as: configuration files, log files, interprocess messaging,
      cross-langauge data sharing, object persistence and debugging of
      complex data structures. When data is well organized and easy to
      understand, programming becomes a simpler task.
    </para>

    <sect1>
      <title><anchor id="intro-goals" />Goals</title>

      <para>
        The design goals for YAML are:
      </para>

      <orderedlist>
        <listitem>
          YAML documents are easily readable by humans.
        </listitem>
        <listitem>
          YAML uses the native data structures of agile languages.
        </listitem>
        <listitem>
          YAML data is portable between programming languages.
        </listitem>
        <listitem>
          YAML has a consistent model to support generic tools.
        </listitem>
        <listitem>
          YAML enables stream-based processing.
        </listitem>
        <listitem>
          YAML is expressive and extensible.
        </listitem>
        <listitem>
          YAML is easy to implement and use.
        </listitem>
      </orderedlist>
    </sect1>

    <sect1>
      <title><anchor id="intro-prior" />Prior Art</title>

      <para>
        YAML's initial direction was set by the data serialization and
        markup language discussions among <ulink
        url="http://www.docuverse.com/smldev/">SML-DEV</ulink> members. It
        directly incorporated experience from Brian Ingerson's Perl module
        <ulink
        url="http://search.cpan.org/doc/INGY/Data-Denter-0.13/Denter.pod"
        >Data::Denter</ulink>. Since then YAML has matured through ideas
        and support from its user community.
      </para>

      <para>
        YAML integrates and builds upon concepts described by
        <ulink url="http://cm.bell-labs.com/cm/cs/cbook/index.html">C</ulink>,
        <ulink url="http://java.sun.com/">Java</ulink>, <ulink
        url="http://www.perl.org/">Perl</ulink>, <ulink
        url="http://www.python.org/">Python</ulink>, <ulink
        url="http://www.ruby-lang.org/">Ruby</ulink>, <ulink
        url="http://www.ietf.org/rfc/rfc0822.txt">RFC0822</ulink> (MAIL),
        <ulink
        url="http://www.ics.uci.edu/pub/ietf/html/rfc1866.txt">RFC1866</ulink>
        (HTML), <ulink
        url="http://www.ietf.org/rfc/rfc2045.txt">RFC2045</ulink> (MIME),
        <ulink url="http://www.ietf.org/rfc/rfc2396.txt">RFC2396</ulink> (URI),
        <ulink url="http://www.w3.org/TR/REC-xml.html">XML</ulink>,
        <ulink url="http://www.saxproject.org/">SAX</ulink> and <ulink
        url="http://www.w3.org/TR/SOAP">SOAP</ulink>.
      </para>

      <para>
        The syntax of YAML was motivated by Internet Mail (RFC0822) and
        remains partially compatible with this standard. Further, YAML
        borrows the idea of having <link linkend="c-l-yaml-stream">multiple
        documents</link> from MIME (RFC2045). YAML's top-level production
        is a <link linkend="preview-struct">stream</link> of independent
        serializations; ideal for message-based distributed processing
        systems.
      </para>

      <para>
        YAML's indentation based <link linkend="syntax-space-indent">block
        scoping</link> is similar to Python's (without the ambiguity caused
        by tabs). Indented blocks facilitate easy inspection of a document's
        structure. YAML's <link
        linkend="syntax-scalar-literal">literal</link> scalar leverages this
        by enabling formatted text to be cleanly mixed within an indented
        structure without troublesome escaping.
      </para>

      <para>
        YAML's <link linkend="syntax-scalar-double">double quoted</link>
        scalar uses familar C-style <link
        linkend="syntax-scalar-escape">escape sequences</link>. This enables
        ASCII representation of non-printable or 8-bit (ISO 8859-1)
        characters such as <link linkend="ns-esc-8-bit"
        ><quote><userinput>\x3B</userinput></quote></link>. 16-bit Unicode
        and 32-bit (ISO/IEC 10646) characters are supported with escape
        sequences such as <link linkend="ns-esc-16-bit"
        ><quote><userinput>\u003B</userinput></quote></link> and <link
        linkend="ns-esc-32-bit"
        ><quote><userinput>\U0000003B</userinput></quote></link>.
      </para>

      <para>
        Motivated by HTML's end-of-line normalization, YAML's <link
        linkend="syntax-scalar-folded">folded</link> scalar employs an
        intuitive method of handling white space. In YAML, single line breaks
        may be <link linkend="syntax-scalar-folding">folded</link> into a
        single space, while empty lines represent line break characters.
        This technique allows for paragraphs to be word-wrapped without
        affecting the canonical form of the content.
      </para>

      <para>
        YAML's core type system is based on the serialization requirements
        of Perl, Python and Ruby. YAML directly supports both <link
        linkend="preview-collect">collection</link> (<link
        linkend="type-map">hash</link>, <link
        linkend="type-seq">array</link>) values and <link
        linkend="preview-scalar">scalar</link> (<link
        linkend="type-str">string</link>) values. Support for common types
        enables programmers to use their language's native data constructs
        for YAML manipulation, instead of requiring a special document
        object model (DOM).
      </para>

      <para>
        Like XML's SOAP, YAML supports serializing native graph structures
        through a rich <link linkend="model-serial-alias">alias</link>
        mechanism. Also like SOAP, YAML provides for <link
        linkend="model-native-type">application-defined types</link>. This
        allows YAML to serialize rich data structures required for modern
        distributed computing. YAML provides unique global <link
        linkend="syntax-stream-tag">type names</link> using a namespace
        mechanism inspired by Java's DNS based package naming convention and
        XML's URI based namespaces.
      </para>

      <para>
        YAML was designed to have an incremental interface that includes
        both a pull-style input stream and a push-style (SAX-like) output
        stream interfaces. Together this enables YAML to support the
        processing of large documents, such as a transaction log, or
        continuous streams, such as a feed from a production machine.
      </para>
    </sect1>

    <sect1>
      <title><anchor id="intro-xml" />Relation to XML</title>

      <para>
        Newcomers to YAML often search for its correlation to the eXtensible
        Markup Language (XML). While the two languages may actually compete
        in several application domains, there is no direct correlation
        between them.
      </para>

      <para>
        YAML is primarily a data serialization language. XML was designed to
        be backwards compatible with the Standard Generalized Markup
        Language (SGML) and thus had many design constraints placed on it
        that YAML does not share. Inheriting SGML's legacy, XML is designed
        to support structured documents, where YAML is more closely targeted
        at messaging and native data structures. Where XML is a pioneer in
        many domains, YAML is the result of lessons learned from XML and
        other technologies.
      </para>

      <para>
        It should be mentioned that there are ongoing efforts to define
        standard XML/YAML mappings. This generally requires that a subset of
        each language be used. For more information on using both XML and
        YAML, please visit <ulink url="http://yaml.org/xml/" />.
      </para>
    </sect1>

    <sect1>
      <title><anchor id="intro-term" />Terminology</title>

      <para>
        This specification uses key words in accordance with <ulink
        url="http://www.ietf.org/rfc/rfc2119.txt">RFC2119</ulink> to
        indicate requirement level. In particular, the following words are
        used to describe the actions of a YAML processor:
      </para>

      <variablelist>
        <varlistentry>
          <term><firstterm>May</firstterm></term>
	  <listitem>
            This word, or the adjective
            <quote><firstterm>Optional</firstterm></quote>, mean that
            conformant YAML processors are permitted, but need not behave as
            described.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><firstterm>Should</firstterm></term>
	    <listitem>
              This word, or the adjective
              <quote><firstterm>Recommended</firstterm></quote>, mean that
              there could be reasons for a YAML processor to deviate from
              the behavior described, but that such deviation could hurt
              interoperability and should therefore be advertised with
              appropriate notice.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><firstterm>Must</firstterm></term>
	    <listitem>
              This word, or the term
              <quote><firstterm>Required</firstterm></quote> or
              <quote><firstterm>Shall</firstterm></quote>, mean that the
              behavior described is an absolute requirement of the
              specification.
            </listitem>
          </varlistentry>
      </variablelist>

      <para>
        This specification uses the following terms with specific meanings.
        These terms can also be found in the <ulink url="http://www.foldoc.org"
        >FOLDOC</ulink> (Free OnLine Dictionary of Computing) or <ulink
        url="http://nist.gov/dads/">NIST Dictionary</ulink>.
      </para>

      <variablelist>
        <varlistentry>
          <term><firstterm>Graph</firstterm></term>
	  <listitem>
            A (connected, directed) graph is a set of nodes and arrows,
            where arrows connect one node to another. By using the term
            <quote>graph</quote> we imply that the structure need not be a
            tree. In other words, a given node may have more than one
            incoming arrow and cycles are allowed.
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><firstterm>Function</firstterm></term>
	  <listitem>
            A function is a correspondence between two sets such that each
            member of the first set is associated with exactly one member in
            the second set.
          </listitem>
        </varlistentry>
      </variablelist>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="preview" />Preview</title>

    <para>
      This section provides a quick glimpse into the expressive power of
      YAML. It is not expected that the first-time reader grok all of the
      examples. Rather, these selections are used as motivation for the
      remainder of the specification.
    </para>

    <sect1>
      <title><anchor id="preview-collect" />Collections</title>

      <para>
        YAML's block collections use indentation for scope and begin each
        member on its own line. Block sequences indicate each member with a
        dash&nbsp;(<quote><userinput>-</userinput></quote>). Block mappings
        use a colon to mark each (key:&nbsp;value) pair.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Sequence of scalars<sbr />
              (ball players)
            </title>
<programlisting>
- Mark McGwire
- Sammy Sosa
- Ken Griffey
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Mapping of scalars to scalars<sbr />
              (player statistics)
            </title>
<programlisting>
hr:  65
avg: 0.278
rbi: 147
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Mapping of scalars to sequences<sbr />
              (ball clubs in each league)
            </title>
<programlisting>
american:
  - Boston Red Sox
  - Detroit Tigers
  - New York Yankees
national:
  - New York Mets
  - Chicago Cubs
  - Atlanta Braves
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Sequence of mappings<sbr />
              (players' statistics)
            </title>
<programlisting>
-
  name: Mark McGwire
  hr:   65
  avg:  0.278
-
  name: Sammy Sosa
  hr:   63
  avg:  0.288
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        YAML also has in-line flow styles for compact notation. The flow
        sequence is written as a comma separated list within square
        brackets. In a similar manner, the flow mapping uses curley braces.
        In YAML, the space after the <quote><userinput>-</userinput></quote>
        and  <quote><userinput>:</userinput></quote> and
        <quote><userinput>:</userinput></quote> is mandatory.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Sequence of sequences</title>
<programlisting>
- [name        , hr, avg  ]
- [Mark McGwire, 65, 0.278]
- [Sammy Sosa  , 63, 0.288]


</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Mapping of mappings</title>
<programlisting>
Mark McGwire: {hr: 65, avg: 0.278}
Sammy Sosa: {
    hr: 63,
    avg: 0.288
  }
</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-struct" />Structures</title>

      <para>
        YAML uses three
        dashes&nbsp;(<quote><userinput>---</userinput></quote>) to separate
        documents within a stream. Comment lines begin with the pound
        sign&nbsp;(<quote><userinput>#</userinput></quote>). Three
        dots&nbsp;(<quote><userinput>...</userinput></quote>) indicate the
        end of a document without starting a new one, for use in
        communication channels.
      </para>

      <para>
        Repeated nodes are first marked with the
        ampersand&nbsp;(<quote><userinput>&amp;</userinput></quote>) and
        then referenced with an
        asterisk&nbsp;(<quote><userinput>*</userinput></quote>) thereafter.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Two documents in a stream<sbr />
              each with a leading comment
            </title>
<programlisting>
# Ranking of 1998 home runs
---
- Mark McGwire
- Sammy Sosa
- Ken Griffey

# Team ranking
---
- Chicago Cubs
- St Louis Cardinals
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Play by play feed<sbr />
              from a game
            </title>
<programlisting>
---
time: 20:03:20
player: Sammy Sosa
action: strike (miss)
...
---
time: 20:03:47
player: Sammy Sosa
action: grand slam
...
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Single document with two comments<sbr />
              &nbsp;
            </title>
<programlisting>
---
hr: # 1998 hr ranking
  - Mark McGwire
  - Sammy Sosa
rbi:
  # 1998 rbi ranking
  - Sammy Sosa
  - Ken Griffey
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Node for <quote><userinput>Sammy Sosa</userinput></quote><sbr />
              appears twice in this document
            </title>
<programlisting>
---
hr:
  - Mark McGwire
  # Following node labeled SS
  - &amp;SS Sammy Sosa
rbi:
  - *SS # Subsequent occurance
  - Ken Griffey
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        The question mark indicates a complex key. Within a block sequence,
        mapping pairs can start immediately following the dash.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Mapping between sequences</title>
<programlisting>
? # PLAY SCHEDULE
  - Detroit Tigers
  - Chicago Cubs
:
  - 2001-07-23

? [ New York Yankees,
    Atlanta Braves ]
: [ 2001-07-02, 2001-08-12,
    2001-08-14 ]
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Sequence key shortcut</title>
<programlisting>
---
# products purchased
- item    : Super Hoop
  quantity: 1
- item    : Basketball
  quantity: 4
- item    : Big Shoes
  quantity: 1


</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-scalar" />Scalars</title>

      <para>
        Scalar values can be written in block form using a literal
        style&nbsp;(<quote><userinput>|</userinput></quote>) where all new
        lines count. Or they can be written with the folded
        style&nbsp;(<quote><userinput>&gt;</userinput></quote>) for content
        that can be word wrapped. In the folded style, newlines are treated as
        a space unless they are part of a blank or indented line.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              In literals,<sbr />
              newlines are preserved
            </title>
<programlisting>
# ASCII Art
--- |
  \//||\/||
  // ||  ||__
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              In the plain scalar,<sbr />
              newlines are treated as a space
            </title>
<programlisting>
---
  Mark McGwire's
  year was crippled
  by a knee injury.
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Folded newlines preserved<sbr />
              for indented and blank lines
            </title>
<programlisting>
--- &gt;
 Sammy Sosa completed another
 fine season with great stats.

   63 Home Runs
   0.288 Batting Average

 What a year!
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Indentation determines scope<sbr />
              &nbsp;
            </title>
<programlisting>
name: Mark McGwire
accomplishment: &gt;
  Mark set a major league
  home run record in 1998.
stats: |
  65 Home Runs
  0.278 Batting Average

</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        YAML's flow scalars include the plain style (most examples thus far)
        and quoted styles. The double quoted style provides escape sequences.
        Single quoted style is useful when escaping is not needed. All flow
        scalars can span multiple lines; intermediate whitespace is trimmed to
        a single space.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Quoted scalars</title>
<programlisting>
unicode: "Sosa did fine.\u263A"
control: "\b1998\t1999\t2000\n"
hexesc:  "\x13\x10 is \r\n"

single: '"Howdy!" he cried.'
quoted: ' # not a ''comment''.'
tie-fighter: '|\-*-/|'
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Multiline flow scalars</title>
<programlisting>
plain:
  This unquoted scalar
  spans many lines.

quoted: "So does this
  quoted scalar.\n"

</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-type" />Types</title>

      <para>
        In YAML, plain (unquoted) scalars are given an implicit type depending
        on the application. YAML's <link linkend="type-repository">type
        repository</link> includes integers, floating point values, timestamps,
        null, boolean, and string values.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Integers</title>
<programlisting>
canonical: 12345
decimal: +12,345
sexagecimal: 3:25:45
octal: 014
hexadecimal: 0xC

</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Floating point</title>
<programlisting>
canonical: 1.23015e+3
exponential: 12.3015e+02
sexagecimal: 20:30.15
fixed: 1,230.15
negative infinity: (-inf)
not a number: (NaN)
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Miscellaneous</title>
<programlisting>
null: ~
true: y
false: n
string: '12345'
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Timestamps</title>
<programlisting>
canonical: 2001-12-15T02:59:43.1Z
iso8601:  2001-12-14t21:59:43.10-05:00
spaced:  2001-12-14 21:59:43.10 -05:00
date:   2002-12-14
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        Explicit typing is denoted with a tag using the
        bang&nbsp;(<quote><userinput>!</userinput></quote>) symbol. Application
        tags should include a domain name and may use the
        caret&nbsp;(<quote><userinput>^</userinput></quote>) to abbreviate
        subsequent types. Ordered mappings and sets can be
        represented using explicit types, and a convention for
        using sequences and mappings.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Various explicit tags</title>
<programlisting>
---
not-date: !str 2002-04-28

picture: !binary |
 R0lGODlhDAAMAIQAAP//9/X
 17unp5WZmZgAAAOfn515eXv
 Pz7Y6OjuDg4J+fn5OTk6enp
 56enmleECcgggoBADs=

application specific tag: !!something |
 The semantics of the tag
 above may be different for
 different documents.

</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Application specific tag</title>
<programlisting>
# Establish a tag prefix
--- !clarkevans.com,2002/graph/^shape
  # Use the prefix: shorthand for
  # !clarkevans.com,2002/graph/circle
- !^circle
  center: &amp;ORIGIN {x: 73, y: 129}
  radius: 7
- !^line
  start: *ORIGIN
  finish: { x: 89, y: 102 }
- !^label
  start: *ORIGIN
  color: 0xFFEEBB
  value: Pretty vector drawing.
</programlisting>
          </example>
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Unorderd set</title>
<programlisting>
# sets are represented as a
# mapping where each key is
# associated with the empty string
--- !set
? Mark McGwire
? Sammy Sosa
? Ken Griff
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Ordered mappings</title>
<programlisting>
# ordered maps are represented as
# a sequence of mappings, with
# each mapping having one key
--- !omap
- Mark McGwire: 65
- Sammy Sosa: 63
- Ken Griffy: 58
</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-full" />Full Length Example</title>

      <para>
        Below are two full-length examples of YAML. On the left is a sample
        invoice; on the right is a sample log file.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Invoice</title>
<programlisting>
--- !clarkevans.com,2002/^invoice
invoice: 34843
date   : 2001-01-23
bill-to: &amp;id001
    given  : Chris
    family : Dumars
    address:
        lines: |
            458 Walkman Dr.
            Suite #292
        city    : Royal Oak
        state   : MI
        postal  : 48046
ship-to: *id001
product:
    - sku         : BL394D
      quantity    : 4
      description : Basketball
      price       : 450.00
    - sku         : BL4438H
      quantity    : 1
      description : Super Hoop
      price       : 2392.00
tax  : 251.42
total: 4443.52
comments:
    Late afternoon is best.
    Backup contact is Nancy
    Billsmer @ 338-4338.
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Log file</title>
<programlisting>
---
Time: 2001-11-23 15:01:42 -05:00
User: ed
Warning:
  This is an error message
  for the log file
---
Time: 2001-11-23 15:02:31 -05:00
User: ed
Warning:
  A slightly different error
  message.
---
Date: 2001-11-23 15:03:17 -05:00
User: ed
Fatal:
  Unknown variable "bar"
Stack:
  - file: TopClass.py
    line: 23
    code: |
      x = MoreObject("345\n")
  - file: MoreClass.py
    line: 58
    code: |-
      foo = bar



</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="model" />Processing YAML Information</title>

    <para>
      YAML is both a text format and a method for representing native
      language data structures in this format. This specification defines
      two concepts: a class of data objects called YAML representations, and
      a syntax for serializing YAML representations as a series of
      characters, called a YAML stream. A YAML
      <firstterm>Processor</firstterm> is a tool for converting information
      between these complementary views. It is assumed that a YAML processor
      does its work on behalf of another module, called an
      <firstterm>Application</firstterm>. This chapter describes the
      information structures a processor must provide to or obtain from the
      application.
    </para>

    <sect1>
      <title><anchor id="model-overview" />Overview</title>

      <para>
        YAML information is used in two ways: for machine processing, and
        for human consumption. The challange of reconciling these two
        perspectives is best done in three distinct translation stages:
        representation, serialization, and presentation. Representation
        addresses how YAML views native language data structures to achieve
        portability between programming environments. Serialization
        concerns itself with turning a YAML representation into a serial
        form, that is, a form with sequential access constraints.
        Presentation deals with the formatting of a YAML serialization as a
        stream of characters, in a manner friendly to humans.
      </para>

      <figure>
        <title>YAML Overview</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="diagram.eps" format="eps" />
          </imageobject>
          <imageobject>
            <imagedata fileref="diagram.png" format="png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        A processor need not expose the serialization or representation
        stages. It may translate directly between native objects and
        a character stream and (<quote>freeze</quote> and <quote>thaw</quote>
        in the diagram above). However, such a direct translation should
        take place so that the native objects are constructed only from
        information available in the representation.
      </para>

      <sect2>
        <title><anchor id="model-overview-represent" />Representation</title>

        <para>
          YAML representations model the data
          constructs from agile programming languages, such as Perl,
          Python, or Ruby. YAML representations view native language data
          objects in a generic manner, allowing data to be portable between
          various programming languages and implementations. Strings,
          arrays, hashes, and other user-defined types are supported. This
          specification formalizes what it means to be a YAML
          representatation and suggests how native language objects can be
          viewed as a YAML representation.
        </para>

        <para>
          YAML representations are constructed with three primitives: the
          <link linkend="model-native-sequence" >sequence</link>, the <link
          linkend="model-native-mapping" >mapping</link> and the <link
          linkend="model-native-scalar" >scalar</link>. By sequence we mean
          an ordered collection, by mapping we mean an unordered association
          of unique keys to values, and by scalar we mean any object with
          opaque structure yet expressable as a series of unicode
          characters. When used generatively, these primitives construct
          directed graph structures. These primitives were chosen beacuse
          they are both powerful and familiar: the sequence corresponds to a
          Perl array and a Python list, the mapping corresponds to a Perl
          hashtable and a Python dictionary. The scalar represents strings,
          integers, dates and other atomic data types.
        </para>

        <para>
          YAML represents any native language data object as one of these
          three primitives, together with a type specifier called a
          <firstterm>tag</firstterm>. Type specifiers are either global,
          using a syntax based on the domain name and registration date, or
          private in scope. For example, an integer is represented in YAML
          with a scalar plus a globally scoped
          <userinput>tag:yaml.org,2002/int</userinput> tag. Similarly, an
          invoice object, particular to a given organization, could be
          represented as a mapping together with a
          <userinput>x-private:invoice</userinput> tag. This simple model,
          based on the sequence and mapping and scalar together with a type
          specifier, can represent any data structure independent of
          programming language.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-overview-serial" />Serialization</title>

        <para>
          For sequential access mediums, such as an
          event callback API, a YAML representation must be serialized to an
          ordered tree. Serialization is necessary since nodes in a YAML
          representation may be referenced more than once (more than one
          incoming arrow) and since mapping keys are unordered. Serialization
          is accomplished by imposing an ordering on mapping keys and by
          replacing the second and subsequent references to a given node with
          place holders called aliases. The result of this process, the YAML
          serialization tree, can then be traversed to produce a series of
          event calls for one-pass processing of YAML data.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-overview-present" />Presentation</title>

        <para>
          YAML <firstterm>character streams</firstterm> (or documents)
          encode YAML representations into a series of characters. Some of
          the characters in a YAML stream represent the content of the
          source information, while other characters are used for
          presentation style. Not only must YAML character streams store
          YAML representations, they must do so in a manner which is human
          friendly.
        </para>

        <para>
          To address human presentation, the YAML syntax has a rich set of
          stylistic options which go far beyond the needs of data
          serialization. YAML has two approaches for expressing a node's
          nesting, one that uses indentation to designate depth in the
          serialization tree and another which uses begin and end
          delimiters. Depending upon escaping and how line breaks should be
          treated, YAML scalars may be written with many different styles.
          YAML syntax also has a comment mechanism for annotations othogonal
          to the <quote>content</quote> of a YAML representation. These
          presentation level details provide sufficient variety of
          expression.
        </para>

        <para>
          In a similar manner, for human readable text, it is frequently
          desirable to omit data typing information which is often obvious
          to the human reader and not needed. This is especially true if the
          information is created by hand, expecting humans to bother with
          data typing detail is optimistic. Implicit type information may be
          restored using a data schema or similar mechanisms.
        </para>
      </sect2>

      <note>
        To maximize data portability between programming languages and
        implementations, users of YAML should be mindful of the distinction
        between serialization or presentation properties and those which are
        part of the YAML representation. While imposing a order on mapping
        keys is necessary for flattening YAML representations to a
        sequential access medium, the specific ordering of a mapping should
        not be used to convey application level information. In a similar
        manner, while indentation technique or the specific scalar style is
        needed for character level human presentation, this syntax detail is
        not part of a YAML serialization nor a YAML representation. By
        carefully separating properties needed for serialization and
        presentation, YAML representations of native language information
        will be consistent and portable between various programming
        environments.
      </note>
    </sect1>

    <sect1>
      <title><anchor id="model-represent" />Representation</title>

      <para>
        In YAML's view, native data is viewed as a directed
        graph of <link linkend="model-represent-tag">tagged</link> <link
        linkend="model-represent-node">nodes</link>. Nodes that are defined in
        terms of other nodes are <link
        linkend="model-represent-collect">collections</link> and nodes that are
        defined independent of any other nodes are <link
        linkend="model-represent-scalar">scalars</link>. YAML supports two
        kinds of collection nodes, <link
        linkend="model-represent-sequence">sequence</link> and <link
        linkend="model-represent-mapping">mappings</link>.   Mapping nodes
        are somewhat tricky beacuse its keys are considered to be unordered
        and <link linkend="model-represent-equality">unique</link>.
      </para>

      <sect2>
        <title><anchor id="model-represent-tag" />Tags</title>

	<para>
          YAML represents type information of native objects with a simple
          identifier, called a <firstterm>tag</firstterm>. These identifiers
          are <ulink url="http://www.ietf.org/rfc/rfc2396.txt">URIs</ulink>,
          using a subset of the <ulink url="http://www.taguri.org">tag</ulink>
          scheme (<ulink url="http://yaml.org/spec/taguri.txt">mirror</ulink>).
          YAML tags use only the domain based form, 
          <userinput>tag:</userinput><varname>domain</varname><userinput>,</userinput><varname>date</varname><userinput>:</userinput><varname>identifier</varname>,
          for example, <userinput>tag:yaml.org,2002:str</userinput>.
        </para>

        <para>
          YAML tags can either be globally unique, or private to a particular
          document.  Private tags are of the form <userinput>tag:private.yaml.org,2002:</userinput><varname>identifier</varname>.
          All the other tags are globally unique since they are based upon a
          domain name plus the date that the tag is minted.  If the day is
          omitted it is assumed to be 1st of the month, and if the month and
          day are omitted it is assumed to be January 1st of the given year.
          Clearly private tags are not globally unique, since the domain name
          and the date are fixed.
        </para> 

        <para>
          Tags are used to associate meta information with the YAML 
          representation.  This information includes: the kind of node
          used by the tag, the set of allowed values, and the canonical
          form for comparisons.   TODO continue
        </para>
        <para>
          Each type family must have a kind that is either a <link
          linkend="model-native-scalar">scalar</link> or a <link
          linkend="model-native-collect">collection</link>. There are
          two kinds of collections, <link
          linkend="model-native-sequence">sequence</link> and <link
          linkend="model-native-mapping">mapping</link>. Usually the
          kind of each type family follows immediately from the
          definition (for example, integers are scalars while
          <userinput>Point</userinput> structures are mappings). In
          other cases, deciding on the kind requires a data modeling
          decision (for example, whether a date is thought of as a
          single scalar or as a mapping with independent sub-parts).
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-represent-scalar" />Scalars</title>
        <para>
          Scalar type families are the simplest. The value of a
          scalar node is defined in some mathematical terms,
          independent of any other nodes and type families.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-represent-sequence" />Sequence</title>
        <para>
          The value of a sequence node is defined as an ordered
          set of nodes. Each sequence type family may impose
          additional constraints on these nodes. For example, it
          may require that they belong to particular type
          families.
        </para>
        <para>
          Is possible to think of a sequence as a mapping using
          a special domain (all integer values between zero and
          some maximal value). A unified collection model is
          helpful both for theoretical analysis and in
          constructing practical YAML tools and APIs.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-represent-mapping" />Mapping</title>
        <para>
          Talk about mappings
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-native-equiv" />Equivalence</title>

	<para>
          In most programming languages, there are two distinct manners in
          which variables can be equivalent.
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <anchor id="model-native-equiv-identity" />
              <firstterm>Identity</firstterm>
            </term>

            <listitem>
	      <para>
                The first form of equivalence is by reference, where the two
                variables refer to the same memory address. We call this
                equivalence relation <emphasis>identity</emphasis>.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <anchor id="model-native-equiv-equality" />
              <firstterm>Equality</firstterm>
            </term>

            <listitem>
	      <para>
                The second form of equivalence occurs when two nodes are
                different (have different memory addresses), but have the
                same content. We call this second form of equivalence
                <emphasis>equality</emphasis>. It follows that when two
                nodes are identical they are also equal.
              </para>

	      <para>
                Equality is defined between scalar nodes and between
                collection nodes, as described below.
              </para>

              <variablelist>
                <varlistentry>
                  <term><firstterm>Scalar Equality</firstterm></term>

                  <listitem>
		    <para>
                      Two <link linkend="model-native-scalar">scalar</link>
                      nodes are equal if and only if they have the same
                      <link linkend="model-native-type">type family</link>
                      and their <link
                      linkend="model-native-value">values</link> are the
                      same under the type family's <link
                      linkend="model-native-type-definition">definition</link>
                    </para>
                  </listitem>
                </varlistentry>

                <varlistentry>
                  <term><firstterm>Collection Equality</firstterm></term>

                  <listitem>
		    <para>
                      Equality of collections is defined recursively. Two
                      <link linkend="model-native-collect">collection</link>
                      nodes are equal if and only if they have the same
                      <link linkend="model-native-type">type family</link>
                      and for each key in the <link
                      linkend="model-domain">domain</link> of one, there is
                      a corresponding key in the domain of the other such
                      that both keys are <link
                      linkend="model-native-equiv-equality">equal</link> and
                      their corresponding values are equal; here
                      corresponding value refers to the unique node in the
                      <link linkend="model-range">range</link> of the
                      collection assigned to the key by the collection's
                      <link linkend="model-function">function</link>.
                    </para>
                  </listitem>
                </varlistentry>
              </variablelist>
            </listitem>
          </varlistentry>
        </variablelist>

	<para>
          For the purpose of node equivalence, all YAML collection type
          families are considered to be <firstterm>Mutable</firstterm> and
          all scalar type families are considered to be
          <firstterm>Immutable</firstterm>. It is possible to modify the
          value of a mutable (collection) node "in place". For immutable
          (scalar) nodes, it is impossible to do so; instead, modifications
          require the creation of a new, independent scalar value of the
          same type family and using it instead. To better understand this
          distinction, consider the following example:
        </para>

        <example>
<programlisting>
C syntax: |
    struct Point { int x; int y; } p = { 1, 2 };
YAML syntax: !Point { x: 1, y: 2 }
</programlisting>
        </example>

	<para>
          It is impossible to modify the integer value 1. The only
          modification possible is constructing a new, unrelated integer
          value 3 and using this new value for the X coordinate. Performing
          this replacement would cause the point to change "in place" from
          <userinput>{&nbsp;x:&nbsp;1,&nbsp;y:&nbsp;2&nbsp;}</userinput> to
          <userinput>{&nbsp;x:&nbsp;3,&nbsp;y:&nbsp;2&nbsp;}</userinput>.
          Thus, in this example points are mutable but integers are not.
        </para>

	<para>
          For immutable (scalar) type families, the distinction between
          equal and identical nodes is only of interest for efficiency
          reasons (reducing memory usage), and has no semantic significance.
          Hence for such type families a YAML processor may freely replace
          two equal but separate (non-identical) nodes with two occurrences
          of the same (identical) node, and vice versa.
        </para>

	<para>
          For mutable (collection) type families, however, the distinction
          between equality and indentity is an important part of the
          information model and a YAML processor is required to preserve
          node identity.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-native-stream" />Documents Stream</title>

	<para>
          A YAML stream is a sequence of disjoint directed graphs, each with
          a root node.
        </para>

        <variablelist>
          <varlistentry>
            <term><firstterm>Stream</firstterm></term>

            <listitem>
              <para>
                A sequence of zero or more document root nodes.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <anchor id="model-native-stream-doc" />
              <firstterm>Document</firstterm>
            </term>

            <listitem>
	      <para>
                A top-level <link linkend="model-native-node">node</link>
                that is disjoint from all other root document nodes.
              </para>

	      <para>
                For any two nodes <varname>x</varname> and
                <varname>y</varname> we say that <varname>x</varname> and
                <varname>y</varname> are <firstterm>Disjoint</firstterm> if
                there does not exist a third node <varname>z</varname> that
                is reachable from both <varname>x</varname> and
                <varname>y</varname>.
              </para>

	      <para>
                For any node <varname>x</varname>, <varname>x</varname> is
                <firstterm>Reachable</firstterm> from <varname>y</varname>
                if and only if either <varname>x</varname> and
                <varname>y</varname> are <link
                linkend="model-native-equiv-identity">identical</link>, or
                <varname>y</varname> is a <link
                linkend="model-native-collect">collection</link> and there
                exists a node <varname>z</varname> in the <link
                linkend="model-domain">domain</link> or the <link
                linkend="model-range">range</link> of <varname>y</varname>
                such that <varname>x</varname> is reachable from
                <varname>z</varname>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="model-graph" />Graph (Generic) Model</title>

      <para>
        To access YAML information through a generic API, scalars must be
        viewed as strings. Since a native data type may be stringified in
        more than one way, the graph model extends the <link
        linkend="model-native">native model</link> with the concept of a
        format. This model allows the operation of generic tools to be
        defined independent of language. Applications constructing a native
        binding from the graph model should not use formats for the
        preservation of important data.
      </para>

      <sect2>
        <title><anchor id="model-graph-format" />Format</title>

	<para>
          It may be possible to write a string value of a scalar in more
          than one way. For example, an integer value of 255 can also be
          written in hex as 0xFF. This distinction is covered by the concept
          of a format. A format defines a way to write the values of a
          <link linkend="model-native-scalar">scalar</link> type family as
          Unicode strings. Using formats allows generic YAML APIs to be
          implemented in terms of such strings and still allow handling of
          arbitrary native data.
        </para>

        <variablelist>
          <varlistentry>
            <term><firstterm>Format Name</firstterm></term>

            <listitem>
	      <para>
                Each format has a name used for <link
                linkend="type-explicit">explicit typing</link>. This name
                may also be used as a fragment identifier in combination
                with the type family URI for general identification. This
                name must comply with the <link
                linkend="c-ns-tag-property">format</link> production, and
                must be unique within the type families it applies to.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><firstterm>Format Definition</firstterm></term>

            <listitem>
	      <para>
                A description of the format as it applies to particular data
                values.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><firstterm>Format Regexp</firstterm></term>

            <listitem>
	      <para>
                Regular expressions may be provided to allow <link
                linkend="type-implicit">implicit typing</link> using the
                string format, or to enable the YAML processor to validate
                that a given value is indeed compliant with the string
                format.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

	<para>
          Formats are an extension required by the graph model, and are not
          part of the native model. Hence, when constructing native data
          structures from YAML data, format need not be preserved. For
          example, a YAML integer node should be loaded to a native integer
          data type, discarding the information that the integer was
          serialized in hex format.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-graph-type" />Type Family Formats</title>
	<para>
          Each type family used for <link
          linkend="model-native-scalar">scalar</link> nodes has associated
          formats. These formats can be separated into two groups, implicit
          formats and explicit formats. In addition, one of the formats is
          designated to be the type family's canonical format.
        </para>

	<para>
          Type families used for <link
          linkend="model-native-collect">collection</link> nodes do not have
          any associated formats.
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <anchor id="model-graph-type-implicit" />
              <firstterm>Implicit Format</firstterm>
            </term>
            <listitem>
	      <para>
                A set of zero or more formats used for <link
                linkend="type-implicit">implicit typing</link>. Each format
                may only be used in a single type family for this purpose.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <firstterm>Explicit Format</firstterm>
            </term>

            <listitem>
	      <para>
                A set of zero or more formats used for <link
                linkend="type-explicit">explicit typing</link>. It is
                possible for two type families to share the same explicit
                format, though this practice is discouraged.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <firstterm><userinput>canonical</userinput> format</firstterm>
            </term>

            <listitem>
	      <para>
                In addition to the above, each scalar type family must
                provide a <userinput>canonical</userinput> format. This must
                be one of the implicit or explicit formats, or a subset of
                one of these formats. The canonical format must provide
                exactly one unique string representation for each possible
                value of the scalar.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2>
        <title><anchor id="model-graph-node" />Graph Node</title>

	<para>
          In the graph model, each <link
          linkend="model-native-scalar">scalar</link> node has an associated
          format that is one of those defined by the node's <link
          linkend="model-native-type">type family</link>. <link
          linkend="model-native-collect">Collection</link> nodes do not have
          an associated format. The <link
          linkend="model-native-value">value</link> of graph scalar nodes is
          a Unicode string that is a representation of the appropriate
          native value using the node's format.
        </para>
      </sect2>

      <sect2>
        <title>Implicit Types and Formats</title>

	<para>
          In the graph model, the type family and format are optional. When
          a type family or format is missing, we say that it is implicit. If
          a format is provided, the type family is mandatory. Since the type
          family is mandatory in the native model, the loader must resolve
          the type family and format using <link
          linkend="type-implicit">implicit typing</link>. When native data
          is converted to YAML, the dumper is responsible for deciding which
          <link linkend="model-graph-node">graph nodes</link> will have
          explicit type family and format.
        </para>

	<para>
          Since graph nodes may be implicitly typed, the loader may not be
          able to determine the type family of the node. Even when the type
          family is known, the loader may not have an appropriate native
          type. Therefore, a given YAML document need not have a native
          binding for every programming language or application.
        </para>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="model-serial" />Serial (Tree) Model</title>

      <para>
        To allow for YAML to be communicated as a sequence of events, an
        ordered tree structure must be used instead of a graph. This section
        describes an extension to the <link linkend="model-graph">graph
        model</link> where the graph is flattened and ordered to provide a
        serial interface by using aliases for recurring nodes and by
        imposing key order. Applications constructing a native binding from
        the serial model should not use these extensions for the
        preservation of important data.
      </para>

      <sect2>
        <title><anchor id="model-serial-node" />Serial Node</title>

	<para>
          To lay out <link linkend="model-native-node">graph nodes</link> as
          a tree structure, a mechanism is needed to manage duplicate
          occurrences. This is solved using an additional node kind, <link
          linkend="model-serial-alias">alias</link>. The first occurrence of
          a node is represented using a serial node of the appropriate kind.
          Subsequent occurrences of either a collection or a scalar are
          represented by an alias node.
        </para>

	<para>
          All nodes in the serial model have the following properties in
          addition to the properties defined in the <link
          linkend="model-graph">graph</link> model:
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <anchor id="model-serial-node-parent" /><firstterm>Parent
              Node</firstterm>
            </term>

            <listitem>
	      <para>
                The parent property gives access to the <link
                linkend="model-native-collect">collection</link> that
                contains the current serial node.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <anchor id="model-serial-node-anchor" />
              <firstterm>Anchor</firstterm>
            </term>

            <listitem>
	      <para>
                The anchor is a Unicode string that complies with the <link
                linkend="ns-ns-anchor-name">ns-ns-anchor-name</link>
                production. The anchor is used to associate the first
                occurrence of a <link linkend="model-graph-node">graph
                node</link> with subsequent occurrences, via the <link
                linkend="model-serial-alias">alias</link> serial node. This
                property is optional, provided that the graph node does not
                occur more than once in the document.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

	<para>
          Note that when a serial node is converted to a graph node, the
          anchor, if any, is not preserved. Likewise the parent property and
          the alias kind are not preserved as the graph node may be
          contained in several collections.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-serial-alias" />Alias</title>

	<para>
          The alias node represents subsequent occurrences of a <link
          linkend="model-graph-node">graph node</link> in the document. Like
          all serial nodes, an alias node has a <link
          linkend="model-serial-node-parent">parent</link> and an <link
          linkend="model-serial-node-anchor">anchor</link> property. In
          addition, an anchor node has a single additional property:
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <firstterm>Referent</firstterm>
            </term>

            <listitem>
	      <para>
                The <link linkend="model-serial-node">serial node</link>
                serial node that the alias references is the closest <link
                linkend="model-serial-order">preceding</link> node having
                the same <link
                linkend="model-serial-node-anchor">anchor</link>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>

	<para>
          When an alias node is converted into a <link
          linkend="model-graph-node">graph node</link> it becomes a
          subsequent occurrence of the graph node represented by its
          referent node.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-serial-pair" />Pair</title>

	<para>
          A pair is an ordered set of two <link
          linkend="model-serial-node">serial nodes</link>. The first member
          of the set is the key and the second member of the set is the
          value.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-serial-map" />Serial Mapping</title>

	<para>
          Mapping <link linkend="model-serial-node">serial nodes</link>
          represent the first occurrence of a <link
          linkend="model-native-mapping">mapping</link> in a given document.
          The <link linkend="model-native-value">value</link> of mapping
          serial nodes is an ordered set of node pairs.
        </para>

	<para>
          When a mapping serial node is converted into a <link
          linkend="model-graph-node">graph node</link>, three operations
          occur. The <link linkend="model-domain">domain</link> is
          constructed with the graph node for each key in its set of pairs.
          Likewise, the <link linkend="model-range">range</link> is
          constructed with the graph node for each value in its set of
          pairs. Last, the <link linkend="model-function">function</link> is
          constructed via association of key graph nodes to value graph
          nodes, as provided by the set of pairs. Note that the ordering of
          the pairs is explicitly not converted.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-serial-order" />Ordering</title>

	<para>
          When serializing a YAML graph, every <link
          linkend="model-serial-node">serial node</link> is put into a
          single linear sequence within a given document through the mapping
          pair ordering. With the composition of collections, this ordering
          becomes total.
        </para>

	<para>
          For any two nodes or aliases, <varname>x</varname> and
          <varname>y</varname> we say that <varname>x</varname>
          <firstterm>Precedes</firstterm> <varname>y</varname> when any of
          the following holds:
        </para>

        <itemizedlist>
          <listitem>
            <varname>x</varname> is the <link
            linkend="model-serial-node-parent">parent</link> of
            <varname>y</varname>.
          </listitem>

          <listitem>
            <varname>x</varname> and <varname>y</varname> are nodes within a
            <link linkend="model-native-sequence">sequence</link>, and
            <varname>x</varname> appears before <varname>y</varname>.
          </listitem>

          <listitem>
            <varname>x</varname> is a key and <varname>y</varname> is a value
            in a given <link linkend="model-serial-pair">pair</link>.
          </listitem>

          <listitem>
            <varname>x</varname> and <varname>y</varname> are nodes in two
            <link linkend="model-serial-pair">pairs</link> within a <link
            linkend="model-native-mapping">mapping</link>, and the pair
            containing <varname>x</varname> comes before the pair containing
            <varname>y</varname>.
          </listitem>

          <listitem>
            There exists a node <varname>z</varname> such that
            <varname>x</varname> precedes <varname>z</varname> and
            <varname>z</varname> precedes <varname>y</varname>.
          </listitem>
        </itemizedlist>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="model-text" />Text (Syntax) Model</title>

      <para>
        To enhance readability, a YAML document extends the <link
        linkend="model-serial">serial model</link> with syntax styles,
        comments and directives and other syntactical details. Although the
        parser may provide this information, applications should take care
        not to use these features to encode information found in a native
        binding.
      </para>

      <sect2>
        <title><anchor id="model-text-style" />Style</title>

	<para>
          In the syntax, each node has an additional
          <firstterm>Style</firstterm> property, depending on its <link
          linkend="model-kind">kind</link>.
        </para>

        <variablelist>
          <varlistentry>
            <term><firstterm>Scalar Style</firstterm>
          </term>

            <listitem>
	      <para>
                <link linkend="model-native-scalar">Scalar</link> styles
                include two <link
                linkend="c-l-scalar-blk-value(n)">block</link> styles and
                three <link linkend="ns-ns-scalar-flow-value(n)">flow</link>
                styles. All but the <link
                linkend="syntax-scalar-double">double quoted</link> style
                are limited to scalars having only printable characters.
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
              <firstterm>Collection Style</firstterm>
            </term>

            <listitem>
              <para>
                There are two styles for each of the <link
                linkend="model-native-collect">collection</link> kinds, a
                <link linkend="l-l-collect-blk-value(n)">block</link> style
                and an <link linkend="c-c-collect-flow-value(n)">flow</link>
                style.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2>
        <title><anchor id="model-text-comment" />Comment</title>

	<para>
          The syntax allows optional comment blocks to be interleaved with
          the node blocks. Comment blocks may appear before or after any
          node block. A comment block can't appear inside a scalar node
          value.
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <firstterm>Comment</firstterm>
            </term>

            <listitem>
	      <para>
                A comment is a sequence of zero or more Unicode characters
                complying with the <link
                linkend="c-nb-throwaway-comment">comment</link> productions.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2>
        <title><anchor id="model-text-directive" />Directive</title>

	<para>
          Attached to each <link
          linkend="model-native-stream-doc">document</link> is a document
          directive section.
        </para>

        <variablelist>
          <varlistentry>
            <term>
              <firstterm>Directive</firstterm> Section
            </term>

            <listitem>
	      <para>
                A <link linkend="model-native-collect">collection</link> of
                directives to the parser where each member of the <link
                linkend="model-domain">domain</link> and <link
                linkend="model-range">range</link> are <link
                linkend="model-native-scalar">scalar</link> values matching
                the <link
                linkend="ns-ns-directive-name">ns-ns-directive-name</link>
                and <link
                linkend="ns-ns-directive-value">ns-ns-directive-value</link>
                productions.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

      <sect2>
        <title><anchor id="model-text-detail" />Details</title>

	<para>
          The YAML syntax contains multiple mechanisms for increased
          readability, such as escaping, indentation, folding, line break
          normalization etc. While the parser may make such details
          available, they should not be used to encode information required
          for the construction of the native data.
        </para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="syntax" />Syntax</title>

      <para>
        Following are the BNF productions defining the syntax of YAML streams.
        The productions introduce the relevant character classes and processing
        of white space, and then follow the decomposition of the stream into
        logical chunks. To make this section easier to follow, production names
        use Hungarian-style notation with the following prefixes:
      </para>

      <variablelist>
        <varlistentry>
          <term><userinput>c-</userinput></term>
          <listitem>
            A production matching a single special character.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>b-</userinput></term>
          <listitem>
            A production matching a single line break.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>nb-</userinput></term>
          <listitem>
            A production matching a single non-break character.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>s-</userinput></term>
          <listitem>
            A production matching a single non-break space character.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>ns-</userinput></term>
          <listitem>
            A production matching a single non-break non-space character.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>i-</userinput></term>
          <listitem>
            A production matching indentation spaces.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>l-</userinput></term>
          <listitem>
            A production matching a single line (shorthand for
            <userinput>i-b-</userinput>).
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>X</varname><userinput>-</userinput
               ><varname>Y</varname><userinput>-</userinput></term>
          <listitem>
            A production matching a sequence of characters, starting with an
            <varname>X</varname><userinput>-</userinput> production and ending
            with a <varname>Y</varname><userinput>-</userinput> production.
          </listitem>
        </varlistentry>
      </variablelist>

    <sect1>
      <title><anchor id="syntax-char" />Characters</title>

      <para>
        Characters are the basis for a YAML stream. Below is a general
        definition of a character followed by several characters that have
        specific meaning in particular contexts.
      </para>

      <sect2>
        <title><anchor id="syntax-char-set" />Character Set</title>

        <para>
          YAML streams use a subset of the Unicode character set. On input, a
          YAML processor must accept all printable ASCII characters, the space,
          tab, line break, and all Unicode characters beyond 0x9F. On output, a
          YAML processor must only produce those acceptable characters, and
          should also <link linkend="syntax-scalar-escape">escape</link> all
          non-printable Unicode characters if a character table is readily
          available.
        </para>

        <productionset>
          <production id="c-printable">
            <lhs>c-printable</lhs>
            <rhs>
              <lineannotation>Characters as defined by the Unicode standard,
              excluding most control characters and the surrogate
              blocks.</lineannotation>
              &nbsp;&nbsp;#x9 | #xA | #xD<sbr />
              | [#x20-#x7E] | #x85<sbr />
              | [#xA0-#xD7FF]<sbr />
              | [#xE000-#xFFFD]<sbr />
              | [#x10000-#x10FFFF]
            </rhs>
          </production>
        </productionset>

        <para>
          The range above explicitly excludes the surrogate block
          <userinput>[#xD800-#xDFFF]</userinput>, DEL
          <userinput>0x7F</userinput>, the C0 control block
          <userinput>[#x0-#x1F]</userinput>, the C1 control block
          <userinput>[#x80-#x9F]</userinput>, <userinput>#xFFFE</userinput>
          and <userinput>#xFFFF</userinput>. Note that in UTF-16, characters
          above <userinput>#xFFFF</userinput> are represented with a surrogate
          pair. When present, DEL and characters in the C0 and C1 control block
          must be represented in a YAML stream using escape sequences.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="syntax-char-encode" />Encoding</title>

        <para>
          A YAML processor must support the UTF-32, UTF-16 and UTF-8 character
          encodings. If an input stream does not begin with a <link
          linkend="c-byte-order-mark">byte order mark</link>, the encoding
          shall be UTF-8. Otherwise the encoding shall be UTF-32 (LE or BE),
          UTF-16 (LE or BE) or UTF-8, as signaled by the byte order mark. Note
          that as YAML files may only contain printable characters, this does
          not raise any ambiguities. For more information about the byte order
          mark and the Unicode character encoding schemes see the Unicode
          <ulink
          url="http://www.unicode.org/unicode/faq/utf_bom.html">FAQ</ulink>.
        </para>

        <productionset>
          <production id="c-byte-order-mark">
            <lhs>c-byte-order-mark</lhs>
            <rhs>
              <lineannotation>Unicode BOM.</lineannotation>
              #xFEFF
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-char-indicator" />Indicators</title>

        <para>
          Indicators are special characters that are used to describe the
          structure of a YAML document. As a result, they can't be used as
          the first character of a <link linkend="syntax-scalar-plain">plain
          scalar</link> except for special cases.
        </para>

        <productionset>
          <production id="c-sequence-start">
            <lhs>c-sequence-start</lhs>
            <rhs>
              <lineannotation>Starts a flow sequence
              collection.</lineannotation>
              <quote>[</quote>
            </rhs>
          </production>

          <production id="c-sequence-end">
            <lhs>c-sequence-end</lhs>
            <rhs>
              <lineannotation>Ends a flow sequence collection.</lineannotation>
              <quote>]</quote>
            </rhs>
          </production>

          <production id="c-mapping-start">
            <lhs>c-mapping-start</lhs>
            <rhs>
              <lineannotation>Starts a flow mapping
              collection.</lineannotation>
              <quote>{</quote>
            </rhs>
          </production>

          <production id="c-mapping-end">
            <lhs>c-mapping-end</lhs>
            <rhs>
              <lineannotation>Ends a flow mapping collection.</lineannotation>
              <quote>}</quote>
            </rhs>
          </production>

          <production id="c-sequence-entry">
            <lhs>c-sequence-entry</lhs>
            <rhs>
              <lineannotation>Indicates a sequence entry.</lineannotation>
              <quote>-</quote>
            </rhs>
          </production>

          <production id="c-mapping-entry">
            <lhs>c-mapping-entry</lhs>
            <rhs>
              <lineannotation>Separates a key from its value.</lineannotation>
              <quote>:</quote>
            </rhs>
          </production>

          <production id="c-top-key">
            <lhs>c-top-key</lhs>
            <rhs>
              <lineannotation>Indicates a complex key.</lineannotation>
              <quote>?</quote>
            </rhs>
          </production>

          <production id="c-collect-entry">
            <lhs>c-collect-entry</lhs>
            <rhs>
              <lineannotation>Separates flow collection
              entries.</lineannotation>
              <quote>,</quote>
            </rhs>
          </production>

          <production id="c-tag">
            <lhs>c-tag</lhs>
            <rhs>
              <lineannotation>Indicates a tag property.</lineannotation>
              <quote>!</quote>
            </rhs>
          </production>

          <production id="c-anchor">
            <lhs>c-anchor</lhs>
            <rhs>
              <lineannotation>Indicates an anchor property.</lineannotation>
              <quote>&amp;</quote>
            </rhs>
          </production>

          <production id="c-alias">
            <lhs>c-alias</lhs>
            <rhs>
              <lineannotation>Indicates an alias node.</lineannotation>
              <quote>*</quote>
            </rhs>
          </production>

          <production id="c-literal">
            <lhs>c-literal</lhs>
            <rhs>
              <lineannotation>Indicates a literal scalar.</lineannotation>
              <quote>|</quote>
            </rhs>
          </production>

          <production id="c-folded">
            <lhs>c-folded</lhs>
            <rhs>
              <lineannotation>Indicates a folded scalar.</lineannotation>
              <quote>&gt;</quote>
            </rhs>
          </production>

          <production id="c-single-quote">
            <lhs>c-single-quote</lhs>
            <rhs>
              <lineannotation>Indicates a single quoted
              scalar.</lineannotation>
              <quote>'</quote>
            </rhs>
          </production>

          <production id="c-double-quote">
            <lhs>c-double-quote</lhs>
            <rhs>
              <lineannotation>Indicates a double quoted
              scalar.</lineannotation>
              <quote>"</quote>
            </rhs>
          </production>

          <production id="c-throwaway">
            <lhs>c-throwaway</lhs>
            <rhs>
              <lineannotation>Indicates a throwaway comment.</lineannotation>
              <quote>#</quote>
            </rhs>
          </production>

          <production id="c-directive">
            <lhs>c-directive</lhs>
            <rhs>
              <lineannotation>Indicates a directive.</lineannotation>
              <quote>%</quote>
            </rhs>
          </production>

          <production id="c-reserved">
            <lhs>c-reserved</lhs>
            <rhs>
              <lineannotation>Reserved for future use.</lineannotation>
              <quote>@</quote> | <quote>`</quote>
            </rhs>
          </production>

          <production id="c-indicators">
            <lhs>c-indicators</lhs>
            <rhs>
              <lineannotation>Indicator characters.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#c-sequence-start"><quote>[</quote></nonterminal>
              | <nonterminal def="#c-sequence-end"><quote>]</quote></nonterminal>
              | <nonterminal def="#c-mapping-start"><quote>{</quote></nonterminal>
              | <nonterminal def="#c-mapping-end"><quote>}</quote></nonterminal><sbr />
              | <nonterminal def="#c-sequence-entry"><quote>-</quote></nonterminal>
              | <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              | <nonterminal def="#c-top-key"><quote>?</quote></nonterminal>
              | <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal><sbr />
              | <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
              | <nonterminal def="#c-alias"><quote>*</quote></nonterminal>
              | <nonterminal def="#c-anchor"><quote>&amp;</quote></nonterminal><sbr />
              | <nonterminal def="#c-literal"><quote>|</quote></nonterminal>
              | <nonterminal def="#c-folded"><quote>&gt;</quote></nonterminal>
              | <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal>
              | <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal><sbr />
              | <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal>
              | <nonterminal def="#c-directive"><quote>%</quote></nonterminal>
              | <nonterminal def="#c-reserved"><quote>@</quote> | <quote>`</quote></nonterminal>
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-char-break" />Line Breaks</title>

        <para>
          The Unicode standard defines several <link linkend="b-char">line
          break characters</link>. These line breaks can be grouped into two
          categories. <link linkend="b-specific">Specific line breaks</link>
          have well-defined semantics for breaking text into lines and
          paragraphs. The semantics of <link linkend="b-generic">generic line
          break</link> characters is not defined beyond <quote>ending a
          line</quote>.
        </para>

        <productionset>
          <production id="b-line-feed">
            <lhs>b-line-feed</lhs>
            <rhs>
              <lineannotation>ASCII line feed (LF).</lineannotation>
              #xA
            </rhs>
          </production>

          <production id="b-carriage-return">
            <lhs>b-carriage-return</lhs>
            <rhs>
              <lineannotation>ASCII carriage return (CR).</lineannotation>
              #xD
            </rhs>
          </production>

          <production id="b-next-line">
            <lhs>b-next-line</lhs>
            <rhs>
              <lineannotation>Unicode next line (NEL).</lineannotation>
              #x85
            </rhs>
          </production>

          <production id="b-line-separator">
            <lhs>b-line-separator</lhs>
            <rhs>
              <lineannotation>Unicode line separator (LS).</lineannotation>
              #x2028
            </rhs>
          </production>

          <production id="b-paragraph-separator">
            <lhs>b-paragraph-separator</lhs>
            <rhs>
              <lineannotation>Unicode paragraph separator (PS).</lineannotation>
              #x2029
            </rhs>
          </production>

          <production id="b-char">
            <lhs>b-char</lhs>
            <rhs>
              <lineannotation>Line break characters.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#b-line-feed"/><sbr />
              | <nonterminal def="#b-carriage-return"/><sbr />
              | <nonterminal def="#b-next-line"/><sbr />
              | <nonterminal def="#b-line-separator"/><sbr />
              | <nonterminal def="#b-paragraph-separator"/>
            </rhs>
          </production>

          <production id="b-generic">
            <lhs>b-generic</lhs>
            <rhs>
              <lineannotation>Line break with non-specific
              semantics.</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#b-carriage-return"/><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#b-line-feed"/> )<sbr />
              | <nonterminal def="#b-carriage-return"/><sbr />
              | <nonterminal def="#b-line-feed"/><sbr />
              | <nonterminal def="#b-next-line"/>
            </rhs>
          </production>

          <production id="b-specific">
            <lhs>b-specific</lhs>
            <rhs>
              <lineannotation>Line break with specific
              semantics.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#b-line-separator"/><sbr />
              | <nonterminal def="#b-paragraph-separator"/>
            </rhs>
          </production>

          <production id="b-any">
            <lhs>b-any</lhs>
            <rhs>
              <lineannotation>Any non-content line break.</lineannotation>
              <nonterminal def="#b-generic"/> | <nonterminal def="#b-specific"/>
            </rhs>
          </production>
        </productionset>

        <para>
          Outside scalar text content, YAML allows <link linkend="b-any">any
          line break</link> to be used to terminate lines, and in most cases
          also allows such line breaks to be preceded by <link
          linkend="s-b-trailing-comment">trailing comment</link> characters.
          On output, a YAML processor is free to emit such line breaks using
          whatever convention is most appropriate. YAML output should avoid
          using trailing line spaces.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="syntax-char-misc" />Miscellaneous</title>

        <para>
          This section includes several common character range definitions.
        </para>

        <productionset>
          <production id="nb-char">
            <lhs>nb-char</lhs>
            <rhs>
              <lineannotation>Characters valid in a line.</lineannotation>
              <nonterminal def="#c-printable"/> - <nonterminal def="#b-char"/>
            </rhs>
          </production>

          <production id="s-char">
            <lhs>s-char</lhs>
            <rhs>
              <lineannotation>White space valid in a line.</lineannotation>
              #x9 | #x20
            </rhs>
          </production>

          <production id="ns-char">
            <lhs>ns-char</lhs>
            <rhs>
              <lineannotation>Non-space characters valid in a
              line.</lineannotation>
              <nonterminal def="#nb-char"/> - <nonterminal def="#s-char"/>
            </rhs>
          </production>

          <production id="ns-ascii-letter">
            <lhs>ns-ascii-letter</lhs>
            <rhs>
              <lineannotation>ASCII letters, A-Z or a-z.</lineannotation>
              [#x41-#x5A] | [#x61-#x7A]
            </rhs>
          </production>

          <production id="ns-decimal-digit">
            <lhs>ns-decimal-digit</lhs>
            <rhs>
              <lineannotation>0-9.</lineannotation>
              [#x30-#x39]
            </rhs>
          </production>
          <production id="ns-hex-digit">
            <lhs>ns-hex-digit</lhs>
            <rhs>
              <lineannotation>0-9, A-F or a-f.</lineannotation>
                <nonterminal def="#ns-decimal-digit"/><sbr />
              | [#x41-#x46] | [#x61-#x66]
            </rhs>
          </production>
          <production id="ns-word-char">
            <lhs>ns-word-char</lhs>
            <rhs>
              <lineannotation>Characters valid in a word.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-decimal-digit"/><sbr />
              | <nonterminal def="#ns-ascii-letter"/> | <quote>-</quote>
            </rhs>
          </production>
        </productionset>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-space" />Space Processing</title>
      <para>
        YAML streams use lines and spaces to convey structure. This requires
        special processing rules for white space (<link linkend="s-char">space
        and tab</link>).
      </para>

      <sect2>
        <title><anchor id="syntax-space-indent" />Indentation</title>

        <para>
          In a YAML text representation, structure is determined from
          indentation, where indentation is defined as a line break character
          followed by zero or more space characters.
        </para>

        <para>
          Tab characters are not allowed in indentation. Since different
          systems treat tabs differently, portability problems are a concern.
          Therefore, YAML's tab policy is conservative; they shall not be used.
          Note that most modern editors may be configured so that pressing the
          tab key results in the insertion of an appropriate number of spaces.
        </para>

        <para>
          With one notable exception, a node must be more indented than its
          parent node. All sibling nodes must use the exact same indentation
          level. However the content of each such node may be indented
          independently.
        </para>

        <para>
          The indentation level is used exclusively to delineate structure.
          Indentation characters are otherwise ignored. In particular, they are
          never taken to be a part of the serialized text.
        </para>

        <productionset>
          <production id="i-spaces(n)">
            <lhs>i-spaces(n)</lhs>
            <rhs>
              <lineannotation>Specific level of indentation.</lineannotation>
              #x20 x n
            </rhs>
          </production>
        </productionset>

        <para>
          Since the YAML stream depends upon indentation level to delineate
          blocks, additional productions are a function of an integer, based on
          the <link
          linkend="i-spaces(n)"><userinput>i-spaces(n)</userinput></link>
          production above. In some cases, the notations
          <userinput>production(&lt;n)</userinput>,
          <userinput>production(&les;n)</userinput> and
          <userinput>production(&gt;n)</userinput> are used; these are
          shorthands for <quote><userinput>production(m)</userinput> for some
          specific <varname>m</varname> such that <varname>m</varname> is less
          than/less than or equal/greater than <varname>n</varname></quote>,
          respectively. The notation <userinput>production(any)</userinput> is
          a shorthand for <quote><userinput>production(m)</userinput> for some
          specific value of <varname>m</varname> such that
          <varname>m</varname>&nbsp;&ges;&nbsp;0</quote>.
        </para>

        <para>
          The <quote><userinput>-</userinput></quote> <link
          linkend="c-sequence-entry">sequence entry indicator</link> is
          perceived by people to be part of the indentation. Hence the
          indentation rules are slightly more flexible when dealing with this
          indicator. First, a block sequence need not be indented relative to
          its parent node, unless that node is a block sequence entry. For
          example:
        </para>

        <example>
<programlisting>
a key in a mapping at indentation level 0:
# The value for this key is a block sequence.
- This sequence is also at indentation level 0.
-   Another entry in the sequence.
- # The value of this entry is a nested sequence.
 - This nested sequence must be
  indented at least to level 1.
 - Another entry in the nested sequence.
- Last entry in block sequence at indentation level 0.
second key in mapping: at indentation level 0.
</programlisting>
        </example>

        <example>
          <title>Test test</title>
          <simplelist type="horiz" columns="2">
            <member>
<screen>
Example YAML TODO
</screen>
            </member>
            <member>
<screen>
What it means
</screen>
            </member>
          </simplelist>
        </example>

        <para>
          In addition, in the special case when the value of a sequence entry
          is a block collection, and neither the nested block collection nor
          its first entry have any properties specified (tag or anchor), then
          this first entry may be specified in the same line as the
          <quote><userinput>-</userinput></quote> indicator of the containing
          sequence entry. In this case both the
          <quote><userinput>-</userinput></quote> and any following spaces are
          counted as part of the indentation. For example:
        </para>

        <example>
<programlisting>
- This sequence is not indented.
-   inline-map: further indented by four.
    this key: is also further indented by four.
-  - inline-seq; further indented by three.
   -    second entry in nested sequence.
- Last entry in top sequence.
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-space-comment" />Throwaway comments</title>

        <para>
          Throwaway comments have no effect whatsoever on the data serialized
          in the stream. Their usual purpose is to communicate between the
          human maintainers of the file. A typical example is comments in a
          configuration file.
        </para>

        <para>
          A throwaway comment is marked by a <link
          linkend="c-throwaway"><quote><userinput>#</userinput></quote></link>
          indicator and always spans to the end of a line. Comments can be
          indented  on their own line, or may, in some cases, follow other
          syntax elements with leading spaces.
        </para>

        <para>
          Outside text content, empty lines or lines containing only white
          space are taken to be implicit throwaway comment lines. Lines
          containing indentation followed by
          <quote><userinput>#</userinput></quote> and comment characters are
          taken to be explicit throwaway comment lines.
        </para>

        <para>
          A throwaway comment may appear before a document's top level node or
          following any node. It may not appear inside a scalar node,  but may
          precede or follow it.
        </para>

        <productionset>
          <production id="c-nb-throwaway-comment">
            <lhs>c-nb-throwaway-comment</lhs>
            <rhs>
              <lineannotation>Comment trailing a line.</lineannotation>
              <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal> <nonterminal def="#nb-char" />*
            </rhs>
          </production>

          <production id="l-comment(n)">
            <lhs>l-comment(n)</lhs>
            <rhs>
              <lineannotation>Types of comment lines.</lineannotation>
                &nbsp;&nbsp;<nonterminal def="#l-empty-comment(n)" /><sbr />
                | <nonterminal def="#l-text-comment(n)" />
            </rhs>
          </production>

          <production id="l-empty-comment(n)">
            <lhs>l-empty-comment(n)</lhs>
            <rhs>
              <lineannotation>Empty throwaway comment line.</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal> <nonterminal def="#b-any" />
            </rhs>
          </production>

          <production id="l-text-comment(n)">
            <lhs>l-text-comment(n)</lhs>
            <rhs>
              <lineannotation>Explicit throwaway comment line.</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&lt;n)</nonterminal><sbr />
              <nonterminal def="#c-nb-throwaway-comment" /><sbr />
              <nonterminal def="#b-any" />
            </rhs>
          </production>

          <production id="s-b-trailing-comment">
            <lhs>s-b-trailing-comment</lhs>
            <rhs>
              <lineannotation>Trailing non-content spaces, comment and line
              break.</lineannotation>
              ( <nonterminal def="#s-char" />+<sbr />
              &nbsp;&nbsp;<nonterminal def="#c-nb-throwaway-comment" />? )?<sbr />
              <nonterminal def="#b-any" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
###The first tree lines of this stream

## are comments (the second one is empty).
this: |   # Comments may trail block indicators.
    contains three lines of text.
    The third one starts with a
    # character. This isn't a comment.

# The last three lines of this stream
# are comments (the first line is empty).
</programlisting>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-stream" />YAML Stream</title>

      <para>
        A sequence of bytes is a YAML stream if, taken as a whole, it complies
        with the following production. Note that an empty stream is a valid
        YAML stream containing no documents.
      </para>

      <para>
        <link linkend="syntax-char-encode">Encoding</link> is assumed to be
        UTF-8 unless explicitly specified by including a byte order mark as the
        first character of the stream. While a byte order mark may also appear
        before additional document headers, the same encoding must be used for
        all documents contained in a YAML stream.
      </para>

      <productionset>
        <production id="c-l-yaml-stream">
          <lhs>c-l-yaml-stream</lhs>
          <rhs>
            <lineannotation>YAML document stream.</lineannotation>
            ( <nonterminal def="#c-l-before-document" /><sbr />
            &nbsp;&nbsp;<nonterminal def="#l-l-implicit-document" /><sbr />
            &nbsp;&nbsp;<nonterminal def="#l-l-after-document" />? )?<sbr />
            ( <nonterminal def="#c-l-before-document" /><sbr />
            &nbsp;&nbsp;<nonterminal def="#l-l-explicit-document" /><sbr />
            &nbsp;&nbsp;<nonterminal def="#l-l-after-document" />? )*
          </rhs>
        </production>

        <production id="c-l-before-document">
          <lhs>c-l-before-document</lhs>
          <rhs>
            <lineannotation>Comments before actual document
            starts.</lineannotation>
            <nonterminal def="#c-byte-order-mark" />?<sbr />
            <nonterminal def="#l-comment(n)">#l-comment(any)</nonterminal>*
          </rhs>
        </production>

        <production id="l-l-implicit-document">
          <lhs>l-l-implicit-document</lhs>
          <rhs>
            <lineannotation>First document with an implicit header
            line.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#l-l-collect-blk-value(n)">l-l-collect-blk-value(any)</nonterminal><sbr />
            | <nonterminal def="#l-l-collect-top-flow-node(n)">l-l-collect-top-flow-node(any)</nonterminal>
          </rhs>
        </production>

        <production id="l-l-explicit-document">
          <lhs>l-l-explicit-document</lhs>
          <rhs>
            <lineannotation>Stream document with an explicit
            header.</lineannotation>
            <nonterminal def="#ns-ns-document-header" /><sbr />
            ( <nonterminal def="#s-l-scalar-top-node(n)">s-l-scalar-top-node(any)</nonterminal><sbr />
            | <nonterminal def="#s-l-collect-top-node(n)">s-l-collect-top-node(any)</nonterminal> )
          </rhs>
        </production>
      </productionset>

      <sect2>
        <title><anchor id="syntax-stream-doc" />Document</title>

        <para>
          A YAML stream may contain several independent YAML documents. A
          document header line may be used to start a document and must be used
          to separate documents within a stream. This line must start with a
          document separator: <link linkend="ns-ns-document-start"
          ><quote><userinput>---</userinput></quote></link> followed by a line
          break or a sequence of space characters. If no explicit header line
          is specified at the start of the stream, the processor should behave
          as if a header line containing an unadorned
          <quote><userinput>---</userinput></quote> was specified.
        </para>

        <para>
          When YAML is used as the format for a communication stream, it is
          useful to be able to indicate the end of a document independent of
          starting the next one. Without such a marker, the YAML processor
          reading the stream would be forced to wait for the header of the next
          document (that may be long time in coming) in order to detect the end
          of the previous document.
        </para>

        <para>
          To support this scenario, a YAML document may be terminated by a
          <link linkend="ns-ns-document-end"
          ><quote><userinput>...</userinput></quote></link> line. Nothing but
          throwaway comments may appear between this line and the (mandatory)
          header line of the following document.
        </para>

        <productionset>
          <production id="ns-ns-document-header">
            <lhs>ns-ns-document-header</lhs>
            <rhs>
              <lineannotation>YAML document header.</lineannotation>
              <nonterminal def="#ns-ns-document-start" /><sbr />
              ( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-directive" /> )*
            </rhs>
          </production>

          <production id="ns-ns-document-start">
            <lhs>ns-ns-document-start</lhs>
            <rhs>
              <lineannotation>YAML document start indicator.</lineannotation>
                <quote>-</quote> <quote>-</quote> <quote>-</quote>
            </rhs>
          </production>

          <production id="l-l-after-document">
            <lhs>l-l-after-document</lhs>
            <rhs>
              <lineannotation>YAML document trailer.</lineannotation>
              <nonterminal def="#ns-ns-document-end" /> <nonterminal def="#b-any" /><sbr />
              <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*
            </rhs>
          </production>

          <production id="ns-ns-document-end">
            <lhs>ns-ns-document-end</lhs>
            <rhs>
              <lineannotation>YAML document end indicator.</lineannotation>
              <quote>.</quote> <quote>.</quote> <quote>.</quote>
            </rhs>
          </production>
        </productionset>

        <para>
          Since <quote><userinput>---</userinput></quote> and
          <quote><userinput>...</userinput></quote> indicate document
          boundaries, it is not allowed to use them as content lines unless
          they are indented.
        </para>

        <productionset>
          <production id="l-forbidden-non-indented">
            <lhs>l-forbidden-non-indented</lhs>
            <rhs>
              <lineannotation>Forbidden non-indented content
              line.</lineannotation>
                &nbsp;&nbsp;( <nonterminal def="#ns-ns-document-start" /><sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-char" /> <nonterminal def="#nb-char" />* )<sbr />
                | <nonterminal def="#ns-ns-document-end" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
--- &gt;
This YAML stream contains a single text value.
The next stream is a log file - a sequence of
log entries. Adding an entry to the log is a
simple matter of appending it at the end.
</programlisting>
        </example>

        <example>
<programlisting>
---
at: 2001-08-12 09:25:00.00 Z
type: GET
HTTP: '1.0'
url: '/index.html'
---
at: 2001-08-12 09:25:10.00 Z
type: GET
HTTP: '1.0'
url: '/toc.html'
</programlisting>
        </example>

        <example>
<programlisting>
# This stream is an example of a top-level mapping.
invoice : 34843
date    : 2001-01-23
total   : 4443.52
</programlisting>
        </example>

        <example>
<programlisting>
# A one-line alternative syntax for the above document.
{ invoice: 34843, date: 2001-01-23, total: 4443.52 }
</programlisting>
        </example>

        <example>
<programlisting>
# The following is a stream of three documents. TODO
# The first is an empty mapping, the second an
# empty sequence, and the last an empty string.
--- {}
--- [ ]
--- ''
</programlisting>
        </example>

        <example>
<programlisting>
# A communication channel based on a YAML stream.
---
sent at: 2002-06-06 11:46:25.10 Z
payload: Whatever
# Receiver can process this as soon as the following is sent:
...
# Even if the next message is sent long after:
---
sent at: 2002-06-06 12:05:53.47 Z
payload: Whatever
...
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-stream-directive" />Directive</title>

        <para>
          Directives are instructions to the YAML processor. Like <link
          linkend="syntax-space-comment">throwaway comments</link>, directives
          are not reflected in the data serialized in the stream. Directives
          apply to a single document. It is an error for the same directive to
          be specified more than once for the same document.
        </para>

        <productionset>
          <production id="c-ns-directive">
            <lhs>c-ns-directive</lhs>
            <rhs>
              <lineannotation>Document directive.</lineannotation>
              <nonterminal def="#c-directive"><quote>%</quote></nonterminal> <nonterminal def="#ns-ns-directive-name" /><sbr />
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal> <nonterminal def="#ns-ns-directive-value" />
            </rhs>
          </production>

          <production id="ns-ns-directive-name">
            <lhs>ns-ns-directive-name</lhs>
            <rhs>
              <lineannotation>Document directive name.</lineannotation>
              ( <nonterminal def="#ns-char" /> - <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal> )+
            </rhs>
          </production>

          <production id="ns-ns-directive-value">
            <lhs>ns-ns-directive-value</lhs>
            <rhs>
              <lineannotation>Document directive value.</lineannotation>
              <nonterminal def="#ns-char" />+
            </rhs>
          </production>
        </productionset>

        <para>
          This version of YAML defines a single directive,
          <quote><userinput>%YAML</userinput></quote>. Additional directives
          may be added in future versions of YAML. A processor should ignore
          unknown directives with an appropriate warning. There is no provision
          for specifying private directives. This is intentional.
        </para>

        <para>
          The <quote><userinput>%YAML</userinput></quote> directive specifies
          the version of YAML the document adheres to. This specification
          defines version <userinput>1.0</userinput>.
        </para>

        <para>
          A version 1.0 processor should accept documents with an explicit
          <quote><userinput>%YAML:1.0</userinput></quote> directive, as well as
          documents lacking a <quote><userinput>%YAML</userinput></quote>
          directive. Documents with a directive specifying a higher minor
          version (e.g. <quote><userinput>%YAML:1.1</userinput></quote>) should
          be processed with an appropriate warning. Documents with a directive
          specifying a higher major version (e.g.
          <quote><userinput>%YAML:2.0</userinput></quote>) should be rejected
          with an appropriate error message.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="syntax-stream-text" />Text Node</title>

        <para>
          A text node begins at a particular level of indentation,
          <varname>n</varname>, and its content is indented at some level
          &gt;&nbsp;<varname>n</varname>. A text node can be a <link
          linkend="syntax-collect">collection</link>, a <link
          linkend="syntax-scalar">scalar</link> or an <link
          linkend="syntax-alias">alias</link>.
        </para>

        <para>
          A YAML document is a normal node. However a document can't be an
          alias (there is nothing it may refer to). Also if the header line is
          omitted the first document must be a collection.
        </para>

        <productionset>
          <production id="s-l-top-node(n)">
            <lhs>s-l-top-node(n)</lhs>
            <rhs>
              <lineannotation>Node outside flow
              collection.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#s-l-alias-top-node" /><sbr />
              | <nonterminal def="#s-l-collect-top-node(n)">s-l-collect-top-node(n)</nonterminal><sbr />
              | <nonterminal def="#s-l-scalar-top-node(n)" />
            </rhs>
          </production>

          <production id="ns-ns-flow-value-node(n)">
            <lhs>ns-ns-flow-value-node(n)</lhs>
            <rhs>
              <lineannotation>Value node inside flow
              collection.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-alias-flow-node" /><sbr />
              | <nonterminal def="#c-c-collect-flow-node(n)" /><sbr />
              | <nonterminal def="#ns-ns-scalar-flow-value-node(n)" />
            </rhs>
          </production>

          <production id="ns-ns-flow-key-node(n)">
            <lhs>ns-ns-flow-key-node(n)</lhs>
            <rhs>
              <lineannotation>Key node inside flow collection.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-alias-flow-node" /><sbr />
              | <nonterminal def="#c-c-collect-flow-node(n)" /><sbr />
              | <nonterminal def="#ns-ns-scalar-flow-key-node(n)" />
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-stream-property" />Node Property</title>

        <para>
          Each text node may have <link
          linkend="syntax-stream-anchor">anchor</link> and <link
          linkend="syntax-stream-tag">tag</link> properties. These properties
          are specified in a properties list appearing before the node value
          itself. For a root node (a document), the properties appear in the
          document header line, following the directives (if any). It is an
          error for the same property to be specified more than once for the
          same node.
        </para>

        <productionset>
          <production id="c-ns-properties">
            <lhs>c-ns-properties</lhs>
            <rhs>
              <lineannotation>Properties list.</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#c-ns-tag-property" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-anchor-property" /> )? )<sbr />
              | ( <nonterminal def="#c-ns-anchor-property" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-tag-property" /> )? )
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-stream-tag" />Tag</title>

        <para>
          The tag property provides a mechanism for serializing type
          information within a YAML stream. Tags are considered to  be part of
          the serialized information, in contrast with <link
          linkend="syntax-space-comment">throwaway comments</link> and <link
          linkend="syntax-stream-directive">directives</link> which are
          considered to be syntactical details.
        </para>

        <sect3>
          <title><anchor id="syntax-stream-tag-default" />Tag Defaulting</title>

          <para>
            To enhance readability, this property is optional in  the common
            cases where mapping, sequence or string typing is desired. When the
            tag property is omitted:  <link
            linkend="syntax-collect-map">mappings</link> must be treated as if
            a <link linkend="type-map"
            ><quote><userinput>!map</userinput></quote></link> tag had been
            provided, <link linkend="syntax-collect-seq">sequences</link> must
            be treated as if a <link linkend="type-seq"
            ><quote><userinput>!seq</userinput></quote></link> tag had been
            provided, and, excepting the case below, <link
            linkend="syntax-scalar">scalars</link> must be treated  as if a
            <link
            linkend="type-str"><quote><userinput>!str</userinput></quote></link>
            tag had been provided.
          </para>

          <para>
            An exception to this simple defaulting rule occurs when a scalar
            uses the <link linkend="syntax-scalar-plain">plain style</link>. In
            this case, an omitted tag shall be treated as if the empty tag,
            <quote><userinput>!</userinput></quote>, had been provided. The
            empty tag is a special case and signals <link
            linkend="type-implicit">implicit typing</link>.
          </para>

          <example>
<programlisting>
a string: '12'
another string: "12"
explicit string: !str 12
explicit integ
implicit integer: 12
also implicit integer: ! "12"
</programlisting>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-stream-tag-short" />Shorthands</title>

          <para>
            YAML makes use of the <userinput>tag:</userinput> <ulink
            url="http://www.taguri.org">URI scheme</ulink> for defining URIs
            for its global tags and the <userinput>x-private:</userinput>
            scheme for its private tags. While these schemes provide the
            necessary semantics for specifying tags, they are rather verbose.
          </para>

          <para>
            To increase readability, YAML does not use the full URI notation in
            the stream. Instead, it provides several shorthand notations for
            different groups of tags. A processor may choose not to expand
            shorthand tags to a full URI form. However, in such a case the
            processor must still perform <link
            linkend="syntax-stream-tag-escape">escaping</link> to ensure a
            single unique representation of each tag.
          </para>

          <itemizedlist>
            <listitem>
              <para>
                If the tag begins with a
                <quote><userinput>!</userinput></quote> character, it is taken
                to be a private tag whose URI belongs to the
                <userinput>x-private:</userinput> scheme.
              </para>

              <example>
<programlisting>
# Both examples below make use of the 'x-private:ball'
# tag, but with different semantics.
---
pool: !!ball { number: 8 }
---
bearing: !!ball { material: steel }
</programlisting>
              </example>
            </listitem>

            <listitem>
              <para>
                If a tag contains no <quote><userinput>:</userinput></quote>
                and no <quote><userinput>/</userinput></quote> characters it is
                assumed to belong to the <userinput>yaml.org</userinput>
                domain. This domain is used to define the core and universal
                YAML data types.
              </para>

              <example>
<programlisting>
# The URI is 'tag:yaml.org,2002:str'
- !str a Unicode string
</programlisting>
              </example>
            </listitem>

            <listitem>
              <para>
                Otherwise, if the tag begins with a single word, followed by a
                <quote><userinput>/</userinput></quote> character, it is
                assumed to belong to a sub-domain of
                <userinput>yaml.org</userinput>. Each domain
                <varname>vocabulary</varname><userinput>.yaml.org</userinput>
                will include all globally unique types of the vocabulary that
                aren't covered by the set of universal types. Each vocabulary
                would contain a set of related types, for example types
                specific to a particular programming language.
              </para>

              <para>
                Globally unique types for each language include any built-in
                types and any standard library types. For languages such as
                Java and C#, all type names based on reverse DNS strings are
                globally unique. For languages such as Perl, that has a central
                authority (<ulink url="http://www.cpan.org/">CPAN</ulink>) for
                managing the global namespace, all the types sanctioned by the
                central authority are globally unique. The list of supported
                languages and their types is maintained as part of the <link
                linkend="type-repository">YAML type repository</link>.
              </para>

              <example>
<programlisting>
# The URI is 'tag:perl.yaml.org,2002:Text::Tabs'
- !perl/Text::Tabs {}
</programlisting>
              </example>
            </listitem>

            <listitem>
              <para>
                Otherwise, the tag must begin with a domain name and a date
                (separated by a <quote><userinput>,</userinput></quote>
                character), followed by a
                <quote><userinput>/</userinput></quote> character. In this case
                it is taken to be defined under the specified domain and date.
              </para>

              <example>
<programlisting>
# The URI is 'tag:clarkevans.com,2003-02:timesheet'
- !clarkevans.com,2003-02/timesheet
</programlisting>
              </example>
            </listitem>
          </itemizedlist>

          <para>
            Tags defined in the <userinput>yaml.org</userinput> domain or any
            of its sub-domains must be expressed using the appropriate
            specialized shorthand rather than using the generic domain syntax.
            This ensures each tag has a unique representation when serialized,
            in addition to having a unique representation as a URI.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="syntax-stream-tag-frag" />Fragments</title>

          <para>
            YAML does not mandate any special relationship between different
            tags that share a common prefix. Using URI fragments is no
            exception; tags that share the same base URI but differ in their
            fragment part are considered to be different, independent tags.
          </para>

          <para>
            By convention, fragments are used to identify different
            <quote>versions</quote> of a tag, while
            <quote><userinput>/</userinput></quote> is used to define nested
            tag <quote>namespace</quote> hierarchies. However, this is merely a
            convention, and each tag may employ its own rules. For example,
            <quote><userinput>!perl</userinput></quote> tags use
            <quote><userinput>::</userinput></quote> to express namespace
            hierarchies, <quote><userinput>!java</userinput></quote> tags use
            <quote><userinput>.</userinput></quote>, etc.
          </para>

          <example>
<programlisting>
# Tags using hierarchies and versions.
- !clarkevans.com,2003-02/commerce/timesheet#1.0
- !clarkevans.com,2003-02/graphic/bezier#2.1
</programlisting>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-stream-tag-escape" />Escaping</title>

          <para>
            YAML allows non-printable Unicode characters to be used in a tag
            using <link linkend="syntax-scalar-escape">escape sequences</link>.
          </para>

          <example>
<programlisting>
# The following values have the same tag.
- !domain.tld,2002/type\x30 value
- !domain.tld,2002/type0 value
</programlisting>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-stream-tag-expand" />Expanding</title>

          <para>
            Sometimes it may be helpful for a YAML tag to be expanded to a full
            URI. A YAML processor may provide a mechanism to perform such
            expansion. Since URIs support a limited ASCII-based character set,
            this expansion requires all characters outside this set to be
            encoded in UTF-8 and the resulting bytes to be encoded using
            <quote><userinput>%</userinput></quote> notation.
          </para>

          <para>
            When an explicit <quote><userinput>%</userinput></quote> character
            appears in a tag, it is passed to the URI form unchanged, allowing
            explicit <quote><userinput>%</userinput></quote> escapes to be used
            in the tag where necessary. It is an error for a tag not to have a
            valid expanded URI format (e.g., contain an invalid explicit
            <quote><userinput>%</userinput></quote> escape sequence).
          </para>

          <example>
<programlisting>
# The following are different as far as YAML is concerned.
- !domain.tld,2002/type%30 value
- !domain.tld,2002/type0 value
</programlisting>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-stream-tag-prefix" />Prefixing</title>

          <para>
            YAML provides convenient shorthand for the common case where a node
            and (most of) its descendents have global tags whose shorthand
            forms share a common prefix. For this case, YAML allows using the
            <link linkend="c-prefix"><quote><userinput>^</userinput></quote></link>
            character to separate the ancestor node's tag into a prefix and a
            suffix. The processor does not consider the separator to be part of
            the tag.
          </para>

          <para>
            When the processor encounters a descendant node whose tag begins
            with <quote><userinput>^</userinput></quote>, it appends the
            ancestor node's prefix to it. Again the
            <quote><userinput>^</userinput></quote> character is not taken to
            be part of the tag.
          </para>

          <para>
            It is possible for a descendant node to establish a different
            prefix. In this case the node may not make use of its ancestor's
            node prefix. It must specify a full tag, separated into a prefix
            and suffix as above.
          </para>

          <para>
            It is an error for a node's tag to begin with
            <quote><userinput>^</userinput></quote> unless it has an ancestor
            node establishing a prefix. However, a node may establish a prefix
            even if none of its descendents make use of it.
          </para>

          <para>
            Note that the tag prefix mechanism is purely syntactical and does
            not imply any additional semantics. In particular, the prefix must
            not be assumed to be an identifier for anything.
          </para>

          <example>
<programlisting>
# 'tag:domain.tld,2002:invoice' is some tag.
invoice: !domain.tld,2002/^invoice
  # 'seq' is shorthand for 'tag:yaml.org,2002:seq'.
  # This does not effect '^customer' below
  # because it is does not specify a prefix.
  customers: !seq
    # '^customer' is shorthand for the full notation
    # '!domain.tld,2002/customer' that stands for the
    # URI 'tag:domain.tld,2002:customer'.
    - !^customer
      given : Chris
      family : Dumars
</programlisting>
          </example>
        </sect3>
        <productionset>
          <production id="c-prefix">
            <lhs>c-prefix</lhs>
            <rhs>
              <lineannotation>Seperate prefix from type.</lineannotation>
              <quote>^</quote>
            </rhs>
          </production>

          <production id="ns-tag-char">
            <lhs>ns-tag-char</lhs>
            <rhs>
              <lineannotation>Characters valid in a tag.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-esc-sequence" /><sbr />
              | ( <quote>%</quote> <nonterminal def="#ns-hex-digit" /> x 2 )<sbr />
              | ( <nonterminal def="#ns-char" /> - <nonterminal def="#c-escape"><quote>\</quote></nonterminal> - <nonterminal def="#c-prefix"><quote>^</quote></nonterminal> - <quote>%</quote> )
            </rhs>
          </production>

          <production id="ns-mundane-tag-char">
            <lhs>ns-mundane-tag-char</lhs>
            <rhs>
              <lineannotation>Non-magical URI character.</lineannotation>
              <nonterminal def="#ns-tag-char" /> - <quote>:</quote> - <quote>/</quote>
            </rhs>
          </production>

          <production id="c-ns-tag-property">
            <lhs>c-ns-tag-property</lhs>
            <rhs>
              <lineannotation>Collection tag.</lineannotation>
              <nonterminal def="#c-tag"><quote>!</quote></nonterminal><sbr />
              ( /* empty (implicit) */<sbr />
              | <nonterminal def="#c-ns-private-tag" /><sbr />
              | <nonterminal def="#ns-ns-global-tag" /><sbr />
              | ( Prefix-of-above?<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#c-prefix"><quote>^</quote></nonterminal><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;Suffix-of-above ) )
            </rhs>
          </production>

          <production id="c-ns-private-tag">
            <lhs>c-ns-private-tag</lhs>
            <rhs>
              <lineannotation>Private tags.</lineannotation>
              <nonterminal def="#c-tag"><quote>!</quote></nonterminal> <nonterminal def="#ns-tag-char" />+
            </rhs>
          </production>

          <production id="ns-ns-global-tag">
            <lhs>ns-ns-global-tag</lhs>
            <rhs>
              <lineannotation>Global tags.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-core-tag" /><sbr />
              | <nonterminal def="#ns-ns-vocabulary-tag" /><sbr />
              | <nonterminal def="#ns-ns-domain-tag" />
            </rhs>
          </production>

          <production id="ns-ns-core-tag">
            <lhs>ns-ns-core-tag</lhs>
            <rhs>
              <lineannotation>Shorthand for
              <userinput>tag:yaml.org,2002:</userinput><varname>type</varname>
              names.</lineannotation>
              ( <nonterminal def="#ns-mundane-tag-char" /><sbr />
              - <nonterminal def="#c-tag"><quote>!</quote></nonterminal> )<sbr />
              <nonterminal def="#ns-mundane-tag-char" />*
            </rhs>
          </production>

          <production id="ns-ns-vocabulary-tag">
            <lhs>ns-ns-vocabulary-tag</lhs>
            <rhs>
              <lineannotation>Shorthand for
              <userinput>tag:vocabulary.yaml.org,2002:</userinput><varname>type</varname>
              names.</lineannotation>
              <nonterminal def="#ns-word-char" />+ <quote>/</quote> <nonterminal def="#ns-tag-char" />*
            </rhs>
          </production>

          <production id="ns-ns-domain-tag">
            <lhs>ns-ns-domain-tag</lhs>
            <rhs>
              <lineannotation>Shorthand for
              <userinput>tag:domain,date:</userinput><varname>type</varname>
              names.</lineannotation>
              <nonterminal def="#ns-word-char" />+<sbr />
              ( <quote>.</quote> <nonterminal def="#ns-word-char" />+ )<sbr />
              <quote>,</quote> <nonterminal def="#ns-ns-domain-year" /><sbr />
              ( <quote>-</quote> <nonterminal def="#ns-ns-domain-day-month" /><sbr />
              &nbsp;&nbsp;( <quote>-</quote> <nonterminal def="#ns-ns-domain-day-month" /> )? )?<sbr />
              <quote>/</quote> <nonterminal def="#ns-tag-char" />*
            </rhs>
          </production>

          <production id="ns-ns-domain-year">
            <lhs>ns-ns-domain-year</lhs>
            <rhs>
              <lineannotation>Tag domain ownership year.</lineannotation>
              <nonterminal def="#ns-decimal-digit" /> x 4
            </rhs>
          </production>

          <production id="ns-ns-domain-day-month">
            <lhs>ns-ns-domain-day-month</lhs>
            <rhs>
              <lineannotation>Tag domain ownership day or month (01 by
              default).</lineannotation>
              <nonterminal def="#ns-decimal-digit" /> x 2
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-stream-anchor" />Anchor</title>
        <para>
          An anchor is a property that can be used to mark a node for future
          reference. An <link linkend="syntax-alias">alias node</link> can then
          be used to indicate additional inclusions of an anchored node by
          specifying the node's anchor.
        </para>

        <productionset>
          <production id="c-ns-anchor-property">
            <lhs>c-ns-anchor-property</lhs>
            <rhs>
              <lineannotation>Associates an anchor with a given
              node.</lineannotation>
              <nonterminal def="#c-anchor"><quote>&amp;</quote></nonterminal> <nonterminal def="#ns-ns-anchor-name" />
            </rhs>
          </production>

          <production id="ns-ns-anchor-name">
            <lhs>ns-ns-anchor-name</lhs>
            <rhs>
              <lineannotation>Unique anchor name.</lineannotation>
              <nonterminal def="#ns-char" />+
            </rhs>
          </production>
        </productionset>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-alias" />Alias</title>

      <para>
        An alias node is a place holder for subsequent occurrences of a
        previously serialized node. The first occurence of the node must be
        marked by an <link linkend="syntax-stream-anchor">anchor</link> to allow
        additional occurences to be represented as alias nodes.
      </para>

      <para>
        An alias refers to the most recent <link
        linkend="model-serial-order">preceding</link> node having the same
        anchor. It is an error to have an alias use an anchor that does not
        occur previously in the serialization of the documeht. It is not an
        error to have an anchor that is not used by any alias node.
      </para>

      <productionset>
        <production id="s-l-alias-top-node">
          <lhs>s-l-alias-top-node</lhs>
          <rhs>
            <lineannotation>Alias node outside flow
            collection.</lineannotation>
            <nonterminal def="#s-char" /> <nonterminal def="#ns-ns-alias-flow-node" /><sbr />
            <nonterminal def="#s-b-trailing-comment" /><sbr />
            <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*
          </rhs>
        </production>

        <production id="ns-ns-alias-flow-node">
          <lhs>ns-ns-alias-flow-node</lhs>
          <rhs>
            <lineannotation>Alias node inside flow collection.</lineannotation>
            <nonterminal def="#c-alias"><quote>*</quote></nonterminal> <nonterminal def="#ns-ns-anchor-name" />
          </rhs>
        </production>
      </productionset>

      <example>
<programlisting>
anchor : &amp;A001 This scalar has an anchor.
override : &amp;A001 The alias node below is a repeated use of this value.
alias : *A001
</programlisting>
      </example>
    </sect1>

    <sect1>
      <title><anchor id="syntax-collect" />Collection</title>

      <para>
        Collection nodes come in two kinds, <link
        linkend="syntax-collect-seq">sequence</link> and <link
        linkend="syntax-collect-map">mapping</link>. Each kind has two styles,
        block and flow. Block styles begin on the next line and use indentation
        for internal structure. Flow collection styles start on the current
        line, may span multiple lines, and rely on indicators to represent
        internal structure.
      </para>

      <productionset>
        <production id="s-l-collect-top-node(n)">
          <lhs>s-l-collect-top-node(n)</lhs>
          <rhs>
            <lineannotation>Collection node outside flow
            collection.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#s-l-collect-blk-node(n)" /><sbr />
            | ( <nonterminal def="#s-s-required(n)" /><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#c-c-collect-flow-node(n)" /><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-b-trailing-comment">s-b-trailing-comment</nonterminal><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>* )
          </rhs>
        </production>

        <production id="l-l-collect-top-flow-node(n)">
          <lhs>l-l-collect-top-flow-node(n)</lhs>
          <rhs>
            <lineannotation>Top-level (document) flow collection
            node.</lineannotation>
            <nonterminal def="#i-spaces(n)" /><sbr />
            <nonterminal def="#c-c-collect-flow-node(n)" /><sbr />
            <nonterminal def="#s-b-trailing-comment" /><sbr />
            <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*
          </rhs>
        </production>

        <production id="c-c-collect-flow-node(n)">
          <lhs>c-c-collect-flow-node(n)</lhs>
          <rhs>
            <lineannotation>Collection node in flow style.</lineannotation>
            ( <nonterminal def="#c-ns-properties" /> <nonterminal def="#s-char" />+ )?<sbr />
            <nonterminal def="#c-c-collect-flow-value(n)" />
          </rhs>
        </production>

        <production id="s-l-collect-blk-node(n)">
          <lhs>s-l-collect-blk-node(n)</lhs>
          <rhs>
            <lineannotation>Collection node in block style.</lineannotation>
            ( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-properties" /> )?<sbr />
            <nonterminal def="#s-b-trailing-comment" /><sbr />
            <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*<sbr />
            <nonterminal def="#l-l-collect-blk-value(n)" />
          </rhs>
        </production>

        <production id="l-l-collect-blk-value(n)">
          <lhs>l-l-collect-blk-value(n)</lhs>
          <rhs>
            <lineannotation>Collection value in block style.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#l-l-blk-seq-value(n)" /><sbr />
            | <nonterminal def="#l-l-blk-map-value(n)" />
          </rhs>
        </production>

        <production id="c-c-collect-flow-value(n)">
          <lhs>c-c-collect-flow-value(n)</lhs>
          <rhs>
            <lineannotation>Collection value in flow style.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-c-flow-seq-value(n)" /><sbr />
            | <nonterminal def="#c-c-flow-map-value(n)" />
          </rhs>
        </production>
      </productionset>

      <para>
        To enable line spanning in flow collections, wherever tokens may be
        separated by white space it is possible to end the line (with an
        optional throwaway comment) and continue the collection in the next
        line. Line spanning functionality is indicated by the use of the <link
        linkend="s-s-optional(n)"><userinput>s-s-optional(n)</userinput></link>
        space and the <link
        linkend="s-s-required(n)"><userinput>s-s-required(n)</userinput></link>
        space productions.
      </para>

      <productionset>
        <production id="s-s-optional(n)">
          <lhs>s-s-optional(n)</lhs>
          <rhs>
            <lineannotation>Optional white space separating
            tokens.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#s-char" />*<sbr />
            | ( <nonterminal def="#s-b-trailing-comment" /><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-spaces(n)" /> <nonterminal def="#s-char" />+ )
          </rhs>
        </production>

        <production id="s-s-required(n)">
          <lhs>s-s-required(n)</lhs>
          <rhs>
            <lineannotation>Required white space separating
            tokens.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#s-char" />+<sbr />
            | ( <nonterminal def="#s-b-trailing-comment" /><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-spaces(n)" /> <nonterminal def="#s-char" />+ )
          </rhs>
        </production>
      </productionset>

      <sect2>
        <title><anchor id="syntax-collect-seq" />Sequence</title>
        <para>
          A sequence node is an ordered collection of sub-nodes, where each
          subordinate node has a higher indentation level. A flow  style is
          available for short, simple sequences. For syntax compactness, if a
          sub-sequence node has no properties, and its  first entry is
          specified without any properties, the sub-sequence may immediately
          follow the sequence entry indicator.
        </para>

        <productionset>
          <production id="l-l-blk-seq-value(n)">
            <lhs>l-l-blk-seq-value(n)</lhs>
            <rhs>
              <lineannotation>Sequence value in block style;
              <userinput>-1</userinput> unless the block sequence is the value
              of an entry of a parent block sequence.</lineannotation>
              ( <nonterminal def="#i-spaces(n)">i-spaces(n-1)</nonterminal><sbr />
              &nbsp;&nbsp;<nonterminal def="#c-l-blk-seq-entry(n)">c-l-blk-seq-entry(n-1)</nonterminal> )+
            </rhs>
          </production>

          <production id="c-l-blk-seq-entry(n)">
            <lhs>c-l-blk-seq-entry(n)</lhs>
            <rhs>
              <lineannotation>Block sequence node entry.</lineannotation>
              <nonterminal def="#c-sequence-entry"><quote>-</quote></nonterminal>
              <nonterminal def="#s-l-inline-node(n)" /><sbr />
            </rhs>
          </production>

          <production id="s-l-inline-node(n)">
            <lhs>s-l-inline-node(n)</lhs>
            <rhs>
              <lineannotation>Top node or a shorthand inline
              collection.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#s-l-top-node(n)">s-l-top-node(&gt;n)</nonterminal><sbr />
              | <nonterminal def="#i-l-inline-seq(n)" /><sbr />
              | <nonterminal def="#i-l-inline-map(n)" />
            </rhs>
          </production>

          <production id="i-l-inline-seq(n)">
            <lhs>i-l-inline-seq(n)</lhs>
            <rhs>
              <lineannotation>Inline sequence node with no properties
              (where <varname>m</varname>&nbsp;&gt;&nbsp;0).</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(m)</nonterminal><sbr />
              <nonterminal def="#c-l-blk-seq-entry(n)">c-l-blk-seq-entry(n+m+1)</nonterminal><sbr />
              <nonterminal def="#l-l-blk-seq-value(n)">l-l-blk-seq-value(n+m+1)</nonterminal>?
            </rhs>
          </production>

          <production id="c-c-flow-seq-value(n)">
            <lhs>c-c-flow-seq-value(n)</lhs>
            <rhs>
              <lineannotation>Sequence value in flow style.</lineannotation>
              <nonterminal def="#c-sequence-start"><quote>[</quote></nonterminal><sbr />
              <nonterminal def="#s-s-optional(n)" /><sbr />
              ( <nonterminal def="#ns-ns-flow-value-node(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#s-s-optional(n)" /><sbr />
              &nbsp;&nbsp;( <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal>
              <nonterminal def="#s-s-required(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-ns-flow-value-node(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-s-optional(n)" /> )* )?<sbr />
              <nonterminal def="#c-sequence-end"><quote>]</quote></nonterminal>
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: []
flow: [ one, two, three # May span lines,
         , four,        # indentation is
           five ]       # mostly ignored.
block:
- Note indicator is not indented.
-
 - Subordinate sequence entry (note must be indented).
 - Another entry in subordinate sequence
- - Another way to write a sub-sequence
  - Another entry in sub-sequence
- &gt;
 A folded sequence entry (fifth entry)
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-collect-map" />Mapping</title>

        <para>
          A mapping node is an unordered association of unique keys with
          values. It is an error for two <link
          linkend="model-native-equiv-equality">equal</link> key entries to
          appear in the same mapping node. In such a case the processor may
          continue, ignoring the second key and issuing an appropriate warning.
          This strategy preserves a consistent information model for streaming
          and random access applications.
        </para>

        <para>
          A flow form is available for short, simple mapping nodes. For syntax
          compactness, if a mapping node has no properties, and its  first key
          is specified as a flow scalar without any properties,  this first key
          may immediately follow the sequence entry indicator.
        </para>

        <productionset>
          <production id="l-l-blk-map-value(n)">
            <lhs>l-l-blk-map-value(n)</lhs>
            <rhs>
              <lineannotation>Mapping value in block style.</lineannotation>
              ( <nonterminal def="#i-spaces(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#ns-l-blk-map-entry(n)" /> )+
            </rhs>
          </production>

          <production id="i-l-inline-map(n)">
            <lhs>i-l-inline-map(n)</lhs>
            <rhs>
              <lineannotation>Inline mapping node with no properties
              (where <varname>m</varname>&nbsp;&gt;&nbsp;0).</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(m)</nonterminal><sbr />
              <nonterminal def="#ns-ns-scalar-key-value(n)">ns-ns-scalar-key-value(n&#43;m&#43;1)</nonterminal><sbr />
              <nonterminal def="#s-char" />*
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal><sbr />
              <nonterminal def="#s-l-top-node(n)">s-l-top-node(&gt;n&#43;m&#43;1)</nonterminal><sbr />
              <nonterminal def="#l-l-blk-map-value(n)">l-l-blk-map-value(n&#43;m&#43;1)</nonterminal>?
            </rhs>
          </production>

          <production id="ns-l-blk-map-entry(n)">
            <lhs>ns-l-blk-map-entry(n)</lhs>
            <rhs>
              <lineannotation>Block key:value pair.</lineannotation>
              <nonterminal def="#ns-l-simple-map-entry(n)" /><sbr />
              <nonterminal def="#ns-l-complex-map-entry(n)" />
            </rhs>
          </production>

          <production id="ns-l-simple-map-entry(n)">
            <lhs>ns-l-simple-map-entry(n)</lhs>
            <rhs>
              <lineannotation>Simple key:value pair.</lineannotation>
              <nonterminal def="#ns-ns-flow-key-node(n)" />
              <nonterminal def="#s-char" />*
              <sbr />
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              <nonterminal def="#s-l-top-node(n)">s-l-top-node(&gt;n)</nonterminal>
            </rhs>
          </production>

          <production id="ns-l-complex-map-entry(n)">
            <lhs>ns-l-complex-map-entry(n)</lhs>
            <rhs>
              <lineannotation>Complex key:value pair.</lineannotation>
              <nonterminal def="#c-top-key"><quote>?</quote></nonterminal>
              <nonterminal def="#s-l-inline-node(n)" /><sbr />
              ( <nonterminal def="#i-spaces(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              <nonterminal def="#s-l-inline-node(n)" /> )?
            </rhs>
          </production>

          <production id="c-c-flow-map-value(n)">
            <lhs>c-c-flow-map-value(n)</lhs>
            <rhs>
              <lineannotation>Mapping value in flow style.</lineannotation>
              <nonterminal def="#c-mapping-start"><quote>{</quote></nonterminal><sbr />
              <nonterminal def="#s-s-optional(n)" /><sbr />
              ( <nonterminal def="#ns-ns-flow-map-entry(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#s-s-optional(n)" /><sbr />
              &nbsp;&nbsp;( <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal>
              <nonterminal def="#s-s-required(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-ns-flow-map-entry(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-s-optional(n)" /> )* )?<sbr />
              <nonterminal def="#c-mapping-end"><quote>}</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-ns-flow-map-entry(n)">
            <lhs>ns-ns-flow-map-entry(n)</lhs>
            <rhs>
              <lineannotation>Flow key:value pair.</lineannotation>
              <nonterminal def="#ns-ns-flow-key-node(n)" /><sbr />
              <nonterminal def="#s-char" />*
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal><sbr />
              <nonterminal def="#s-s-required(n)" /><sbr />
              <nonterminal def="#ns-ns-flow-value-node(n)" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: {}
flow: { one: 1, two: 2 }
spanning: { one: 1,
   two: 2 }
block:
 key : value
 nested mapping:
  key: Subordinate mapping
 nested sequence:
  - Subordinate sequence
!float 12 : This key is a float.
"\a" : This key had to be escaped.
? '?'
: This key had to be quoted.
? &gt;
 This is a multi
 line folded key
: Whose value is
  also multi-line.
? This key has implicit null value
?
 - This key
 - is a sequence
: - With a sequence value.
? This: key
  is a: mapping
:
 with a: mapping value.
---
- A key: value pair in a sequence.
  A second: key:value pair.
- The previous entry is equal to the following one.
-
 A key:
     value pair in a sequence.
 A second:
     key:value pair.
</programlisting>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-scalar" />Scalar</title>

      <para>
        While most of the document productions are fairly strict, the scalar
        production is generous. It offers three flow style variants and two
        block style variants to choose from, depending upon the readability
        requirements.
      </para>

      <para>
        Additionally, <link linkend="syntax-space-comment">Throwaway
        comments</link> may follow a scalar  node, but may not appear inside
        one. The comment lines following a  block scalar node must be less
        indented than the block scalar value. Empty lines in a scalar node
        that are followed by a non-empty content  line are interpreted as
        content rather than as implicit comments. Such lines may be less
        indented than the text content.
      </para>

      <productionset>
        <production id="s-l-scalar-top-node(n)">
          <lhs>s-l-scalar-top-node(n)</lhs>
          <rhs>
            <lineannotation>Scalar node outside flow
            collection.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#s-l-scalar-top-blk-node(n)" /><sbr />
            | <nonterminal def="#s-l-scalar-top-flow-node(n)" />
          </rhs>
        </production>

        <production id="s-l-scalar-top-blk-node(n)">
          <lhs>s-l-scalar-top-blk-node(n)</lhs>
          <rhs>
            <lineannotation>Scalar node outside flow collection, in block
            style.</lineannotation>
            ( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-properties" /> )?<sbr />
            <nonterminal def="#s-char" />+ <nonterminal def="#c-l-scalar-blk-value(n)" />
          </rhs>
        </production>

        <production id="s-l-scalar-top-flow-node(n)">
          <lhs>s-l-scalar-top-flow-node(n)</lhs>
          <rhs>
            <lineannotation>Scalar node outside flow collection, in flow
            style.</lineannotation>
            <nonterminal def="#s-s-required(n)" /><sbr />
            ( <nonterminal def="#c-ns-properties" /> <nonterminal def="#s-char" />+ )?<sbr />
            <nonterminal def="#ns-ns-scalar-top-value(n)" /><sbr />
            <nonterminal def="#s-b-trailing-comment" /><sbr />
            <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*
          </rhs>
        </production>

        <production id="ns-ns-scalar-flow-value-node(n)">
          <lhs>ns-ns-scalar-flow-value-node(n)</lhs>
          <rhs>
            <lineannotation>Scalar node inside flow collection, used as
            value.</lineannotation>
            ( <nonterminal def="#c-ns-properties" /> <nonterminal def="#s-char" />+ )?<sbr />
            <nonterminal def="#ns-ns-scalar-flow-value(n)" />
          </rhs>
        </production>

        <production id="ns-ns-scalar-flow-key-node(n)">
          <lhs>ns-ns-scalar-flow-key-node(n)</lhs>
          <rhs>
            <lineannotation>Scalar node inside flow collection, used as
            key.</lineannotation>
            ( <nonterminal def="#c-ns-properties" /> <nonterminal def="#s-char" />+ )?<sbr />
            <nonterminal def="#ns-ns-scalar-key-value(n)" />
          </rhs>
        </production>

        <production id="c-l-scalar-blk-value(n)">
          <lhs>c-l-scalar-blk-value(n)</lhs>
          <rhs>
            <lineannotation>Scalar value in block style.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-l-literal(n)" /><sbr />
            | <nonterminal def="#c-l-folded(n)" />
          </rhs>
        </production>

        <production id="ns-ns-scalar-flow-value(n)">
          <lhs>ns-ns-scalar-flow-value(n)</lhs>
          <rhs>
            <lineannotation>Scalar value in flow style, used as value, inside
            flow collection.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-c-single-quoted(n)" /><sbr />
            | <nonterminal def="#c-c-double-quoted(n)" /><sbr />
            | <nonterminal def="#ns-ns-plain-flow(n)" />
          </rhs>
        </production>

        <production id="ns-ns-scalar-top-value(n)">
          <lhs>ns-ns-scalar-top-value(n)</lhs>
          <rhs>
            <lineannotation>Scalar value in flow style, used as value, outside
            flow collection.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-c-single-quoted(n)" /><sbr />
            | <nonterminal def="#c-c-double-quoted(n)" /><sbr />
            | <nonterminal def="#ns-ns-plain-top(n)" />
          </rhs>
        </production>

        <production id="ns-ns-scalar-key-value(n)">
          <lhs>ns-ns-scalar-key-value(n)</lhs>
          <rhs>
            <lineannotation>Scalar value in flow style, used as
            key.</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-c-single-quoted(n)" /><sbr />
            | <nonterminal def="#c-c-double-quoted(n)" /><sbr />
            | <nonterminal def="#ns-ns-plain-key" />
          </rhs>
        </production>
      </productionset>

      <sect2>
        <title>
          <anchor id="syntax-scalar-norm" />
          End Of line Normalization
        </title>

        <para>
          Inside all scalar nodes, a compliant YAML processor must translate
          the two-character combination <link
          linkend="b-carriage-return">CR</link> <link
          linkend="b-line-feed">LF</link>, any <link
          linkend="b-carriage-return">CR</link> that is not followed by an
          <link linkend="b-line-feed">LF</link>, and any <link
          linkend="b-next-line">NEL</link> into a single <link
          linkend="b-line-feed">LF</link> (this does not apply to <link
          linkend="syntax-scalar-escape">escaped characters</link>). <link
          linkend="b-line-separator">LS</link> and <link
          linkend="b-paragraph-separator">PS</link> characters are preserved.
          These rules are compatible with Unicode's <ulink
          url="http://www.unicode.org/unicode/reports/tr13/">newline
          guidelines</ulink>.
        </para>

        <para>
          Normalization functionality is indicated by the use of the <link
          linkend="b-as-line-feed"><userinput>b-as-line-feed</userinput></link>
          production defined below.
        </para>

        <productionset>
          <production id="b-as-line-feed">
            <lhs>b-as-line-feed</lhs>
            <rhs>
              <lineannotation>Line break converted to a line
              feed.</lineannotation>
              <nonterminal def="#b-generic" />
            </rhs>
          </production>

          <production id="b-normalized">
            <lhs>b-normalized</lhs>
            <rhs>
              <lineannotation>A normalized end of line marker.</lineannotation>
              <nonterminal def="#b-as-line-feed" /> | <nonterminal def="#b-specific" />
            </rhs>
          </production>
        </productionset>

        <para>
          On output, a YAML processor is free to serialize end of line markers
          using whatever convention is most appropriate, though again <link
          linkend="b-line-separator">LS</link> and <link
          linkend="b-paragraph-separator">PS</link> must be preserved.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-mod" />Block Modifiers</title>
        <para>
          Each block scalar may have <link
          linkend="syntax-scalar-indent">explicit indentation</link> and
          <link linkend="syntax-scalar-chomp">chomping</link> modifiers.
          These modifiers are specified following the block style indicator.
          It is an error for the same modifier to be specified more than
          once for the same node.
        </para>

        <productionset>
          <production id="ns-ns-blk-modifiers">
            <lhs>ns-ns-blk-modifiers</lhs>
            <rhs>
              <lineannotation>Block scalar modifiers.</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#ns-explicit-indent" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#c-chomp-control" />? )<sbr />
              | ( <nonterminal def="#c-chomp-control" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-explicit-indent" />? )
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title>
          <anchor id="syntax-scalar-indent" />
          Explicit Indentation
        </title>

        <para>
          Typically the indentation level of a block scalar node is detected
          from its first non-empty content line. This detection fails when this
          first non-empty line contains leading white space characters. Note
          that content lines, including the first non-empty content line, may
          begin with a <quote><userinput>#</userinput></quote> character.
        </para>

        <para>
          When the first non-empty content line begins with spaces, YAML
          requires that the indentation level for the scalar node text content
          be given explicitly. This level is specified as the integer number of
          the additional indentation spaces used for the text content.
        </para>

        <para>
          If the block scalar begins with lines containing only spaces, and no
          explicit indentation is given, the processor assumes such lines are
          empty lines. It is an error for any such leading empty line to
          contain more spaces than the indentation level that is deduced from
          the first non-empty content line.
        </para>

        <para>
          The indentation level is always non-zero, except for the top level
          node of each document. This node is commonly indented by zero spaces
          (not indented). When the content is not indented, all lines up to the
          next document separator, document terminator, or end of the stream
          are assumed to be content lines, even if they begin with a
          <quote><userinput>#</userinput></quote> character. Note that in this
          case, all lines up to the next document seperator are assumed to be
          content lines, even if they begin with a
          <quote><userinput>#</userinput></quote> character.
        </para>

        <para>
          It is always valid to specify an explicit indentation level, though a
          YAML processor should only do so in cases where detection fails. It
          is an error for detection to fail when there is no explicit
          indentation specified.
        </para>

        <productionset>
          <production id="ns-explicit-indent">
            <lhs>ns-explicit-indent</lhs>
            <rhs>
              <lineannotation>Explicit additional indentation
              level.</lineannotation>
              <nonterminal def="#ns-decimal-digit" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
# Explicit indentation must be given
# in both the following cases.
leading spaces: |2
      This value starts with four spaces.

leading spaces after empty lines: |2

      This value starts with four spaces.

# The following is valid:
leading comment indicator: |

  # Content line starts with a '#'
  character, and follows empty lines.

# This is a comment because it is not
# more indented than the base level.
# Since blocks may not contain comments,
# this ends the block and the following
# empty line is not a content line.

# Explicit indentation may
# also be given when it is
# not required.
redundant: |2
  This value is indented 2 spaces.

# Indentation applies to top level nodes.
--- |
Usually top level nodes are not indented.
--- |
  This text is indented two spaces.
  It contains no leading spaces.
--- |0
  This text contains two leading spaces.
---
This text is not indented, so
# this is a content line and
--- |
  However, this is indented two spaces
# So this is a comment ending the block.
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-chomp" />Chomping</title>
        <para>
          Typically the final line break of a block scalar is considered to be
          a part of its value, and any trailing empty lines are taken to be
          <link linkend="l-empty-comment(n)">comment lines</link>. This default
          <firstterm>Clip</firstterm> chomping behavior can be overriden by
          specifying a chomp control modifier.
        </para>

        <productionset>
          <production id="c-chomp-control">
            <lhs>c-chomp-control</lhs>
            <rhs>
              <lineannotation>Override the default "clip"
              chomping.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#c-strip-chomp" /><sbr />
              | <nonterminal def="#c-keep-chomp" />
            </rhs>
          </production>

          <production id="c-strip-chomp">
            <lhs>c-strip-chomp</lhs>
            <rhs>
              <lineannotation>Strip final line break from
              value.</lineannotation>
              <quote>-</quote>
            </rhs>
          </production>

          <production id="c-keep-chomp">
            <lhs>c-keep-chomp</lhs>
            <rhs>
              <lineannotation>Keep trailing line breaks in
              value.</lineannotation>
              <quote>+</quote>
            </rhs>
          </production>
        </productionset>

        <variablelist>
          <varlistentry>
            <term>
                <firstterm>Strip</firstterm>
                (<quote><userinput>-</userinput></quote>)
            </term>

            <listitem>
              The <quote><userinput>-</userinput></quote> chomp control
              specifies that the final line break character of the block scalar
              should be stripped from its value.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
                <firstterm>Keep</firstterm>
                (<quote><userinput>+</userinput></quote>)
            </term>

            <listitem>
              The <quote><userinput>+</userinput></quote> chomp control
              specifies that any trailing empty lines following the block
              scalar should be considered to be a part of its value. If this
              modifier is not specified, such lines are considered to be empty
              throwaway comment lines and are ignored.
            </listitem>
          </varlistentry>
        </variablelist>

        <para>
          When this functionality is implied, the <link
          linkend="l-l-empty-trailing(n)"
          ><userinput>l-l-empty-trailing(n)</userinput></link> production will
          be used.
        </para>

        <productionset>
          <production id="l-l-empty-trailing(n)">
            <lhs>l-l-empty-trailing(n)</lhs>
            <rhs>
              <lineannotation>Trailing line feeds or comment lines, depending
              on chomp control).</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#l-empty-comment(n)" />+<sbr />
              | <nonterminal def="#l-blk-empty-line-feed(n)" />+
            </rhs>
          </production>

          <production id="l-blk-empty-line-feed(n)">
            <lhs>l-blk-empty-line-feed(n)</lhs>
            <rhs>
              <lineannotation>Empty block line.</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal> <nonterminal def="#b-as-line-feed" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
clipped: |
    This has one newline.

same as "clipped" above: "This has one newline.\n"

stripped: |-
    This has no newline.

same as "stripped" above: "This has no newline."

kept: |+
    This has two newlines.

same as "kept" above: "This has two newlines.\n\n"
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-literal" />Literal</title>

        <para>
          A literal scalar is the simplest scalar style. No processing is
          performed on literal scalar characters aside from <link
          linkend="syntax-scalar-norm">end of line normalization</link> and
          stripping away the <link
          linkend="syntax-space-indent">indentation</link>. Indentation is
          detected from the first non-empty content line. <link
          linkend="syntax-scalar-indent">Explicit indentation</link> must be
          specified in case this yields the wrong result.
        </para>

        <para>
          Since escaping is not done, the literal style is restricted to <link
          linkend="c-printable">printable characters</link> and long lines
          cannot be wrapped. In exchange for these restrictions, literal
          scalars are the  most readable format for source code or other text
          values with  significant use of indicators, quotes, escape sequences,
          and  line breaks.
        </para>

        <productionset>
          <production id="c-l-literal(n)">
            <lhs>c-l-literal(n)</lhs>
            <rhs>
              <lineannotation>Literal scalar.</lineannotation>
              <nonterminal def="#c-literal"><quote>|</quote></nonterminal>
              <nonterminal def="#ns-ns-blk-modifiers" />?<sbr />
              <nonterminal def="#s-b-trailing-comment" /><sbr />
              <nonterminal def="#l-l-literal-value(n)" />?<sbr />
              <nonterminal def="#l-l-empty-trailing(n)" />?<sbr />
              ( <nonterminal def="#l-text-comment(n)">l-text-comment(&lt;n)</nonterminal><sbr />
              &nbsp;&nbsp;<nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>* )?
            </rhs>
          </production>

          <production id="l-l-literal-value(n)">
            <lhs>l-l-literal-value(n)</lhs>
            <rhs>
              <lineannotation>Value of literal scalar.</lineannotation>
              <nonterminal def="#l-l-literal-chunk(n)" />+
            </rhs>
          </production>

          <production id="l-l-literal-chunk(n)">
            <lhs>l-l-literal-chunk(n)</lhs>
            <rhs>
              <lineannotation>Chunk of literal scalar lines.</lineannotation>
              <nonterminal def="#l-blk-empty-line-feed(n)" />*<sbr />
              ( <nonterminal def="#l-literal-text(n)" /><sbr />
              | <nonterminal def="#l-blk-empty-specific(n)" /> )
            </rhs>
          </production>

          <production id="l-blk-empty-specific(n)">
            <lhs>l-blk-empty-specific(n)</lhs>
            <rhs>
              <lineannotation>Empty block line with preserved specific line
              break.</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal> <nonterminal def="#b-specific" />
            </rhs>
          </production>

          <production id="l-literal-text(n)">
            <lhs>l-literal-text(n)</lhs>
            <rhs>
              <lineannotation>Literal line character data.</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#i-spaces(n)" /> <nonterminal def="#nb-char" />+ <nonterminal def="#b-normalized" /> )<sbr />
              - ( <nonterminal def="#l-forbidden-non-indented" /> <nonterminal def="#b-any" /> )
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: |

literal: |
 The \ ' " characters may be
 freely used. Leading white
    space is significant.

 Line breaks are significant. Thus this value
 contains one empty line and ends with a single
 line break, but does not start with one.

is equal to: "The \\ ' \" characters may \
 be\nfreely used. Leading white\n   space \
 is significant.\n\nLine breaks are \
 significant. Thus this value\ncontains \
 one empty line and ends with a single\nline \
 break, but does not start with one.\n"

# Comments may follow a block scalar value.
# They must be less indented.

# Modifiers may be combined in any order.
indented and chomped: |2-
    This has no newline.

also written as: |-2
    This has no newline.

both are equal to: "  This has no newline."
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-folding" />Folding</title>

        <para>
          Folding supports scenarios where word-wrapping is useful for
          presentation, where the serialized content does not contain line
          breaks at convenient places.

          <remark>
            TODO: Rephrase.
          </remark>
        </para>

        <para>
          When folding is done, a single <link
          linkend="b-as-line-feed">normalized line feed</link> is converted to
          a single space (<userinput>#x20</userinput>). When two or more
          consecutive (possibly indented) normalized line feeds are
          encountered, the processor does not convert them into spaces.
          Instead, the parser ignores the first line feed and preserves the
          rest. Thus a single line feed can be serialized as two, two line
          feeds can be serialized as three, etc. In this process, <link
          linkend="b-specific">specific line breaks</link> are preserved and
          may be safely used to convey text structure.
        </para>

        <para>
          Since scalars come in both a block and flow variants, folding
          behavior must be defined in both contexts.

        </para>

        <sect3>
          <title>
            <anchor id="syntax-scalar-folding-block" />
            Folding in a block context
          </title>

          <para>
            When folding block scalars, space conversion only applies to  line
            feeds separating text lines having a non-space starting  character.
            Hence, folding does not apply to leading line feeds, line feeds
            surrounding a specific line break, or line feeds adjacent to a text
            line that starts with a space character.
          </para>

          <para>
            The combined effect of the processing rules above is that each
            "paragraph" is interpreted as a single line, empty lines are used
            to represent a line feed, and "more indented" lines are preserved.
            Also, specific line breaks may be safely used to indicate text
            structure.
          </para>

          <productionset>
            <production id="b-as-space">
              <lhs>b-as-space</lhs>
              <rhs>
                <lineannotation>Line feed converted to a
                space.</lineannotation>
                <nonterminal def="#b-generic" />
              </rhs>
            </production>

            <production id="b-ignored">
              <lhs>b-ignored</lhs>
              <rhs>
                <lineannotation>Ignored line feed.</lineannotation>
                <nonterminal def="#b-generic" />
              </rhs>
            </production>

            <production id="b-l-blk-trimmed(n)">
              <lhs>b-l-blk-trimmed(n)</lhs>
              <rhs>
                <lineannotation>Sequence of line feeds in block
                scalar.</lineannotation>
                <nonterminal def="#b-ignored" /><sbr />
                <nonterminal def="#l-blk-empty-line-feed(n)" />+
              </rhs>
            </production>
          </productionset>
        </sect3>

        <sect3>
          <title>
            <anchor id="syntax-scalar-folding-flow" />
            Folding flow scalars
          </title>

          <para>
            When folding is applied in a flow context, the process is somewhat
            different. Flow scalars depend on explicit indicators  to convey
            structure, rather than indentation. Hence, in such  scalars, all
            line space preceding or following a line break is  not considered
            to be part of the scalar value. Hence folding  flow scalars
            provides a more relaxed, less powerful semantics. In flow scalars,
            folding strips all leading and trailing white  space, further, all
            generic line breaks are folded, even if the line was "more
            indented".
          </para>

          <para>
            The combined effect of these processing rules is that each
            "paragraph" is interpreted as a single line, empty lines are used
            to represent a line feed, and text can be freely "indented" without
            affecting the scalar value. Again, specific line breaks may be
            safely used to indicate text structure.
          </para>

          <productionset>
            <production id="i-s-ignored-leading(n)">
              <lhs>i-s-ignored-leading(n)</lhs>
              <rhs>
                <lineannotation>Ignored spaces at start of flow scalar
                line.</lineannotation>
                <nonterminal def="#i-spaces(n)" /> <nonterminal def="#s-char" />+
              </rhs>
            </production>

            <production id="s-s-ignored-trailing">
              <lhs>s-s-ignored-trailing</lhs>
              <rhs>
                <lineannotation>Ignored spaces at end of flow scalar
                line.</lineannotation>
                <nonterminal def="#s-char" />+
              </rhs>
            </production>

            <production id="l-flow-empty-specific(n)">
              <lhs>l-flow-empty-specific(n)</lhs>
              <rhs>
                <lineannotation>Empty flow line with preserved specific line
                break.</lineannotation>
                ( <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal><sbr />
                | <nonterminal def="#i-s-ignored-leading(n)" /> )<sbr />
                <nonterminal def="#b-specific" />
              </rhs>
            </production>

            <production id="l-flow-empty-line-feed(n)">
              <lhs>l-flow-empty-line-feed(n)</lhs>
              <rhs>
                <lineannotation>Empty flow line with line break normalized to
                line feed.</lineannotation>
                ( <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal><sbr />
                | <nonterminal def="#i-s-ignored-leading(n)" /> )<sbr />
                <nonterminal def="#b-as-line-feed" />
              </rhs>
            </production>

            <production id="b-l-flow-trimmed(n)">
              <lhs>b-l-flow-trimmed(n)</lhs>
              <rhs>
                <lineannotation>Sequence of line feeds in flow
                scalar.</lineannotation>
                <nonterminal def="#b-ignored" /><sbr />
                <nonterminal def="#l-flow-empty-line-feed(n)" />+
              </rhs>
            </production>

            <production id="s-l-end-flow-line(n)">
              <lhs>s-l-end-flow-line(n)</lhs>
              <rhs>
                <lineannotation>End of a line in a multi-line flow
                scalar.</lineannotation>
                <nonterminal def="#s-s-ignored-trailing" /><sbr />
                ( <nonterminal def="#b-as-space" /><sbr />
                | <nonterminal def="#b-l-flow-trimmed(n)" /><sbr />
                | <nonterminal def="#b-specific" /> )
              </rhs>
            </production>
          </productionset>
        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-folded" />Folded</title>

        <para>
          A folded scalar is similar to a <link
          linkend="syntax-scalar-literal">literal scalar</link>. However,
          unlike a literal scalar, a folded scalar is subject to (block) <link
          linkend="syntax-scalar-folding-block">line folding</link>. This
          allows long lines to be broken anywhere a space character
          (<userinput>#x20</userinput>) appears, at the cost of requiring an
          empty line to represent each <link linkend="b-line-feed">line
          feed</link> character.
        </para>

        <productionset>
          <production id="c-l-folded(n)">
            <lhs>c-l-folded(n)</lhs>
            <rhs>
              <lineannotation>Folded scalar.</lineannotation>
              <nonterminal def="#c-folded"><quote>&gt;</quote></nonterminal>
              <nonterminal def="#ns-ns-blk-modifiers" /><sbr />
              <nonterminal def="#s-b-trailing-comment" /><sbr />
              <nonterminal def="#l-l-folded-value(n)" />?<sbr />
              <nonterminal def="#l-l-empty-trailing(n)" />?<sbr />
              ( <nonterminal def="#l-text-comment(n)">l-text-comment(&lt;n)</nonterminal><sbr />
              &nbsp;&nbsp;<nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>* )?
            </rhs>
          </production>

          <production id="l-l-folded-value(n)">
            <lhs>l-l-folded-value(n)</lhs>
            <rhs>
              <lineannotation>Value of folded scalar.</lineannotation>
              <nonterminal def="#l-blk-empty-line-feed(n)" />*<sbr />
              ( <nonterminal def="#l-l-folded-chunk(n)" /><sbr />
              | <nonterminal def="#l-l-non-folded-chunk(n)" /> )
            </rhs>
          </production>

          <production id="l-l-folded-chunk(n)">
            <lhs>l-l-folded-chunk(n)</lhs>
            <rhs>
              <lineannotation>Value starting with a chunk of folded
              text.</lineannotation>
              ( <nonterminal def="#i-nb-folded-paragraph(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#b-l-blk-trimmed(n)" /> )*<sbr />
              <nonterminal def="#i-nb-folded-paragraph(n)" /><sbr />
              <nonterminal def="#b-l-after-folded-chunk(n)" />
            </rhs>
          </production>

          <production id="i-nb-folded-paragraph(n)">
            <lhs>i-nb-folded-paragraph(n)</lhs>
            <rhs>
              <lineannotation>Single content paragraph folded into multiple
              physical lines.</lineannotation>
              ( <nonterminal def="#i-nb-folded-text(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#b-as-space" /> )*<sbr />
              <nonterminal def="#i-nb-folded-text(n)" />
            </rhs>
          </production>

          <production id="i-nb-folded-text(n)">
            <lhs>i-nb-folded-text(n)</lhs>
            <rhs>
              <lineannotation>Folded text line characters.</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#i-spaces(n)" /> <nonterminal def="#ns-char" /> <nonterminal def="#nb-char" />* )<sbr />
              - <nonterminal def="#l-forbidden-non-indented" />
            </rhs>
          </production>

          <production id="b-l-after-folded-chunk(n)">
            <lhs>b-l-after-folded-chunk(n)</lhs>
            <rhs>
              <lineannotation>Text following a folded text
              chunk.</lineannotation>
              <nonterminal def="#b-normalized" /><sbr />
              ( <nonterminal def="#l-blk-empty-line-feed(n)" />*<sbr />
              &nbsp;&nbsp;<nonterminal def="#l-l-non-folded-chunk(n)" /> )?
            </rhs>
          </production>

          <production id="l-l-non-folded-chunk(n)">
            <lhs>l-l-non-folded-chunk(n)</lhs>
            <rhs>
              <lineannotation>Value starting with non-folded text
              chunk.</lineannotation>
              ( <nonterminal def="#l-empty-non-folded(n)" /><sbr />
              | <nonterminal def="#l-indented-non-folded(n)" /> )<sbr />
              <nonterminal def="#l-l-folded-value(n)" />?
            </rhs>
          </production>

          <production id="l-empty-non-folded(n)">
            <lhs>l-empty-non-folded(n)</lhs>
            <rhs>
              <lineannotation>Not folded due to specific line
              break.</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal> <nonterminal def="#b-specific" />
            </rhs>
          </production>

          <production id="l-indented-non-folded(n)">
            <lhs>l-indented-non-folded(n)</lhs>
            <rhs>
              <lineannotation>Not folded due to starting white
              space.</lineannotation>
              <nonterminal def="#i-spaces(n)" /> <nonterminal def="#s-char" /> <nonterminal def="#nb-char" />*<sbr />
              <nonterminal def="#b-normalized" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: &gt;

one paragraph: &gt;
 Line feeds are converted to spaces,
 so this value contains no line
 breaks except for the final one.

multiple paragraphs: &gt;2

  An empty line, either at
  the start or in the value:

  Is interpreted as a line
  break. Thus this value
  contains three line breaks.

indented text: &gt;
    This is a folded paragraph
    followed by a list:
     * first entry
     * second entry
    Followed by another folded
    paragraph, another list:

     * first entry

     * second entry

    And a final folded
    paragraph.

above is equal to: |
    This is a folded paragraph followed by a list:
     * first entry
     * second entry
    Followed by another folded paragraph, another list:

     * first entry

     * second entry

    And a final folded paragraph.

# Explicit comments may follow
# but must be less indented.
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-single" />Single Quoted</title>

        <para>
          The single quoted flow scalar style is indicated by surrounding
          <link
          linkend="c-single-quote"><quote><userinput
          >'</userinput></quote></link>
          characters. Therefore, within a single quoted scalar such
          characters need to be <link
          linkend="ns-escaped-single-quote">escaped</link>. No other form of
          escaping is done, limiting single quoted scalars to printable
          characters.
        </para>

        <para>
          Single quoted scalars are subject to (flow) <link
          linkend="syntax-scalar-folding-flow">folding</link>. This allows
          empty lines to be broken everywhere a single space character
          (<userinput>#x20</userinput>) separates non-space characters, at the
          cost of requiring an empty line to represent each <link
          linkend="b-line-feed">line feed</link> character.
        </para>

        <productionset>
          <production id="c-c-single-quoted(n)">
            <lhs>c-c-single-quoted(n)</lhs>
            <rhs>
              <lineannotation>Single quoted scalar.</lineannotation>
              <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal>
              <nonterminal def="#nb-nb-single-quoted-value(n)" />?
              <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-nb-single-quoted-value(n)">
            <lhs>nb-nb-single-quoted-value(n)</lhs>
            <rhs>
              <lineannotation>Value of a single quoted scalar.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#nb-nb-one-single-line" /><sbr />
              | ( <nonterminal def="#nb-l-first-single-line(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-l-inner-single-line(n)" />*<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-nb-last-single-line(n)" /> )
            </rhs>
          </production>

          <production id="nb-nb-one-single-line">
            <lhs>nb-nb-one-single-line</lhs>
            <rhs>
              <lineannotation>One line value of single quoted
              scalar.</lineannotation>
              <nonterminal def="#nb-single-char" />+
            </rhs>
          </production>

          <production id="nb-l-first-single-line(n)">
            <lhs>nb-l-first-single-line(n)</lhs>
            <rhs>
              <lineannotation>First line of multi-line single quoted
              scalar.</lineannotation>
              ( <nonterminal def="#nb-single-char" />* <nonterminal def="#ns-single-char" /> )?<sbr />
              <nonterminal def="#s-l-end-flow-line(n)" />
            </rhs>
          </production>

          <production id="l-l-inner-single-line(n)">
            <lhs>l-l-inner-single-line(n)</lhs>
            <rhs>
              <lineannotation>Inner line of multi-line single quoted
              scalar.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#l-flow-empty-specific(n)" /><sbr />
              | ( <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-single-char" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#nb-l-first-single-line(n)" /> )
            </rhs>
          </production>

          <production id="i-nb-last-single-line(n)">
            <lhs>i-nb-last-single-line(n)</lhs>
            <rhs>
              <lineannotation>Last line of multi-line single quoted
              scalar.</lineannotation>
              <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              ( <nonterminal def="#ns-single-char" /> <nonterminal def="#nb-single-char" />* )?
            </rhs>
          </production>

          <production id="ns-escaped-single-quote">
            <lhs>ns-escaped-single-quote</lhs>
            <rhs>
              <lineannotation>Indicates a single quote.</lineannotation>
              <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal> <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-single-char">
            <lhs>nb-single-char</lhs>
            <rhs>
              <lineannotation>Non-break char valid in a single quoted
              scalar.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-escaped-single-quote" /><sbr />
              | ( <nonterminal def="#nb-char" /> - <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal> )
            </rhs>
          </production>

          <production id="ns-single-char">
            <lhs>ns-single-char</lhs>
            <rhs>
              <lineannotation>Non-space char valid in a single quoted
              scalar.</lineannotation>
              <nonterminal def="#nb-single-char" /> - <nonterminal def="#s-char" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: ''
second:
  '! : \ etc. can be used freely.'
third: 'a single quote '' must be escaped.'
span: 'this contains
      six spaces

      and one
      line break'
is same as: "this contains six spaces\nand one line break"
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-escape" />Escaping</title>

        <para>
          Escaping allows YAML scalar nodes to specify arbitrary Unicode
          characters, using C-style escape codes. Non-escaped nodes are
          restricted to <link linkend="c-printable">printable Unicode
          characters</link>.
        </para>

        <productionset>
          <production id="c-escape">
            <lhs>c-escape</lhs>
            <rhs>
              <lineannotation>Escape character.</lineannotation>
              <quote>\</quote>
            </rhs>
          </production>

          <production id="ns-esc-escape">
            <lhs>ns-esc-escape</lhs>
            <rhs>
              <lineannotation>Escaped backslash.</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-esc-double-quote">
            <lhs>ns-esc-double-quote</lhs>
            <rhs>
              <lineannotation>Escaped double quote character.</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-esc-bel">
            <lhs>ns-esc-bel</lhs>
            <rhs>
              <lineannotation>ASCII alert (BEL).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>a</quote>
            </rhs>
          </production>

          <production id="ns-esc-backspace">
            <lhs>ns-esc-backspace</lhs>
            <rhs>
              <lineannotation>ASCII backspace (BS).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>b</quote>
            </rhs>
          </production>

          <production id="ns-esc-esc">
            <lhs>ns-esc-esc</lhs>
            <rhs>
              <lineannotation>ASCII escape (ESC).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>e</quote>
            </rhs>
          </production>

          <production id="ns-esc-form-feed">
            <lhs>ns-esc-form-feed</lhs>
            <rhs>
              <lineannotation>ASCII formfeed (FF).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>f</quote>
            </rhs>
          </production>

          <production id="ns-esc-line-feed">
            <lhs>ns-esc-line-feed</lhs>
            <rhs>
              <lineannotation>ASCII linefeed (LF).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>n</quote>
            </rhs>
          </production>

          <production id="ns-esc-return">
            <lhs>ns-esc-return</lhs>
            <rhs>
              <lineannotation>ASCII carriage return (CR).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>r</quote>
            </rhs>
          </production>

          <production id="ns-esc-tab">
            <lhs>ns-esc-tab</lhs>
            <rhs>
              <lineannotation>ASCII horizontal tab (TAB).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>t</quote>
            </rhs>
          </production>

          <production id="ns-esc-vertical-tab">
            <lhs>ns-esc-vertical-tab</lhs>
            <rhs>
              <lineannotation>ASCII vertical tab (VTAB).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>v</quote>
            </rhs>
          </production>

          <production id="ns-esc-null">
            <lhs>ns-esc-null</lhs>
            <rhs>
              <lineannotation>ASCII zero (NUL).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>0</quote>
            </rhs>
          </production>

          <production id="ns-esc-space">
            <lhs>ns-esc-space</lhs>
            <rhs>
              <lineannotation>ASCII space (SP).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> #20
            </rhs>
          </production>

          <production id="ns-esc-non-breaking-space">
            <lhs>ns-esc-non-breaking-space</lhs>
            <rhs>
              <lineannotation>Unicode non-breaking space
              (NBSP).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>_</quote>
            </rhs>
          </production>

          <production id="ns-esc-next-line">
            <lhs>ns-esc-next-line</lhs>
            <rhs>
              <lineannotation>Unicode next line (NEL).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>N</quote>
            </rhs>
          </production>

          <production id="ns-esc-line-separator">
            <lhs>ns-esc-line-separator</lhs>
            <rhs>
              <lineannotation>Unicode line separator (LS).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>L</quote>
            </rhs>
          </production>

          <production id="ns-esc-paragraph-separator">
            <lhs>ns-esc-paragraph-separator</lhs>
            <rhs>
              <lineannotation>Unicode paragraph separator (PS).</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>P</quote>
            </rhs>
          </production>

          <production id="ns-esc-8-bit">
            <lhs>ns-esc-8-bit</lhs>
            <rhs>
              <lineannotation>8-bit character.</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>x</quote> ( <nonterminal def="#ns-hex-digit" /> x 2 )
            </rhs>
          </production>

          <production id="ns-esc-16-bit">
            <lhs>ns-esc-16-bit</lhs>
            <rhs>
              <lineannotation>16-bit character.</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>u</quote> ( <nonterminal def="#ns-hex-digit" /> x 4 )
            </rhs>
          </production>

          <production id="ns-esc-32-bit">
            <lhs>ns-esc-32-bit</lhs>
            <rhs>
              <lineannotation>32-bit character.</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>U</quote> ( <nonterminal def="#ns-hex-digit" /> x 8 )
            </rhs>
          </production>

          <production id="ns-esc-sequence">
            <lhs>ns-esc-sequence</lhs>
            <rhs>
              <lineannotation>Escape codes in escaped scalars.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-esc-escape" /><sbr />
              | <nonterminal def="#ns-esc-double-quote" /><sbr />
              | <nonterminal def="#ns-esc-bel" /><sbr />
              | <nonterminal def="#ns-esc-backspace" /><sbr />
              | <nonterminal def="#ns-esc-esc" /><sbr />
              | <nonterminal def="#ns-esc-form-feed" /><sbr />
              | <nonterminal def="#ns-esc-line-feed" /><sbr />
              | <nonterminal def="#ns-esc-return" /><sbr />
              | <nonterminal def="#ns-esc-tab" /><sbr />
              | <nonterminal def="#ns-esc-vertical-tab" /><sbr />
              | <nonterminal def="#ns-esc-null" /><sbr />
              | <nonterminal def="#ns-esc-space" /><sbr />
              | <nonterminal def="#ns-esc-non-breaking-space" /><sbr />
              | <nonterminal def="#ns-esc-next-line" /><sbr />
              | <nonterminal def="#ns-esc-line-separator" /><sbr />
              | <nonterminal def="#ns-esc-paragraph-separator" /><sbr />
              | <nonterminal def="#ns-esc-8-bit" /><sbr />
              | <nonterminal def="#ns-esc-16-bit" /><sbr />
              | <nonterminal def="#ns-esc-32-bit" />
            </rhs>
          </production>
        </productionset>

        <para>
          An escaped line break is completely ignored.
        </para>

        <productionset>
          <production id="b-escaped">
            <lhs>b-escaped</lhs>
            <rhs>
              <lineannotation>Escaped (ignored) line break.</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <nonterminal def="#b-any" />
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-double" />Double Quoted</title>

        <para>
          The double quoted style variant adds <link
          linkend="syntax-scalar-escape">escaping</link> to the <link
          linkend="syntax-single">single quoted</link> style variant. This is
          indicated by surrounding <link linkend="c-double-quote"
          ><quote><userinput>"</userinput></quote></link> characters. Escaping
          allows arbitrary Unicode characters to be specified at the cost of
          some verbosity: escaping the printable <link
          linkend="c-escape"><quote><userinput>\</userinput></quote></link> and
          <link linkend="c-double-quote"
          ><quote><userinput>"</userinput></quote></link> characters. It is an
          error for a double quoted value to contain invalid escape sequences.
        </para>

        <para>
          Like single quoted scalars, double quoted scalars may span multiple
          lines, resulting in a single space content character for each line
          break. If the line break is escaped, any white space preceding it is
          preserved, and the line break and any leading white space in the
          continuation line are discarded.
        </para>

        <productionset>
          <production id="c-c-double-quoted(n)">
            <lhs>c-c-double-quoted(n)</lhs>
            <rhs>
              <lineannotation>Double quoted scalar.</lineannotation>
              <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal>
              <nonterminal def="#nb-nb-double-quoted-value(n)" />?
              <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-nb-double-quoted-value(n)">
            <lhs>nb-nb-double-quoted-value(n)</lhs>
            <rhs>
              <lineannotation>Value of a double quoted scalar.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#nb-nb-one-double-line" /><sbr />
              | ( <nonterminal def="#nb-l-first-double-line(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-l-inner-double-line(n)" />*<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-nb-last-double-line(n)" /> )
            </rhs>
          </production>

          <production id="nb-nb-one-double-line">
            <lhs>nb-nb-one-double-line</lhs>
            <rhs>
              <lineannotation>One line value of double quoted
              scalar.</lineannotation>
              <nonterminal def="#nb-double-char" />+
            </rhs>
          </production>

          <production id="nb-l-first-double-line(n)">
            <lhs>nb-l-first-double-line(n)</lhs>
            <rhs>
              <lineannotation>First line of multi-line double quoted
              scalar.</lineannotation>
              ( <nonterminal def="#nb-double-char" />* <nonterminal def="#ns-double-char" /> )?<sbr />
              <nonterminal def="#s-l-end-double-line(n)" />
            </rhs>
          </production>

          <production id="l-l-inner-double-line(n)">
            <lhs>l-l-inner-double-line(n)</lhs>
            <rhs>
              <lineannotation>Inner line of multi-line double quoted
              scalar.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#l-flow-empty-specific(n)" /><sbr />
              | ( <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-double-char" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#nb-l-first-double-line(n)" /> )
            </rhs>
          </production>

          <production id="i-nb-last-double-line(n)">
            <lhs>i-nb-last-double-line(n)</lhs>
            <rhs>
              <lineannotation>Last line of multi-line double quoted
              scalar.</lineannotation>
              <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              ( <nonterminal def="#ns-double-char" /> <nonterminal def="#nb-double-char" />* )?
            </rhs>
          </production>

          <production id="s-l-end-double-line(n)">
            <lhs>s-l-end-double-line(n)</lhs>
            <rhs>
              <lineannotation>End of a line in a multi-line double quoted
              scalar.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#s-l-end-flow-line(n)" /><sbr />
              | ( <nonterminal def="#s-char" />* <nonterminal def="#b-escaped" /> )
            </rhs>
          </production>

          <production id="nb-double-char">
            <lhs>nb-double-char</lhs>
            <rhs>
              <lineannotation>Non-break char valid in a double quoted
              scalar.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-esc-sequence" /><sbr />
              | ( <nonterminal def="#nb-char" /> - <nonterminal def="#c-escape"><quote>\</quote></nonterminal> )
            </rhs>
          </production>

          <production id="ns-double-char">
            <lhs>ns-double-char</lhs>
            <rhs>
              <lineannotation>Non-space char valid in a double quoted
              scalar.</lineannotation>
              <nonterminal def="#nb-double-char" /> - <nonterminal def="#s-char" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: ""
second: "! : etc. can be used freely."
third: "a \" or a \\ must be escaped."
fourth:
  "this value ends with an LF.\n"
span: "this contains
  four  \
      spaces"
is equal to: "this contains four  spaces"
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-plain" />Plain</title>

        <para>
          The plain style variant is a restricted form of the <link
          linkend="syntax-single">single quoted</link> style variant. As it has
          no identifying markers, it may not start or end with white space
          characters, may not start with most <link
          linkend="syntax-char-indicator">indicators</link>, and may not
          contain certain indicators. Also, a plain scalar is subject to <link
          linkend="type-implicit">implicit typing</link>. This can be avoided by
          providing an <link linkend="type-explicit">explicit tag</link>
          property.
        </para>

        <para>
          Since it lacks identifying markers, the restrictions on a plain
          scalar depends on the context. There are three different such
          contexts, with increasing restrictions. Top level plain values are
          the least restricted plain scalar format. While they can't start with
          <link linkend="ns-first-plain-char">most indicators</link>, they may
          contain any indicator except <link linkend="c-throwaway"
          ><quote>&nbsp;<userinput>#</userinput></quote></link> and <link
          linkend="c-mapping-entry"
          ><quote><userinput>:</userinput>&nbsp;</quote></link>. Plain scalars
          used in flow collections are further restricted not to contain <link
          linkend="nb-plain-flow-char">flow indicators</link>. Finally, plain
          keys are further restricted to a single line.
        </para>

        <productionset>
          <production id="ns-ns-plain-top(n)">
            <lhs>ns-ns-plain-top(n)</lhs>
            <rhs>
              <lineannotation>Avoiding top indicator chars.</lineannotation>
              <nonterminal def="#ns-ns-plain-value(n)" />
            </rhs>
          </production>

          <production id="ns-ns-plain-flow(n)">
            <lhs>ns-ns-plain-flow(n)</lhs>
            <rhs>
              <lineannotation>Avoiding flow indicator chars.</lineannotation>
              <nonterminal def="#ns-ns-plain-value(n)" />
            </rhs>
          </production>

          <production id="ns-ns-plain-key">
            <lhs>ns-ns-plain-key</lhs>
            <rhs>
              <lineannotation>Plain scalar used as a key; avoiding flow
              indicator chars.</lineannotation>
              <nonterminal def="#ns-ns-one-plain-line" />
            </rhs>
          </production>

          <production id="ns-ns-plain-value(n)">
            <lhs>ns-ns-plain-value(n)</lhs>
            <rhs>
              <lineannotation>Plain scalar used as a value.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-one-plain-line" /><sbr />
              | ( <nonterminal def="#ns-l-first-plain-line(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-l-inner-plain-line(n)" />*<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-ns-last-plain-line(n)" /> )
            </rhs>
          </production>

          <production id="ns-ns-one-plain-line">
            <lhs>ns-ns-one-plain-line</lhs>
            <rhs>
              <lineannotation>Plain one-line value.</lineannotation>
              <nonterminal def="#ns-first-plain-char" /><sbr />
              <nonterminal def="#nb-ns-plain-text" />?
            </rhs>
          </production>

          <production id="ns-l-first-plain-line(n)">
            <lhs>ns-l-first-plain-line(n)</lhs>
            <rhs>
              <lineannotation>First line of multi-line plain
              scalar.</lineannotation>
              <nonterminal def="#ns-ns-one-plain-line" /><sbr />
              <nonterminal def="#s-l-end-flow-line(n)" />
            </rhs>
          </production>

          <production id="l-l-inner-plain-line(n)">
            <lhs>l-l-inner-plain-line(n)</lhs>
            <rhs>
              <lineannotation>Inner line of multi-line plain
              scalar.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#l-flow-empty-specific(n)" /><sbr />
              | ( <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-plain-char" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#nb-ns-plain-text" />?<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-l-end-flow-line(n)" /> )
            </rhs>
          </production>

          <production id="i-ns-last-plain-line(n)">
            <lhs>i-ns-last-plain-line(n)</lhs>
            <rhs>
              <lineannotation>Last line of multi-line plain
              scalar.</lineannotation>
              <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              ( <nonterminal def="#ns-plain-char" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#nb-ns-plain-text" />? )?
            </rhs>
          </production>

          <production id="nb-ns-plain-text">
            <lhs>nb-ns-plain-text</lhs>
            <rhs>
              <lineannotation>Chunk of plain text.</lineannotation>
              <nonterminal def="#nb-plain-char" />* <nonterminal def="#ns-plain-char" />
            </rhs>
          </production>

          <production id="ns-first-plain-char">
            <lhs>ns-first-plain-char</lhs>
            <rhs>
              <lineannotation>First character in a plain
              scalar.</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#ns-plain-char" /><sbr />
              &nbsp;&nbsp;- <nonterminal def="#c-indicators" /> )<sbr />
              | ( ( <nonterminal def="#c-sequence-entry"><quote>-</quote></nonterminal>
              | <nonterminal def="#c-top-key"><quote>?</quote></nonterminal>
              | <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              | <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal> )<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-plain-char" /> )
            </rhs>
          </production>

          <production id="nb-plain-top-char">
            <lhs>nb-plain-top-char</lhs>
            <rhs>
              <lineannotation>Char allowed in plain scalar used as top level
              value.</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#nb-char" />
              - <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              - <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal> )<sbr />
              | ( <nonterminal def="#ns-plain-char" />
              <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal> )<sbr />
              | ( <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              <nonterminal def="#ns-plain-char" /> )
            </rhs>
          </production>

          <production id="nb-plain-flow-char">
            <lhs>nb-plain-flow-char</lhs>
            <rhs>
              <lineannotation>Char allowed in plain scalar used as value in a
              flow collection.</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#nb-plain-top-char" /><sbr />
              &nbsp;&nbsp;- <nonterminal def="#c-sequence-start"><quote>[</quote></nonterminal>
              - <nonterminal def="#c-sequence-end"><quote>]</quote></nonterminal>
              - <nonterminal def="#c-mapping-start"><quote>{</quote></nonterminal>
              - <nonterminal def="#c-mapping-end"><quote>}</quote></nonterminal>
              - <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal> )<sbr />
              | ( <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal>
              <nonterminal def="#ns-plain-char" /> )
            </rhs>
          </production>

          <production id="nb-plain-key-char">
            <lhs>nb-plain-key-char</lhs>
            <rhs>
              <lineannotation>Char allowed in plain scalar used as
              key.</lineannotation>
              <nonterminal def="#nb-plain-flow-char" />
            </rhs>
          </production>

          <production id="nb-plain-char">
            <lhs>nb-plain-char</lhs>
            <rhs>
              <lineannotation>Depending whether reached from top, flow or key
              plain scalar production.</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#nb-plain-top-char" /><sbr />
              | <nonterminal def="#nb-plain-flow-char" /><sbr />
              | <nonterminal def="#nb-plain-key-char" />
            </rhs>
          </production>

          <production id="ns-plain-char">
            <lhs>ns-plain-char</lhs>
            <rhs>
              <lineannotation>Non-space char valid in a plain
              scalar.</lineannotation>
              <nonterminal def="#nb-plain-char" /> - <nonterminal def="#s-char" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
first: There is no unquoted empty string.
second: 12          ## This is an integer.
boolean: n          ## This is false.
third: !str 12      ## This is a string.
span: this contains
      six spaces

      and one
      line break

indicators: this has no comments.
            #:foo and bar# are
            both text.
flow: [ can span
           lines, # comment
             like
           this ]
note: { one-line keys: but
        multi-line values }
</programlisting>
        </example>
      </sect2>
    </sect1>
  </chapter>


  <chapter>
    <title><anchor id="type" />Type Families</title>

    <para>
      Every <link linkend="model-native-node">native node</link> has, by
      definition, a type family. However this type family may be missing
      (implicit) from the <link linkend="model-graph">graph model</link>.
      YAML provides three mechanisms for identifying the true type family
      (and format) of each node.
    </para>

    <variablelist>
      <varlistentry>
        <term>
          <anchor id="type-explicit" /><firstterm>Explicit Typing</firstterm>
        </term>

        <listitem>
	  <para>
            A node may be given an explicit <link
            linkend="syntax-stream-tag">tag</link> property, specifying the
            node's type family and optionally its format. If no format is
            given, the loader needs to select amongst the type family's
            formats. This is usualy done by matching the value with the
            regular expressions of each of the implicit and explicit formats
            provided by the type family to determine the specific format
            used.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <anchor id="type-default" /><firstterm>Default Typing</firstterm>
        </term>

        <listitem>
	  <para>
            When no explicit type family is given, the parser assigns the
            <link linkend="type-str">str</link> type family to all <link
            linkend="syntax-scalar">scalar</link> nodes, except for <link
            linkend="syntax-scalar-plain">plain scalars</link>. This is the
            only case where typing is done by the parser; all other typing
            is done by the loader. Specifying an explicit empty tag disables
            this and forces such nodes to undergo implicit typing.
          </para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>
          <anchor id="type-implicit" /><firstterm>Implicit Typing</firstterm>
        </term>

        <listitem>
	  <para>
            All nodes that are not explicitly typed and do not have a
            default type family are subject to implicit typing. This can
            also be forced using the tag indicator, <link
            linkend="c-tag"><quote><userinput>!</userinput></quote></link>,
            all by itself. The loader is then responsible for assigning a
            type family (and format) for such nodes. This is done in an
            application-specific manner. However, it is common practice to
            base such implicit typing on the <link
            linkend="type-implicit">implicit formats</link> of scalar type
            families. Similarly, implicit typing of collection nodes may be
            based on the kind of the collection node and its contents.
            Implicit typing of a node may also depend on its position in the
            graph.
          </para>

	  <para>
            The implicit typing rules depends upon the application. It is
            possible to parse a document without being aware of these rules.
            However, without knowledge of these rules, loading an implicitly
            typed node to native data structures is not possible.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>
      <anchor id="type-repository" />Following is a description of the three
      mandatory core type families. YAML requires support for the <link
      linkend="type-seq">seq</link>, <link linkend="type-map">map</link> and
      <link linkend="type-str">str</link> type families. YAML also provides
      a list of universal types that are not mandatory in the YAML type
      repository available at <ulink
      url="http://yaml.org/type">http://yaml.org/type</ulink>. These types
      map to native data types in most programming languages or are useful
      in a wide range of applications. Hence applications are strongly
      encouraged to make use of them whenever they are appropriate in order
      to improve interoperability between YAML systems.
    </para>

    <sect1>
      <title><anchor id="type-seq" />Sequence</title>

      <variablelist>
        <varlistentry>
          <term>URI:</term>
          <listitem><userinput>tag:yaml.org,2002:seq</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Shorthand:</term>
          <listitem><userinput>!seq</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Kind:</term>
          <listitem>Sequence.</listitem>
        </varlistentry>

        <varlistentry>
          <term>Definition:</term>
          <listitem>
            <para>
              Collections indexed by sequential integers starting with zero.
            </para>

	    <para>
              This type family is typically used for implicitly typing <link
              linkend="syntax-collect-seq">sequence</link> nodes. Example
              bindings include the Perl array, Python's list or tuple, and
              Java's array or vector.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
<programlisting>
# The following are equal seqs
# with different identities.
flow: [ one, two ]
spanning: [ one,
     two ]
block:
  - one
  - two
</programlisting>
      </example>
    </sect1>

    <sect1>
      <title><anchor id="type-map" />Mapping</title>

      <variablelist>
        <varlistentry>
          <term>URI:</term>
          <listitem><userinput>tag:yaml.org,2002:map</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Shorthand:</term>
          <listitem><userinput>!map</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Kind:</term>
          <listitem>Mapping.</listitem>
        </varlistentry>

        <varlistentry>
          <term>Definition:</term>
          <listitem>
	    <para>
              Associative container, where each key is unique in the
              association and mapped to exactly one value.
            </para>

	    <para>
              This type family is typically used for implicitly typing <link
              linkend="syntax-collect-map">mapping</link> nodes. Example
              bindings include the Perl hash, Python's dictionary, and
              Java's Hashtable.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
<programlisting>
# The following are equal maps
# with different identities.
flow: { one: 1, two: 2 }
block:
    one: 1
    two: 2
</programlisting>
      </example>
    </sect1>

    <sect1>
      <title><anchor id="type-str" />String</title>

      <variablelist>
        <varlistentry>
          <term>URI:</term>
          <listitem><userinput>tag:yaml.org,2002:str</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Shorthand:</term>
          <listitem><userinput>!str</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Kind:</term>
          <listitem>Scalar.</listitem>
        </varlistentry>

        <varlistentry>
          <term>Canonical:</term>
          <listitem>
            N/A (single format).
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Regexp:</term>
          <listitem><userinput>.*</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Definition:</term>
          <listitem>
            <para>
              Unicode strings, a sequence of zero or more Unicode characters.
            </para>

	    <para>
              This type family is used as the default for all <link
              linkend="syntax-scalar">scalar</link> styles with the
              exception of <link linkend="syntax-scalar-plain">plain
              scalars</link>, unless they are given an explicit tag
              property. Also, it is typically used as the default implicit
              type family for all plain scalars that don't match any other
              implicit type.
            </para>

	    <para>
              This type is usually bound to the native language's string or
              character array construct. Note that generic YAML tools should
              have an immutable (const) interface to such constructs even
              when the language default is mutable (such as in C/C++).
            </para>
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
<programlisting>
# Assuming an application
# using implicit integers.
- 12     # An integer
- ! "12" # Also an integer.
# The following scalars
# are loaded to the
# string value '1' '2'.
- !str 12
- '12'
- "12"
- "\
 1\
 2"
# Otherwise, everything is a string:
- /foo/bar
- 192.168.1.1
</programlisting>
      </example>
    </sect1>
  </chapter>

  <appendix>
    <title>YAML Terms</title>

    <para>
      YAML defines a special meaning to the following terms:
    </para>

    <index>
      <title />
    </index>
  </appendix>
</book>
