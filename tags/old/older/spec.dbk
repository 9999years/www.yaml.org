<?xml version="1.0"?>
<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook V4.2//EN"
         "file:///usr/local/share/xml/docbook/4.2/docbookx.dtd"
[]>

<book status="draft">
  <bookinfo>
    <title>
      YAML Ain't Markup Language (<trademark>YAML</trademark>) 1.0
    </title>

    <subtitle>
      Working Draft 2004-JAN-29
    </subtitle>

    <authorgroup>
      <author>
        <firstname>Oren</firstname>
        <surname>Ben-Kiki</surname>
        <email>oren@ben-kiki.org</email>
      </author>

      <author>
        <firstname>Clark</firstname>
        <surname>Evans</surname>
        <email>cce@clarkevans.com</email>
      </author>

      <author>
        <firstname>Brian</firstname>
        <surname>Ingerson</surname>
        <email>ingy@ttul.org</email>
      </author>
    </authorgroup>

    <copyright>
      <year>2001-2004</year>
      <holder>Oren Ben-Kiki</holder>
      <holder>Clark Evans</holder>
      <holder>Brian Ingerson</holder>
    </copyright>

    <releaseinfo id="releaseinfo">
      <emphasis>This version:</emphasis>
      <ulink url="http://www.yaml.org/spec/29jan2004.html" /><sbr />
      <emphasis>Latest version:</emphasis>
      <ulink url="http://www.yaml.org/spec" />
    </releaseinfo>

    <legalnotice>
      This document may be freely copied provided it is not modified.
    </legalnotice>

    <abstract>
      <title>Status of this Document</title>

      <para>
        This is an intermediate working draft and is being actively 
        revised.  Hopefully the next draft will be a release canidate.
      </para>

      <para>
        We wish to thank implementers who have tirelessly tracked earlier
        versions of this specification, and our fabulous user community
        whose feedback has both validated and clarified our direction.
      </para>
    </abstract>

    <abstract>
      <title>Abstract</title>

      <para>
        <trademark>YAML</trademark> (rhymes with <quote>camel</quote>) is a
        human friendly, cross language, unicode based data serialization
        language designed around the common native structures of agile
        programming languages. It is broadly useful for programming needs
        ranging from configuration files to Internet messaging to object
        persistence to data auditing. Together with the <ulink
        url="http://www.unicode.org/">Unicode</ulink> standard for
        characters, this specification provides all the information
        necessary to understand YAML Version 1.0 and to construct programs
        that process YAML information.
      </para>
    </abstract>

  </bookinfo>

  <chapter>
    <title><anchor id="intro"/>Introduction</title>

    <para>
      "YAML Ain't Markup Language" (abbreviated YAML) is a data
      serialization language designed to be human friendly and work well
      with modern programming languages for common everyday tasks. This
      specification is both an introduction to the YAML language and the
      concepts supporting it; and also a complete reference of the
      information needed to develop applications for processing YAML.
    </para>

    <para>
      Open, interoperable and readily understandable tools have advanced
      computing immensely. YAML was designed from the start to be useful and
      friendly to the people working with data. It uses printable unicode
      characters, some of which provide structural information and the rest
      representing the data itself. YAML achieves a unique cleanness by
      minimizing the amount of structural characters, and allowing the data
      to show itself in a natural and meaningful way. For example,
      indentation is used for structure, colons separate pairs, and dashes
      are used for bulleted lists.
    </para>

    <para>
      There are myriad flavors of data structures, but they can all be
      adequately represented with three basic primitives: mappings
      (hashes/dictionaries), sequences (arrays/lists) and scalars
      (strings/numbers). YAML leverages these primitives and adds a simple
      typing system and aliasing mechanism to form a complete language for
      encoding any data structure. While most programming languages
      can use YAML for data serialization, YAML excels in those languages
      that are fundamentally built around the three basic primitives. These
      include the new wave of agile languages such as Perl, Python, PHP,
      Ruby and Javascript.
    </para>

    <para>
      There are hundreds of different languages for programming, but only a
      handful of languages for storing and transferring data. Even though its
      potential is virtually boundless, YAML was specifically created to work
      well for common use cases such as: configuration files, log files,
      interprocess messaging, cross-langauge data sharing, object persistence
      and debugging of complex data structures. When data is well organized
      and easy to understand, programming becomes a simpler task.
    </para>

    <sect1>
      <title><anchor id="intro-goals" />Goals</title>

      <para>
        The design goals for YAML are:
      </para>

      <orderedlist>
        <listitem>
          YAML documents are easily readable by humans.
        </listitem>
        <listitem>
          YAML uses the native data structures of agile languages.
        </listitem>
        <listitem>
          YAML data is portable between programming languages.
        </listitem>
        <listitem>
          YAML has a consistent model to support generic tools.
        </listitem>
        <listitem>
          YAML enables stream-based processing.
        </listitem>
        <listitem>
          YAML is expressive and extensible.
        </listitem>
        <listitem>
          YAML is easy to implement and use.
        </listitem>
      </orderedlist>
    </sect1>

    <sect1>
      <title><anchor id="intro-prior" />Prior Art</title>

      <para>
        YAML's initial direction was set by the data serialization and markup
        language discussions among <ulink
            url="http://www.docuverse.com/smldev/">SML-DEV</ulink> members.
        Later on it directly incorporated experience from Brian Ingerson's
        Perl module <ulink
            url="http://search.cpan.org/doc/INGY/Data-Denter-0.13/Denter.pod"
        >Data::Denter</ulink>. Since then YAML has matured through ideas
        and support from its user community.
      </para>

      <para>
        YAML integrates and builds upon concepts described by
        <ulink url="http://cm.bell-labs.com/cm/cs/cbook/index.html">C</ulink>,
        <ulink url="http://java.sun.com/">Java</ulink>, <ulink
        url="http://www.perl.org/">Perl</ulink>, <ulink
        url="http://www.python.org/">Python</ulink>, <ulink
        url="http://www.ruby-lang.org/">Ruby</ulink>, <ulink
        url="http://www.ietf.org/rfc/rfc0822.txt">RFC0822</ulink> (MAIL),
        <ulink
        url="http://www.ics.uci.edu/pub/ietf/html/rfc1866.txt">RFC1866</ulink>
        (HTML), <ulink
        url="http://www.ietf.org/rfc/rfc2045.txt">RFC2045</ulink> (MIME),
        <ulink url="http://www.ietf.org/rfc/rfc2396.txt">RFC2396</ulink> (URI),
        <ulink url="http://www.w3.org/TR/REC-xml.html">XML</ulink>,
        <ulink url="http://www.saxproject.org/">SAX</ulink> and <ulink
        url="http://www.w3.org/TR/SOAP">SOAP</ulink>.
      </para>

      <para>
        The syntax of YAML was motivated by Internet Mail (RFC0822) and
        remains partially compatible with that standard. Further, YAML
        borrows the idea of having <link linkend="c-l-yaml-stream">multiple
        documents</link> from MIME (RFC2045). YAML's top-level production
        is a <link linkend="preview-struct">stream</link> of independent
        documents; ideal for message-based distributed processing
        systems.
      </para>

      <para>
        YAML's indentation based <link linkend="syntax-indentation">block
            scoping</link> is similar to Python's (without the ambiguities
        caused by tabs). Indented blocks facilitate easy inspection of a
        document's structure. YAML's <link
            linkend="syntax-scalar-literal">literal</link> scalar leverages
        this by enabling formatted text to be cleanly mixed within an indented
        structure without troublesome escaping.
      </para>

      <para>
        YAML's <link linkend="syntax-scalar-double">double quoted</link>
        scalar uses familar C-style <link
        linkend="syntax-escape">escape sequences</link>. This enables
        ASCII representation of non-printable or 8-bit (ISO 8859-1)
        characters such as <link linkend="ns-esc-8-bit"
        ><quote><userinput>\x3B</userinput></quote></link>. 16-bit Unicode
        and 32-bit (ISO/IEC 10646) characters are supported with escape
        sequences such as <link linkend="ns-esc-16-bit"
        ><quote><userinput>\u003B</userinput></quote></link> and <link
        linkend="ns-esc-32-bit"
        ><quote><userinput>\U0000003B</userinput></quote></link>.
      </para>

      <para>
        Motivated by HTML's end-of-line normalization, YAML's <link
        linkend="syntax-scalar-folded">folded</link> scalar employs an
        intuitive method of handling white space. In YAML, single line breaks
        may be <link linkend="syntax-scalar-folding">folded</link> into a
        single space, while empty lines represent line break characters.
        This technique allows for paragraphs to be word-wrapped without
        affecting the canonical form of the content.
      </para>

      <para>
        YAML's core type system is based on the requirements
        of Perl, Python and Ruby. YAML directly supports both <link
        linkend="preview-collect">collection</link> (<link
        linkend="type-map">hash</link>, <link
        linkend="type-seq">array</link>) values and <link
        linkend="preview-scalar">scalar</link> (<link
        linkend="type-str">string</link>) values. Support for common types
        enables programmers to use their language's native data constructs
        for YAML manipulation, instead of requiring a special document
        object model (DOM).
      </para>

      <para>
        Like XML's SOAP, YAML supports serializing native graph structures
        through a rich <link linkend="model-alias">alias</link>
        mechanism. Also like SOAP, YAML provides for <link
        linkend="model-tag">application-defined types</link>. This
        allows YAML to encode rich data structures required for modern
        distributed computing. YAML provides unique global <link
        linkend="syntax-tag">type names</link> using a namespace
        mechanism inspired by Java's DNS based package naming convention and
        XML's URI based namespaces.
      </para>

      <para>
        YAML was designed to have an incremental interface that includes
        both a pull-style input stream and a push-style (SAX-like) output
        stream interfaces. Together this enables YAML to support the
        processing of large documents, such as a transaction log, or
        continuous streams, such as a feed from a production machine.
      </para>
    </sect1>

    <sect1>
      <title><anchor id="intro-xml" />Relation to XML</title>

      <para>
        Newcomers to YAML often search for its correlation to the eXtensible
        Markup Language (XML). While the two languages may actually compete
        in several application domains, there is no direct correlation
        between them.
      </para>

      <para>
        YAML is primarily a data serialization language. XML was designed to
        be backwards compatible with the Standard Generalized Markup
        Language (SGML) and thus had many design constraints placed on it
        that YAML does not share. Inheriting SGML's legacy, XML is designed
        to support structured documents, where YAML is more closely targeted
        at messaging and native data structures. Where XML is a pioneer in
        many domains, YAML is the result of lessons learned from XML and
        other technologies.
      </para>

      <para>
        It should be mentioned that there are ongoing efforts to define
        standard XML/YAML mappings. This generally requires that a subset of
        each language be used. For more information on using both XML and
        YAML, please visit <ulink url="http://yaml.org/xml/" />.
      </para>
    </sect1>

    <sect1>
      <title><anchor id="intro-term" />Terminology</title>

      <para>
        This specification uses key words in accordance with <ulink
        url="http://www.ietf.org/rfc/rfc2119.txt">RFC2119</ulink> to
        indicate requirement level. In particular, the following words are
        used to describe the actions of a YAML processor:
      </para>

      <variablelist>
        <varlistentry>
          <term><firstterm>may</firstterm></term>
	  <listitem>
            This word, or the adjective
            <quote><firstterm>optional</firstterm></quote>, mean that
            conformant YAML processors are permitted, but need not behave as
            described.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><firstterm>should</firstterm></term>
	    <listitem>
              This word, or the adjective
              <quote><firstterm>recommended</firstterm></quote>, mean that
              there could be reasons for a YAML processor to deviate from
              the behavior described, but that such deviation could hurt
              interoperability and should therefore be advertised with
              appropriate notice.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><firstterm>must</firstterm></term>
	    <listitem>
              This word, or the term
              <quote><firstterm>required</firstterm></quote> or
              <quote><firstterm>shall</firstterm></quote>, mean that the
              behavior described is an absolute requirement of the
              specification.
            </listitem>
          </varlistentry>
      </variablelist>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="preview" />Preview</title>

    <para>
      This section provides a quick glimpse into the expressive power of
      YAML. It is not expected that the first-time reader grok all of the
      examples. Rather, these selections are used as motivation for the
      remainder of the specification.
    </para>

    <sect1>
      <title><anchor id="preview-collect" />Collections</title>

      <para>
        YAML's block collections use indentation for scope and begin each
        member on its own line. Block sequences indicate each member with a
        dash&nbsp;(<quote><userinput>-</userinput></quote>). Block mappings
        use a colon to mark each (key:&nbsp;value) pair.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Sequence of scalars<sbr />
              (ball players)
            </title>
<programlisting>
- Mark McGwire
- Sammy Sosa
- Ken Griffey
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Mapping of scalars to scalars<sbr />
              (player statistics)
            </title>
<programlisting>
hr:  65
avg: 0.278
rbi: 147
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Mapping of scalars to sequences<sbr />
              (ball clubs in each league)
            </title>
<programlisting>
american:
  - Boston Red Sox
  - Detroit Tigers
  - New York Yankees
national:
  - New York Mets
  - Chicago Cubs
  - Atlanta Braves
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Sequence of mappings<sbr />
              (players' statistics)
            </title>
<programlisting>
-
  name: Mark McGwire
  hr:   65
  avg:  0.278
-
  name: Sammy Sosa
  hr:   63
  avg:  0.288
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        YAML also has in-line flow styles for compact notation. The flow
        sequence is written as a comma separated list within square
        brackets. In a similar manner, the flow mapping uses curley braces.
        In YAML, the space after the <quote><userinput>-</userinput></quote>
        and  <quote><userinput>:</userinput></quote> and
        <quote><userinput>:</userinput></quote> is mandatory.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Sequence of sequences</title>
<programlisting>
- [name        , hr, avg  ]
- [Mark McGwire, 65, 0.278]
- [Sammy Sosa  , 63, 0.288]


</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Mapping of mappings</title>
<programlisting>
Mark McGwire: {hr: 65, avg: 0.278}
Sammy Sosa: {
    hr: 63,
    avg: 0.288
  }
</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-struct" />Structures</title>

      <para>
        YAML uses three
        dashes&nbsp;(<quote><userinput>---</userinput></quote>) to separate
        documents within a stream. Comment lines begin with the pound
        sign&nbsp;(<quote><userinput>#</userinput></quote>). Three
        dots&nbsp;(<quote><userinput>...</userinput></quote>) indicate the
        end of a document without starting a new one, for use in
        communication channels.
      </para>

      <para>
        Repeated nodes are first marked with the
        ampersand&nbsp;(<quote><userinput>&amp;</userinput></quote>) and
        then referenced with an
        asterisk&nbsp;(<quote><userinput>*</userinput></quote>) thereafter.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              Two documents in a stream<sbr />
              each with a leading comment
            </title>
<programlisting>
# Ranking of 1998 home runs
---
- Mark McGwire
- Sammy Sosa
- Ken Griffey

# Team ranking
---
- Chicago Cubs
- St Louis Cardinals
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Play by play feed<sbr />
              from a game
            </title>
<programlisting>
---
time: 20:03:20
player: Sammy Sosa
action: strike (miss)
...
---
time: 20:03:47
player: Sammy Sosa
action: grand slam
...
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Single document with two comments<sbr />
              &nbsp;
            </title>
<programlisting>
---
hr: # 1998 hr ranking
  - Mark McGwire
  - Sammy Sosa
rbi:
  # 1998 rbi ranking
  - Sammy Sosa
  - Ken Griffey
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Node for <quote><userinput>Sammy Sosa</userinput></quote><sbr />
              appears twice in this document
            </title>
<programlisting>
---
hr:
  - Mark McGwire
  # Following node labeled SS
  - &amp;SS Sammy Sosa
rbi:
  - *SS # Subsequent occurance
  - Ken Griffey
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        The question mark indicates a complex key. Within a block sequence,
        mapping pairs can start immediately following the dash.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Mapping between sequences</title>
<programlisting>
? # PLAY SCHEDULE
  - Detroit Tigers
  - Chicago Cubs
:
  - 2001-07-23

? [ New York Yankees,
    Atlanta Braves ]
: [ 2001-07-02, 2001-08-12,
    2001-08-14 ]
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Sequence key shortcut</title>
<programlisting>
---
# products purchased
- item    : Super Hoop
  quantity: 1
- item    : Basketball
  quantity: 4
- item    : Big Shoes
  quantity: 1


</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-scalar" />Scalars</title>

      <para>
        Scalar values can be written in block form using a literal
        style&nbsp;(<quote><userinput>|</userinput></quote>) where all new
        lines count. Or they can be written with the folded
        style&nbsp;(<quote><userinput>&gt;</userinput></quote>) for content
        that can be word wrapped. In the folded style, newlines are treated as
        a space unless they are part of a blank or indented line.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>
              In literals,<sbr />
              newlines are preserved
            </title>
<programlisting>
# ASCII Art
--- |
  \//||\/||
  // ||  ||__
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              In the plain scalar,<sbr />
              newlines are treated as a space
            </title>
<programlisting>
---
  Mark McGwire's
  year was crippled
  by a knee injury.
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Folded newlines preserved<sbr />
              for indented and blank lines
            </title>
<programlisting>
--- &gt;
 Sammy Sosa completed another
 fine season with great stats.

   63 Home Runs
   0.288 Batting Average

 What a year!
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>
              Indentation determines scope<sbr />
              &nbsp;
            </title>
<programlisting>
name: Mark McGwire
accomplishment: &gt;
  Mark set a major league
  home run record in 1998.
stats: |
  65 Home Runs
  0.278 Batting Average

</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        YAML's flow scalars include the plain style (most examples thus far)
        and quoted styles. The double quoted style provides escape sequences.
        Single quoted style is useful when escaping is not needed. All flow
        scalars can span multiple lines; intermediate whitespace is trimmed to
        a single space.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Quoted scalars</title>
<programlisting>
unicode: "Sosa did fine.\u263A"
control: "\b1998\t1999\t2000\n"
hexesc:  "\x13\x10 is \r\n"

single: '"Howdy!" he cried.'
quoted: ' # not a ''comment''.'
tie-fighter: '|\-*-/|'
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Multiline flow scalars</title>
<programlisting>
plain:
  This unquoted scalar
  spans many lines.

quoted: "So does this
  quoted scalar.\n"

</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-tag" />Tags</title>

      <para>
        In YAML, plain (unquoted) scalars are given an implicit type
        depending on the application. The examples in this specification use
        types from YAML's <link linkend="tag-repository">tag
        repository</link>, which includes types like integers, floating point
        values, timestamps, null, boolean, and string values.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Integers</title>
<programlisting>
canonical: 12345
decimal: +12,345
sexagecimal: 3:25:45
octal: 014
hexadecimal: 0xC

</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Floating point</title>
<programlisting>
canonical: 1.23015e+3
exponential: 12.3015e+02
sexagecimal: 20:30.15
fixed: 1,230.15
negative infinity: (-inf)
not a number: (NaN)
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Miscellaneous</title>
<programlisting>
null: ~
true: y
false: n
string: '12345'
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Timestamps</title>
<programlisting>
canonical: 2001-12-15T02:59:43.1Z
iso8601:  2001-12-14t21:59:43.10-05:00
spaced:  2001-12-14 21:59:43.10 -05:00
date:   2002-12-14
</programlisting>
          </example>
        </member>
      </simplelist>

      <para>
        Explicit typing is denoted with a tag using the
        bang&nbsp;(<quote><userinput>!</userinput></quote>) symbol. Application
        tags should include a domain name and may use the
        caret&nbsp;(<quote><userinput>^</userinput></quote>) to abbreviate
        subsequent tags. 
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Various explicit tags</title>
<programlisting>
---
not-date: !str 2002-04-28

picture: !binary |
 R0lGODlhDAAMAIQAAP//9/X
 17unp5WZmZgAAAOfn515eXv
 Pz7Y6OjuDg4J+fn5OTk6enp
 56enmleECcgggoBADs=

application specific tag: !!something |
 The semantics of the tag
 above may be different for
 different documents.

</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Application specific tag</title>
<programlisting>
# Establish a tag prefix
--- !clarkevans.com,2002/graph/^shape
  # Use the prefix: shorthand for
  # !clarkevans.com,2002/graph/circle
- !^circle
  center: &amp;ORIGIN {x: 73, y: 129}
  radius: 7
- !^line
  start: *ORIGIN
  finish: { x: 89, y: 102 }
- !^label
  start: *ORIGIN
  color: 0xFFEEBB
  value: Pretty vector drawing.
</programlisting>
          </example>
        </member>
      </simplelist>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Unorderd set</title>
<programlisting>
# sets are represented as a
# mapping where each key is
# associated with the empty string
--- !set
? Mark McGwire
? Sammy Sosa
? Ken Griff
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Ordered mappings</title>
<programlisting>
# ordered maps are represented as
# a sequence of mappings, with
# each mapping having one key
--- !omap
- Mark McGwire: 65
- Sammy Sosa: 63
- Ken Griffy: 58
</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>

    <sect1>
      <title><anchor id="preview-full" />Full Length Example</title>

      <para>
        Below are two full-length examples of YAML. On the left is a sample
        invoice; on the right is a sample log file.
      </para>

      <simplelist type="horiz" columns="2">
        <member>
          <example>
            <title>Invoice</title>
<programlisting>
--- !clarkevans.com,2002/^invoice
invoice: 34843
date   : 2001-01-23
bill-to: &amp;id001
    given  : Chris
    family : Dumars
    address:
        lines: |
            458 Walkman Dr.
            Suite #292
        city    : Royal Oak
        state   : MI
        postal  : 48046
ship-to: *id001
product:
    - sku         : BL394D
      quantity    : 4
      description : Basketball
      price       : 450.00
    - sku         : BL4438H
      quantity    : 1
      description : Super Hoop
      price       : 2392.00
tax  : 251.42
total: 4443.52
comments:
    Late afternoon is best.
    Backup contact is Nancy
    Billsmer @ 338-4338.
</programlisting>
          </example>
        </member>

        <member>
          <example>
            <title>Log file</title>
<programlisting>
---
Time: 2001-11-23 15:01:42 -05:00
User: ed
Warning:
  This is an error message
  for the log file
---
Time: 2001-11-23 15:02:31 -05:00
User: ed
Warning:
  A slightly different error
  message.
---
Date: 2001-11-23 15:03:17 -05:00
User: ed
Fatal:
  Unknown variable "bar"
Stack:
  - file: TopClass.py
    line: 23
    code: |
      x = MoreObject("345\n")
  - file: MoreClass.py
    line: 58
    code: |-
      foo = bar



</programlisting>
          </example>
        </member>
      </simplelist>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="model" />Processing YAML Information</title>

    <para>
      YAML is both a text format and a method for representing native
      language data structures in this format. This specification defines
      two concepts: a class of data objects called YAML representations, and
      a syntax for encoding YAML representations as a series of
      characters, called a YAML stream. A YAML
      <firstterm>processor</firstterm> is a tool for converting information
      between these complementary views. It is assumed that a YAML processor
      does its work on behalf of another module, called an
      <firstterm>application</firstterm>. This chapter describes the
      information structures a processor must provide to or obtain from the
      application.
    </para>

    <para>
      YAML information is used in two ways: for machine processing, and
      for human consumption. The challange of reconciling these two
      perspectives is best done in three distinct translation stages:
      representation, serialization, and presentation. Representation
      addresses how YAML views native language data structures to achieve
      portability between programming environments. Serialization
      concerns itself with turning a YAML representation into a serial
      form, that is, a form with sequential access constraints.
      Presentation deals with the formatting of a YAML serialization as a
      stream of characters, in a manner friendly to humans.
    </para>

    <figure>
      <title>YAML Overview</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="overview.eps" format="eps" />
        </imageobject>
        <imageobject>
          <imagedata fileref="overview.png" format="png" />
        </imageobject>
      </mediaobject>
    </figure>

    <para>
      A processor need not expose the serialization or representation
      stages. It may translate directly between native objects and
      a character stream and (<quote>dump</quote> and <quote>load</quote>
      in the diagram above). However, such a direct translation should
      take place so that the native objects are constructed only from
      information available in the representation.
    </para>

    <sect1>
      <title><anchor id="model-processes" />Processes</title>

      <para>
        This section details the processes shown in the 
        diagram above.
      </para>

      <sect2>
        <title><anchor id="model-processes-represent" />Represent</title>

        <para>
          YAML representations model the data constructs from agile
          programming languages, such as Perl, Python, or Ruby. YAML
          representations view native language data objects in a generic
          manner, allowing data to be portable between various programming
          languages and implementations. Strings, arrays, hashes, and other
          user-defined types are supported. This specification formalizes
          what it means to be a YAML representatation and suggests how
          native language objects can be viewed as a YAML representation.
        </para>

        <para>
          YAML representations are constructed with three primitives: the
          <link linkend="model-sequence" >sequence</link>, the <link
          linkend="model-mapping" >mapping</link> and the <link
          linkend="model-scalar" >scalar</link>. By sequence we mean
          an ordered collection, by mapping we mean an unordered association
          of unique keys to values, and by scalar we mean any object with
          opaque structure yet expressable as a series of unicode
          characters. When used generatively, these primitives construct
          directed graph structures. These primitives were chosen beacuse
          they are both powerful and familiar: the sequence corresponds to a
          Perl array and a Python list, the mapping corresponds to a Perl
          hashtable and a Python dictionary. The scalar represents strings,
          integers, dates and other atomic data types.
        </para>

        <para>
          YAML represents any native language data object as one of these
          three primitives, together with a type specifier called a
          <firstterm>tag</firstterm>. Type specifiers are either global,
          using a syntax based on the domain name and registration date, or
          private in scope. For example, an integer is represented in YAML
          with a scalar plus a globally scoped
          <userinput>tag:yaml.org,2002/int</userinput> tag. Similarly, an
          invoice object, particular to a given organization, could be
          represented as a mapping together with a
          <userinput>tag:private.yaml.org,2002:invoice</userinput> tag. This
          simple model, based on the sequence and mapping and scalar
          together with a type specifier, can represent any data structure
          independent of programming language.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-serialize" />Serialize</title>

        <para>
          For sequential access mediums, such as an
          event callback API, a YAML representation must be serialized to an
          ordered tree. Serialization is necessary since nodes in a YAML
          representation may be referenced more than once (more than one
          incoming arrow) and since mapping keys are unordered. Serialization
          is accomplished by imposing an ordering on mapping keys and by
          replacing the second and subsequent references to a given node with
          place holders called aliases. The result of this process, the YAML
          serialization tree, can then be traversed to produce a series of
          event calls for one-pass processing of YAML data.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-present" />Present</title>

        <para>
          YAML <firstterm>character streams</firstterm> (or documents)
          encode YAML representations into a series of characters. Some of
          the characters in a YAML stream represent the content of the
          source information, while other characters are used for
          presentation style. Not only must YAML character streams store
          YAML representations, they must do so in a manner which is human
          friendly.
        </para>

        <para>
          To address human presentation, the YAML syntax has a rich set of
          stylistic options which go far beyond the needs of data
          serialization. YAML has two approaches for expressing a node's
          nesting, one that uses indentation to designate depth in the
          serialization tree and another which uses begin and end
          delimiters. Depending upon escaping and how line breaks should be
          treated, YAML scalars may be written with many different styles.
          YAML syntax also has a comment mechanism for annotations othogonal
          to the <quote>content</quote> of a YAML representation. These
          presentation level details provide sufficient variety of
          expression.
        </para>

        <para>
          In a similar manner, for human readable text, it is frequently
          desirable to omit data typing information which is often obvious
          to the human reader and not needed. This is especially true if the
          information is created by hand, expecting humans to bother with
          data typing detail is optimistic. Implicit type information may be
          restored using a data schema or similar mechanisms.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-parse" />Parse</title>

        <para>
          Parsing is the inverse process of presentation, it takes
          a stream of characters and produces a series of events.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-compose" />Compose</title>

        <para>
          Composing takes a series of events and produces a node graph
          representation.  See <link
          linkend="model-complete">completeness</link> for more detail
          on the constraints composition must follow.  When composing,
          one must deal with broken aliases and anchors, and other
          things of this sort.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-processes-construct" />Construct</title>

        <para>
          Construction converts construct YAML representations into native
          language objects.
        </para>
      </sect2>

    </sect1>

    <sect1>
      <title><anchor id="model-models" />Information Models</title>

      <para>
        This section has the formal details of the results of
        the processes.
      </para>

      <figure>
        <title>YAML Information Models</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="model.eps" format="eps" />
          </imageobject>
          <imageobject>
            <imagedata fileref="model.png" format="png" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        To maximize data portability between programming languages and
        implementations, users of YAML should be mindful of the distinction
        between serialization or presentation properties and those which are
        part of the YAML representation. While imposing a order on mapping
        keys is necessary for flattening YAML representations to a
        sequential access medium, the specific ordering of a mapping should
        not be used to convey application level information. In a similar
        manner, while indentation technique or the specific scalar style is
        needed for character level human presentation, this syntax detail is
        not part of a YAML serialization nor a YAML representation. By
        carefully separating properties needed for serialization and
        presentation, YAML representations of native language information
        will be consistent and portable between various programming
        environments.
      </para>

      <sect2>
        <title><anchor id="model-representation" />Node Graph
        Representation</title>

        <para>
          In YAML's view, native data is represented as a directed
          graph of <link linkend="model-tag">tagged</link> <link
          linkend="model-node">nodes</link>. Nodes that are defined in
          terms of other nodes are <link
          linkend="model-collection">collections</link> and nodes that are
          defined independent of any other nodes are <link
          linkend="model-scalar">scalars</link>. YAML supports two
          kinds of collection nodes, <link
          linkend="model-sequence">sequence</link> and <link
          linkend="model-mapping">mappings</link>. Mapping nodes
          are somewhat tricky beacuse its keys are considered to be unordered
          and <link linkend="model-equality">unique</link>.
        </para>

        <figure>
          <title>YAML Representation</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="represent.eps" format="eps" />
            </imageobject>
            <imageobject>
              <imagedata fileref="represent.png" format="png" />
            </imageobject>
          </mediaobject>
        </figure>

        <sect3>
          <title><anchor id="model-node" />Nodes</title>
          <para>
            A YAML representation is a rooted, connected, directed graph. By
            <quote>directed graph</quote> we mean a set of nodes and arrows,
            where arrows connect one node to another (<ulink
            url="http://www.nist.gov/dads/HTML/directedgraph.html"> a formal
            definition </ulink>). Note that the YAML graph may include cycles,
            and a node may have more than one incoming arrow.
         </para>

          <para>
            YAML nodes have a <link linkend="model-tag">tag</link> and
            can be of one of three kinds: scalar, sequence, or mapping. The
            node's tag serves to restrict the set of possible values
            which the node can have.
          </para>

          <variablelist>
            <varlistentry>
              <term>
                <anchor id="model-scalar" />
                <firstterm>scalar</firstterm>
              </term>
              <listitem>
                <para>
                  A scalar is a series of zero or more Unicode characters.
                  YAML places no restriction on the length or content of the
                  series.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <anchor id="model-sequence" />
                <firstterm>sequence</firstterm>
              </term>
              <listitem>
                <para>
                  A sequence is a series of zero or more nodes. In
                  particular, a sequence may contain the same node more than
                  once or it could even contain itself (directly or indirectly).
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <anchor id="model-mapping" />
                <firstterm>mapping</firstterm>
              </term>
              <listitem>
                <para>
                  A mapping is an unordered set of key/value node pairs, with
                  the restriction that each of the keys is unique. This
                  restriction has non-trivial implications detailed
                  <link linkend="model-equality">below</link>.
                  YAML places no further restrictions on the nodes. In
                  particular, keys may be arbitrary nodes, the same node may
                  be used as a value in several pairs, and a mapping could
                  even contain itself as a key or a value (directly or
                  indirectly).
                </para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>
            <anchor id="model-collection" />When appropriate, it is convient
            to consider sequences and mappings together, as a
            <firstterm>collection</firstterm>. In this view, sequences are
            treated as mappings with integer keys starting at zero. Having a
            unified collections view for sequences and mappings is helpful for
            both constructing practical YAML tools and APIs and for
            theoretical analysis.
          </para>

          <para>
            YAML allows several representations to be encoded
            to the same character stream. Representations appearing in the
            same character stream are independent. That is, a given node may
            not appear in more than one representation graph.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-tag" />Tags</title>

          <para>
            YAML represents type information of native objects with a simple
            identifier, called a <firstterm>tag</firstterm>. These identifiers
            are <ulink url="http://www.ietf.org/rfc/rfc2396.txt">URIs</ulink>,
            using a subset of the <quote><userinput>tag</userinput></quote>
            URI scheme. YAML tags use only the domain based form,
            <userinput>tag:</userinput><varname>domain</varname><userinput>,</userinput><varname>date</varname><userinput>:</userinput><varname>identifier</varname>,
            for example, <userinput>tag:yaml.org,2002:str</userinput>. YAML
            presentations provide several <link
            linkend="syntax-tag">mechanisms</link> to make this less
            verbose. Tags may be minted by those who own the domain at the
            specified date. The day must be omitted if it is the 1st of the
            month, and the month and day must be omitted for January 1st.
            The year is never omitted. Thus, each YAML tag has a single
            globally unique representation. More information on this URI
            scheme can be found at <ulink url="http://www.taguri.org"/>
            (<ulink url="http://yaml.org/spec/taguri.txt">mirror</ulink>).
          </para>

          <para>
            <anchor id="model-private"/>YAML tags can be either globally
            unique, or private to a single representation graph. Private tags
            start with <userinput>tag:private.yaml.org,2002:</userinput>.
            Clearly private tags are not globally unique, since the domain
            name and the date are fixed.
          </para>

          <para>
            YAML does not mandate any special relationship between different
            tags that begin with the same substring.  Tags ending URI fragments
            (containing <quote><userinput>#</userinput></quote>) are no
            exception. Tags that share the same base URI but differ in their
            fragment part are considered to be different, independent tags. By
            convention, fragments are used to identify different
            <quote>versions</quote> of a tag, while
            <quote><userinput>/</userinput></quote> is used to define nested
            tag <quote>namespace</quote> hierarchies. However, this is merely
            a convention, and each tag may employ its own rules.
            For example,
            <userinput>tag:perl.yaml.org,2002:</userinput> tags
            use <quote><userinput>::</userinput></quote> to express namespace
            hierarchies,
            <userinput>tag:java.yaml.org,2002:</userinput> tags
            use <quote><userinput>.</userinput></quote>, etc.
          </para>

          <para>
            YAML tags are used to associate meta information with each node.
            In particular, each tag is required to specify a the <link
            linkend="model-node">kind</link> (scalar, sequence, or mapping)
            it applies to. Scalar tags must also provide mechanism for
            converting values to a <link linkend="model-canonical">canonical
            form</link> for supporting <link
            linkend="model-equality">equality testing</link>. Furthermore, a
            tag may provide additional information such as the set of
            allowed values for validation, a mechanism for <link
            linkend="model-resolve">implicit typing</link>, or any other
            data that is applicable to all of the tag's nodes.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-equality" />Equality</title>

          <para>
            Since YAML mappings require key uniqueness, representations must
            include a mechanism for testing the equality of nodes. This is
            non-trivial since YAML <link
            linkend="model-presentation">presentations</link> allow various
            ways to write a given <link linkend="model-scalar">scalar</link>.
            For example, the integer ten can be written as
            <userinput>10</userinput> or <userinput>0xA</userinput> (hex). If
            both forms are used as a key in the same mapping, only a YAML
            processor which <quote>knows</quote> about integer tags and their
            presentation formats would correctly flag the duplicate key
            as an error.
          </para>

          <variablelist>
            <varlistentry>
              <term>
                <anchor id="model-canonical" />
                <firstterm>canonical form</firstterm>
              </term>
              <listitem>
                <para>
                  YAML supports the need for scalar equality by requiring that
                  every scalar <link linkend="model-tag">tag</link> have a
                  mechanism to produce a canonical form
                  of its scalars. By canonical form, we mean a Unicode
                  character string which represents the scalar's content and
                  can be used for equality testing. While this requirement is
                  stronger than a well defined equality operator, it has other
                  uses, such as the production of digital signatures.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <anchor id="model-equal" />
                <firstterm>equality</firstterm>
              </term>
              <listitem>
                <para>
                   Two nodes must have the same <link
                   linkend="model-tag">tag</link> and value to be equal. Since
                   each tag applies to exactly one kind, this implies that the
                   two nodes must have the same kind to be equal. Two <link
                   linkend="model-scalar">scalar</link> nodes are equal only
                   when their <link linkend="model-canonical">canonical</link>
                   values are character-by-character equivalent. Equality of
                   <link linkend="model-collection">collections</link> is
                   defined recursively. Two <link
                   linkend="model-sequence">sequences</link> are equal only
                   when they have the same length and each node in one
                   sequence is equal to the corresponding node in the other
                   sequence. Two <link linkend="model-mapping">mappings</link>
                   are equal only when they have equal sets of keys, and each
                   key in this set is associated with equal values in both
                   mappings.
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <anchor id="model-identity" />
                <firstterm>identity</firstterm>
              </term>
              <listitem>
                <para>
                  Node equality should not be confused with node
                  <firstterm>identity</firstterm>. Two nodes are identical
                  only when they represent the same native object. Typically,
                  this corresponds to a single memory address. During
                  <ulink linkend="model-serialize">serialization</ulink>, equal
                  scalar nodes may be treated as if they were identical. In
                  contrast, the seperate identity of two distinct, but equal,
                  collection nodes must be preserved.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="model-serialize" />Event / Tree Serialization</title>

        <para>
          To express a YAML representation using a serial API, it necessary to
          impose an order on mapping keys and employ alias nodes to indicate a
          subsequent occurence of a previously encountered node. The result of
          this serialization process is a tree structure, where each branch
          has an ordered set of children. This tree can be traversed for a
          serial event based API. Construction of native structures from the
          serial interface should not use key order or anchors for the
          preservation of important data.
        </para>

        <figure>
          <title>YAML Serialization</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="serialize.eps" format="eps" />
            </imageobject>
            <imageobject>
              <imagedata fileref="serialize.png" format="png" />
            </imageobject>
          </mediaobject>
        </figure>

        <sect3>
          <title><anchor id="model-key-order" />Key Order</title>

          <para>
            In the representation model, keys in a
            <link linkend="model-mapping">mapping</link> do not have order.
            To serialize a mapping, it is necessary to impose an ordering on
            its keys. This order should not be used when composing a
            representation graph from serialized events.
          </para>

          <para>
            In every case where node order is significant, a sequence must be
            used. For example, an ordered mapping can be represented by a
            sequence of mappings, where each mapping is a single key/value
            pair. YAML presentations provide convient shorthand syntax
            for this case.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-alias" />Aliases</title>

          <para>
            In the representation model, a node may appear in more than one
            context. When serializing such nodes, the first occurance of the
            node is serialized with an <firstterm>anchor</firstterm> and
            subsequent occurances are serialized as an
            <firstterm>alias</firstterm> which specifies the same anchor.
            Anchors need not be unique within a serialization. When composing a
            representation graph from serialized events, alias nodes refer to
            the most recent node in the serialization having the specified anchor.
          </para>

          <para>
            An anchored node need not have an alias referring to it. It is
            therefore possible to provide an anchor for all nodes in
            serialization. After composing a representation graph, the
            anchors are discarded. Hence, anchors must not be used for
            encoding application data.
          </para>
        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="model-presentation" />Character Stream
        Presentation</title>

        <para>
          YAML presentations make use of styles, comments, directives and
          other syntactical details. Although the processor may provide this
          information, these features should not be used when constructing
          native structures.
        </para>

        <figure>
          <title>YAML Presentation</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="present.eps" format="eps" />
            </imageobject>
            <imageobject>
              <imagedata fileref="present.png" format="png" />
            </imageobject>
          </mediaobject>
        </figure>

        <sect3>
          <title><anchor id="model-style" />Styles</title>

          <para>
            In the syntax, each node has an additional
            <firstterm>style</firstterm> property, depending on its <link
            linkend="model-node">node</link>. There are two types of styles,
            <firstterm>block</firstterm> and <firstterm>flow</firstterm>.
            Block styles use indentation to denote nesting and scope within
            the presentation. In contrast, flow styles rely on explicit
            markers to denote nesting and scope.
          </para>

          <para>
            YAML provides several shorthand forms for collection styles,
            allowing for compact nesting of collections in common cases. For
            compact set notation, null mapping values may be omitted. For
            compact ordered mapping notation, a mapping with a single
            key:value pair may be specified directly inside a flow sequence
            collection. Also, simple block collections may begin in-line
            rather than the next line.
          </para>

          <para>
            YAML provides a rich set of scalar style variants. Scalar block
            styles include the literal and folded styles; scalar flow styles
            include the plain, single quoted and double quoted styles. These
            styles offer a range of tradeoffs between expressive power and
            readability.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-comment" />Comments</title>

          <para>
            The syntax allows optional <firstterm>comment</firstterm> blocks
            to be interleaved with the node blocks. Comment blocks may appear
            before or after any node block. A comment block can't appear
            inside a scalar node value.
          </para>
        </sect3>

        <sect3>
          <title><anchor id="model-directive" />Directives</title>

          <para>
            Each document may be associated with a set of directives. A
            <firstterm>directive</firstterm> is a key:value pair where both
            the key and the value are simple strings. Directives are
            instructions to the YAML processor, allowing for extending YAML in
            the future. This version of YAML defines a single directive,
            <quote><userinput>YAML</userinput></quote>. Additional directives
            may be added in future versions of YAML. A processor should ignore
            unknown directives with an appropriate warning. There is no
            provision for specifying private directives. This is intentional.
          </para>

          <para>
            The <quote><userinput>YAML</userinput></quote> directive specifies
            the version of YAML the document adheres to. This specification
            defines version <userinput>1.0</userinput>. A version 1.0
            processor should accept documents with an explicit
            <quote><userinput>%YAML:1.0</userinput></quote> directive, as well
            as documents lacking a <quote><userinput>YAML</userinput></quote>
            directive. Documents with a directive specifying a higher minor
            version (e.g. <quote><userinput>%YAML:1.1</userinput></quote>)
            should be processed with an appropriate warning. Documents with a
            directive specifying a higher major version (e.g.
            <quote><userinput>%YAML:2.0</userinput></quote>) should be
            rejected with an appropriate error message.
          </para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="model-complete"/>Completeness</title>

      <para>
        The process of converting YAML information from a character
        stream presentation to a native data structure has several
        potential failure points. The character stream may be ill-formed,
        implicit tags may be unresolvable, tags may be unrecognized,
        the content may be invalid, and a native type may be unavailable.
        Each of these failures results with an incomplete conversion.
      </para>

      <para><anchor id="model-partial" />
        A <firstterm>partial representation</firstterm> need not specify the
        tag of each node, and the canonical form of scalar values need not
        be available.  This weaker representation is useful for cases of
        incomplete knowledge of tags used in the document.
      </para>

      <figure>
        <title>YAML Completeness</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="validity.eps" format="eps" />
          </imageobject>
          <imageobject>
            <imagedata fileref="validity.png" format="png" />
          </imageobject>
        </mediaobject>
      </figure>

      <sect2>
        <title><anchor id="model-well-formed" />Well-Formed</title>
        <para>
          A <firstterm>well-formed</firstterm> character stream must match
          the productions specified in the next chapter. A YAML processor
          should reject <firstterm>ill-formed</firstterm> input. A
          processor may recover from syntax errors, but it must provide a
          mechanism for reporting such errors.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-resolve" />Resolved</title>

        <para>
          It is not required that all tags in a complete YAML representation
          be explicitly specified in the character stream presentation. In
          this case, these <firstterm>implicit tags</firstterm> must be
          <firstterm>resolved</firstterm>.
        </para>

        <para>
          When resolving tags, a YAML processor must only rely upon
          representation details, with one notable exception. It may
          consider whether a scalar was written in the plain style when
          resolving the scalar's tag. Other than this exception, the
          processor must not rely upon presentation or serialization
          details. In particular, it must not consider key order, anchors,
          styles, spacing, indentation or comments.
        </para>

        <para>
          The plain scalar style exception allows unquoted values to signify
          numbers, dates, or other typed data, while quoted values are
          treated as generic strings. With this exception, a processor may
          match plain scalars against a set of regular expressions, to
          provide automatic resolution of such types without an explict tag.
        </para>

        <para>
          If a document contains <firstterm>unresolved</firstterm> nodes,
          the processor is unable to compose a complete representation
          graph. However, the processor may compose an <link
          linkend="model-partial">partial representation</link>, based on
          each node's <link linkend="model-node">kind</link> (mapping,
          sequence, scalar) and allowing for unresolved tags.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-recognized" />
               <anchor id="model-valid" />Recognized and Valid</title>

        <para>
          To be <firstterm>valid</firstterm>, a node must have a tag which
          is <firstterm>recognized</firstterm> by the processor and its
          value must satisfy the constraints imposed by its tag. If a
          document contains a scalar node with an
          <firstterm>unrecognized</firstterm> tag or an
          <firstterm>invalid</firstterm> value, only a <link
          linkend="model-partial">partial representation</link> may be
          composed. In constrast, a processor can always compose a complete
          YAML representation for an unrecognized or an invalid collection,
          since collection <link linkend="model-equality">equality</link>
          does not depend upon the collection's data type.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="model-available"/>Available</title>
        <para>
          In a given processing environment, there may not be an
          <firstterm>available</firstterm> native type corresponding to a
          given tag. If a node's tag is <firstterm>unavailable</firstterm>,
          a YAML processor will not be able to construct a native data
          structure for it. In this case, a complete YAML representation may
          still be composed, and an application may wish to use this
          representation directly.
        </para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title><anchor id="syntax" />Syntax</title>

      <para>
        Following are the BNF productions defining the syntax of YAML
        character streams. The productions introduce the relevant character
        classes, describe the processing of white space, and then follow
        with the decomposition of the stream into logical chunks. To make
        this chapter easier to follow, production names use Hungarian-style
        notation:
      </para>

      <variablelist>
        <varlistentry>
          <term><userinput>c-</userinput></term>
          <listitem>
            a production matching a single special character
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>b-</userinput></term>
          <listitem>
            a production matching a single line break
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>nb-</userinput></term>
          <listitem>
            a production matching a single non-break character
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>s-</userinput></term>
          <listitem>
            a production matching a single non-break space character
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>ns-</userinput></term>
          <listitem>
            a production matching a single non-break non-space character
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>i-</userinput></term>
          <listitem>
            a production matching indentation spaces
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>X</varname><userinput>-</userinput><varname>Y</varname><userinput>-</userinput></term>
          <listitem>
            a production matching a sequence of characters, starting with an
            <varname>X</varname><userinput>-</userinput> production and ending
            with a <varname>Y</varname><userinput>-</userinput> production
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><userinput>l-</userinput></term>
          <listitem>
            a production matching a single line (shorthand for
            <userinput>i-b-</userinput>)
          </listitem>
        </varlistentry>
      </variablelist>

    <sect1>
      <title><anchor id="syntax-char" />Characters</title>

      <sect2>
        <title><anchor id="syntax-char-set" />Character Set</title>

        <para>
          YAML streams use a subset of the Unicode character set. On input,
          a YAML processor must accept all printable ASCII characters, the
          space, tab, line break, and all Unicode characters beyond 0x9F. On
          output, a YAML processor must only produce those acceptable
          characters, and should also <link
          linkend="syntax-escape">escape</link> all non-printable
          Unicode characters.
        </para>

        <productionset>
          <production id="c-printable">
            <lhs>c-printable</lhs>
            <rhs>
              <lineannotation>characters as defined by the Unicode standard,
              excluding most control characters and the surrogate
              blocks</lineannotation>
              &nbsp;&nbsp;#x9 | #xA | #xD<sbr />
              | [#x20-#x7E] | #x85<sbr />
              | [#xA0-#xD7FF]<sbr />
              | [#xE000-#xFFFD]<sbr />
              | [#x10000-#x10FFFF]
            </rhs>
          </production>
        </productionset>

        <para>
          This character range explicitly excludes the surrogate block
          <userinput>[#xD800-#xDFFF]</userinput>, DEL
          <userinput>0x7F</userinput>, the C0 control block
          <userinput>[#x0-#x1F]</userinput>, the C1 control block
          <userinput>[#x80-#x9F]</userinput>, <userinput>#xFFFE</userinput>
          and <userinput>#xFFFF</userinput>. Note that in UTF-16, characters
          above <userinput>#xFFFF</userinput> are represented with a surrogate
          pair. When present, DEL and characters in the C0 and C1 control block
          must be represented in a YAML stream using escape sequences.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="syntax-encode" />Encoding</title>

        <para>
          A YAML processor must support the UTF-16 and UTF-8 character
          encodings. If an input stream does not begin with a <link
          linkend="c-byte-order-mark">byte order mark</link>, the encoding
          shall be UTF-8. UTF-16 (LE or BE) or UTF-8, as signaled by the
          byte order mark. Since YAML files may only contain
          printable characters, this does not raise any ambiguities. For
          more information about the byte order mark and the Unicode
          character encoding schemes see the Unicode <ulink
          url="http://www.unicode.org/unicode/faq/utf_bom.html">FAQ</ulink>.
        </para>

        <productionset>
          <production id="c-byte-order-mark">
            <lhs>c-byte-order-mark</lhs>
            <rhs>
              <lineannotation>unicode BOM</lineannotation>
              #xFEFF
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-indicator" />Indicators</title>

        <para>
          Indicators are special characters that are used to describe the
          structure of a YAML document. In general, they cannot be used as
          the first character of a <link linkend="syntax-scalar-plain">plain
          scalar</link>.
        </para>

        <productionset>
          <production id="c-sequence-start">
            <lhs>c-sequence-start</lhs>
            <rhs>
              <lineannotation>starts a flow sequence
              collection</lineannotation>
              <quote>[</quote>
            </rhs>
          </production>

          <production id="c-sequence-end">
            <lhs>c-sequence-end</lhs>
            <rhs>
              <lineannotation>ends a flow sequence collection</lineannotation>
              <quote>]</quote>
            </rhs>
          </production>

          <production id="c-mapping-start">
            <lhs>c-mapping-start</lhs>
            <rhs>
              <lineannotation>starts a flow mapping
              collection</lineannotation>
              <quote>{</quote>
            </rhs>
          </production>

          <production id="c-mapping-end">
            <lhs>c-mapping-end</lhs>
            <rhs>
              <lineannotation>ends a flow mapping collection</lineannotation>
              <quote>}</quote>
            </rhs>
          </production>

          <production id="c-sequence-entry">
            <lhs>c-sequence-entry</lhs>
            <rhs>
              <lineannotation>indicates a sequence entry</lineannotation>
              <quote>-</quote>
            </rhs>
          </production>

          <production id="c-mapping-entry">
            <lhs>c-mapping-entry</lhs>
            <rhs>
              <lineannotation>separates a key from its value</lineannotation>
              <quote>:</quote>
            </rhs>
          </production>

          <production id="c-collect-entry">
            <lhs>c-collect-entry</lhs>
            <rhs>
              <lineannotation>separates flow collection
              entries</lineannotation>
              <quote>,</quote>
            </rhs>
          </production>

          <production id="c-complex-key">
            <lhs>c-complex-key</lhs>
            <rhs>
              <lineannotation>a complex key</lineannotation>
              <quote>?</quote>
            </rhs>
          </production>


          <production id="c-tag">
            <lhs>c-tag</lhs>
            <rhs>
              <lineannotation>indicates a tag property</lineannotation>
              <quote>!</quote>
            </rhs>
          </production>

          <production id="c-anchor">
            <lhs>c-anchor</lhs>
            <rhs>
              <lineannotation>an anchor property</lineannotation>
              <quote>&amp;</quote>
            </rhs>
          </production>

          <production id="c-alias">
            <lhs>c-alias</lhs>
            <rhs>
              <lineannotation>an alias node</lineannotation>
              <quote>*</quote>
            </rhs>
          </production>

          <production id="c-literal">
            <lhs>c-literal</lhs>
            <rhs>
              <lineannotation>a literal scalar</lineannotation>
              <quote>|</quote>
            </rhs>
          </production>

          <production id="c-folded">
            <lhs>c-folded</lhs>
            <rhs>
              <lineannotation>a folded scalar</lineannotation>
              <quote>&gt;</quote>
            </rhs>
          </production>

          <production id="c-single-quote">
            <lhs>c-single-quote</lhs>
            <rhs>
              <lineannotation>a single quoted scalar</lineannotation>
              <quote>'</quote>
            </rhs>
          </production>

          <production id="c-double-quote">
            <lhs>c-double-quote</lhs>
            <rhs>
              <lineannotation>a double quoted scalar</lineannotation>
              <quote>"</quote>
            </rhs>
          </production>

          <production id="c-throwaway">
            <lhs>c-throwaway</lhs>
            <rhs>
              <lineannotation>a throwaway comment</lineannotation>
              <quote>#</quote>
            </rhs>
          </production>

          <production id="c-directive">
            <lhs>c-directive</lhs>
            <rhs>
              <lineannotation>a directive</lineannotation>
              <quote>%</quote>
            </rhs>
          </production>

          <production id="c-reserved">
            <lhs>c-reserved</lhs>
            <rhs>
              <lineannotation>reserved for future use</lineannotation>
              <quote>@</quote> | <quote>`</quote>
            </rhs>
          </production>

          <production id="c-indicators">
            <lhs>c-indicators</lhs>
            <rhs>
              <lineannotation>indicator characters</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#c-sequence-start"><quote>[</quote></nonterminal>
              | <nonterminal def="#c-sequence-end"><quote>]</quote></nonterminal>
              | <nonterminal def="#c-mapping-start"><quote>{</quote></nonterminal>
              | <nonterminal def="#c-mapping-end"><quote>}</quote></nonterminal><sbr />
              | <nonterminal def="#c-sequence-entry"><quote>-</quote></nonterminal>
              | <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              | <nonterminal def="#c-complex-key"><quote>?</quote></nonterminal>
              | <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal><sbr />
              | <nonterminal def="#c-tag"><quote>!</quote></nonterminal>
              | <nonterminal def="#c-alias"><quote>*</quote></nonterminal>
              | <nonterminal def="#c-anchor"><quote>&amp;</quote></nonterminal><sbr />
              | <nonterminal def="#c-literal"><quote>|</quote></nonterminal>
              | <nonterminal def="#c-folded"><quote>&gt;</quote></nonterminal>
              | <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal>
              | <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal><sbr />
              | <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal>
              | <nonterminal def="#c-directive"><quote>%</quote></nonterminal>
              | <nonterminal def="#c-reserved"><quote>@</quote> | <quote>`</quote></nonterminal>
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-char-break" />Line Breaks</title>

        <para>
          The Unicode standard defines several <link linkend="b-char">line
          break characters</link>. These line breaks can be grouped into two
          categories. <link linkend="b-specific">Specific line breaks</link>
          have well-defined semantics for breaking text into lines and
          paragraphs. <link linkend="b-generic">Generic line
          breaks</link> are not given meaning beyond <quote>ending a
          line</quote>.
        </para>

        <productionset>
          <production id="b-line-feed">
            <lhs>b-line-feed</lhs>
            <rhs>
              <lineannotation>aSCII line feed (LF)</lineannotation>
              #xA
            </rhs>
          </production>

          <production id="b-carriage-return">
            <lhs>b-carriage-return</lhs>
            <rhs>
              <lineannotation>aSCII carriage return (CR)</lineannotation>
              #xD
            </rhs>
          </production>

          <production id="b-next-line">
            <lhs>b-next-line</lhs>
            <rhs>
              <lineannotation>unicode next line (NEL)</lineannotation>
              #x85
            </rhs>
          </production>

          <production id="b-line-separator">
            <lhs>b-line-separator</lhs>
            <rhs>
              <lineannotation>unicode line separator (LS)</lineannotation>
              #x2028
            </rhs>
          </production>

          <production id="b-paragraph-separator">
            <lhs>b-paragraph-separator</lhs>
            <rhs>
              <lineannotation>unicode paragraph separator (PS)</lineannotation>
              #x2029
            </rhs>
          </production>

          <production id="b-char">
            <lhs>b-char</lhs>
            <rhs>
              <lineannotation>line break characters</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#b-line-feed"/><sbr />
              | <nonterminal def="#b-carriage-return"/><sbr />
              | <nonterminal def="#b-next-line"/><sbr />
              | <nonterminal def="#b-line-separator"/><sbr />
              | <nonterminal def="#b-paragraph-separator"/>
            </rhs>
          </production>

          <production id="b-generic">
            <lhs>b-generic</lhs>
            <rhs>
              <lineannotation>line break with non-specific
              semantics</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#b-carriage-return"/><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#b-line-feed"/> )<sbr />
              | <nonterminal def="#b-carriage-return"/><sbr />
              | <nonterminal def="#b-line-feed"/><sbr />
              | <nonterminal def="#b-next-line"/>
            </rhs>
          </production>

          <production id="b-specific">
            <lhs>b-specific</lhs>
            <rhs>
              <lineannotation>line break with specific
              semantics</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#b-line-separator"/><sbr />
              | <nonterminal def="#b-paragraph-separator"/>
            </rhs>
          </production>

          <production id="b-any">
            <lhs>b-any</lhs>
            <rhs>
              <lineannotation>any non-content line break</lineannotation>
              <nonterminal def="#b-generic"/> | <nonterminal def="#b-specific"/>
            </rhs>
          </production>
        </productionset>

        <para>
          Outside scalar text content, YAML allows <link linkend="b-any">any
          line break</link> to be used to terminate lines, and in most cases
          also allows such line breaks to be preceded by <link
          linkend="s-b-trailing-comment">trailing comment</link> characters.
          On output, a YAML processor is free to emit such line breaks using
          whatever convention is most appropriate. YAML output should avoid
          using trailing line spaces.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="syntax-char-misc" />Miscellaneous</title>

        <para>
          This section includes several common character range definitions.
        </para>

        <productionset>
          <production id="nb-char">
            <lhs>nb-char</lhs>
            <rhs>
              <lineannotation>characters valid in a line</lineannotation>
              <nonterminal def="#c-printable"/> - <nonterminal def="#b-char"/>
            </rhs>
          </production>

          <production id="s-char">
            <lhs>s-char</lhs>
            <rhs>
              <lineannotation>white space valid in a line</lineannotation>
              #x9 | #x20
            </rhs>
          </production>

          <production id="ns-char">
            <lhs>ns-char</lhs>
            <rhs>
              <lineannotation>non-space characters valid in a
              line</lineannotation>
              <nonterminal def="#nb-char"/> - <nonterminal def="#s-char"/>
            </rhs>
          </production>

          <production id="ns-ascii-letter">
            <lhs>ns-ascii-letter</lhs>
            <rhs>
              <lineannotation>aSCII letters, A-Z or a-z</lineannotation>
              [#x41-#x5A] | [#x61-#x7A]
            </rhs>
          </production>

          <production id="ns-decimal-digit">
            <lhs>ns-decimal-digit</lhs>
            <rhs>
              <lineannotation>0-9</lineannotation>
              [#x30-#x39]
            </rhs>
          </production>
          <production id="ns-hex-digit">
            <lhs>ns-hex-digit</lhs>
            <rhs>
              <lineannotation>0-9, A-F or a-f</lineannotation>
                <nonterminal def="#ns-decimal-digit"/><sbr />
              | [#x41-#x46] | [#x61-#x66]
            </rhs>
          </production>
          <production id="ns-word-char">
            <lhs>ns-word-char</lhs>
            <rhs>
              <lineannotation>characters valid in a word</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-decimal-digit"/><sbr />
              | <nonterminal def="#ns-ascii-letter"/> | <quote>-</quote>
            </rhs>
          </production>
        </productionset>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-space" />Space Processing</title>
      <para>
        YAML streams use lines and spaces to convey structure. This requires
        special processing rules for white space (<link linkend="s-char">space
        and tab</link>).
      </para>

      <sect2>
        <title><anchor id="syntax-indentation" />Indentation</title>

        <para>
          In a YAML character stream, structure is often determined from
          indentation, where indentation is defined as a line break
          character followed by zero or more space characters. With one
          notable exception, a node must be more indented than its parent
          node. All sibling nodes must use the exact same indentation level,
          however the content of each such node could be further indented.
          Indentation is used exclusively to delineate structure and is
          otherwise ignored; in particular, indentation characters must
          never be considered part of the document's content.
        </para>

        <para>
          Tab characters are not allowed in indentation since different
          systems treat tabs differently. To maintain portability, YAML's
          tab policy is conservative; they shall not be used. Note that most
          modern editors may be configured so that pressing the tab key
          results in the insertion of an appropriate number of spaces.
        </para>

        <productionset>
          <production id="i-spaces(n)">
            <lhs>i-spaces(n)</lhs>
            <rhs>
              <lineannotation>specific level of indentation</lineannotation>
              #x20 x n
            </rhs>
          </production>
        </productionset>

        <para>
          Since the YAML stream depends upon indentation level to delineate
          blocks, many productions are a function of an integer, based on
          the <link
          linkend="i-spaces(n)"><userinput>i-spaces(n)</userinput></link>
          production above. In some cases, the notations
          <userinput>production(&lt;n)</userinput>,
          <userinput>production(&les;n)</userinput> and
          <userinput>production(&gt;n)</userinput> are used; these are
          shorthands for <quote><userinput>production(m)</userinput> for some
          specific <varname>m</varname> such that <varname>m</varname> is less
          than/less than or equal/greater than <varname>n</varname></quote>,
          respectively. The notation <userinput>production(any)</userinput> is
          a shorthand for <quote><userinput>production(m)</userinput> for some
          specific value of <varname>m</varname> such that
          <varname>m</varname>&nbsp;&ges;&nbsp;0</quote>.
        </para>

        <para>
          The <quote><userinput>-</userinput></quote> <link
          linkend="c-sequence-entry">sequence entry</link>,
          <quote><userinput>?</userinput></quote> <link
          linkend="c-complex-key">complex key</link> and
          <quote><userinput>:</userinput></quote> <link
          linkend="c-mapping-entry">mapping entry</link> indicators are
          perceived by people to be part of the indentation. Hence the
          indentation rules are slightly more flexible when dealing with these
          indicators. First, a block sequence need not be indented relative to
          its parent node, unless that node is a block sequence entry. For
          example:
        </para>

        <example>
<programlisting>
a key in a mapping at indentation level 0:
# The value for this key is a block sequence.
- This sequence is also at indentation level 0.
-   Another entry in the sequence.
- # The value of this entry is a nested sequence.
 - This nested sequence must be
  indented at least to level 1.
 - Another entry in the nested sequence.
- Last entry in block sequence at indentation level 0.
second key in mapping: at indentation level 0.
</programlisting>
        </example>


        <para>
          In addition, in the special case when the value of a sequence
          entry or complex key:value pair is a block collection, and neither
          the nested block collection nor its first entry have any
          properties specified (tag or anchor), then this first entry may be
          specified in the same line as the indicator of the containing
          sequence entry. In this case both the indicator and any following
          spaces are counted as part of the indentation. For example:
        </para>

        <example>
<programlisting>
- This sequence is not indented.
-   inline-map: further indented by four.
    this key: is also further indented by four.
    ? - nested sequence used as key
      - indented by eight spaces
    : nested map: used as value
      indented by: six spaces
-  - inline-seq; further indented by three.
   -    second entry in nested sequence.
- Last entry in top sequence.
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-space-comment" />Throwaway comments</title>

        <para>
          Throwaway comments have no effect whatsoever on the document's
          representation graph.  The usual purpose of a comment is to
          communicate between the human maintainers of the file. A typical
          example is comments in a configuration file.
        </para>

        <para>
          A throwaway comment is marked by a <link
          linkend="c-throwaway"><quote><userinput>#</userinput></quote></link>
          indicator and always spans to the end of a line. Comments can be
          indented  on their own line, or may, in some cases, follow other
          syntax elements with leading spaces.
        </para>

        <para>
          Outside text content, empty lines or lines containing only white
          space are taken to be implicit throwaway comment lines. Lines
          containing indentation followed by
          <quote><userinput>#</userinput></quote> and comment characters are
          taken to be explicit throwaway comment lines.
        </para>

        <para>
          A throwaway comment may appear before a document's top level node or
          following any node. It may not appear inside a scalar node,  but may
          precede or follow it.
        </para>

        <productionset>
          <production id="c-nb-throwaway-comment">
            <lhs>c-nb-throwaway-comment</lhs>
            <rhs>
              <lineannotation>comment trailing a line</lineannotation>
              <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal> <nonterminal def="#nb-char" />*
            </rhs>
          </production>

          <production id="l-comment(n)">
            <lhs>l-comment(n)</lhs>
            <rhs>
              <lineannotation>types of comment lines</lineannotation>
                &nbsp;&nbsp;<nonterminal def="#l-empty-comment(n)" /><sbr />
                | <nonterminal def="#l-text-comment(n)" />
            </rhs>
          </production>

          <production id="l-empty-comment(n)">
            <lhs>l-empty-comment(n)</lhs>
            <rhs>
              <lineannotation>empty throwaway comment line</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal> <nonterminal def="#b-any" />
            </rhs>
          </production>

          <production id="l-text-comment(n)">
            <lhs>l-text-comment(n)</lhs>
            <rhs>
              <lineannotation>explicit throwaway comment line</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&lt;n)</nonterminal><sbr />
              <nonterminal def="#c-nb-throwaway-comment" /><sbr />
              <nonterminal def="#b-any" />
            </rhs>
          </production>

          <production id="s-b-trailing-comment">
            <lhs>s-b-trailing-comment</lhs>
            <rhs>
              <lineannotation>trailing non-content spaces, comment and line
              break</lineannotation>
              ( <nonterminal def="#s-char" />+<sbr />
              &nbsp;&nbsp;<nonterminal def="#c-nb-throwaway-comment" />? )?<sbr />
              <nonterminal def="#b-any" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
###The first tree lines of this stream

## are comments (the second one is empty).
this: |   # Comments may trail block indicators.
    contains three lines of text.
    The third one starts with a
    # character. This isn't a comment.

# The last three lines of this stream
# are comments (the first line is empty).
</programlisting>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-stream" />YAML Stream</title>

      <para>
        A sequence of bytes is a YAML stream if, taken as a whole, it complies
        with the following production. Note that an empty stream is a valid
        YAML stream containing no documents.
      </para>

      <para>
        <link linkend="syntax-encode">Encoding</link> is assumed to be
        UTF-8 unless explicitly specified by including a byte order mark as the
        first character of the stream. While a byte order mark may also appear
        before additional document headers, the same encoding must be used for
        all documents contained in a YAML stream.
      </para>

      <productionset>
        <production id="c-l-yaml-stream">
          <lhs>c-l-yaml-stream</lhs>
          <rhs>
            <lineannotation>document stream</lineannotation>
            ( <nonterminal def="#c-l-before-document" /><sbr />
            &nbsp;&nbsp;<nonterminal def="#l-l-implicit-document" /><sbr />
            &nbsp;&nbsp;<nonterminal def="#l-l-after-document" />? )?<sbr />
            ( <nonterminal def="#c-l-before-document" /><sbr />
            &nbsp;&nbsp;<nonterminal def="#l-l-explicit-document" /><sbr />
            &nbsp;&nbsp;<nonterminal def="#l-l-after-document" />? )*
          </rhs>
        </production>

        <production id="c-l-before-document">
          <lhs>c-l-before-document</lhs>
          <rhs>
            <lineannotation>comments before actual document
            starts</lineannotation>
            <nonterminal def="#c-byte-order-mark" />?<sbr />
            <nonterminal def="#l-comment(n)">#l-comment(any)</nonterminal>*
          </rhs>
        </production>

        <production id="l-l-implicit-document">
          <lhs>l-l-implicit-document</lhs>
          <rhs>
            <lineannotation>first document with an implicit header
            line</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#l-l-collect-blk-value(n)">l-l-collect-blk-value(any)</nonterminal><sbr />
            | <nonterminal def="#l-l-collect-top-flow-node(n)">l-l-collect-top-flow-node(any)</nonterminal>
          </rhs>
        </production>

        <production id="l-l-explicit-document">
          <lhs>l-l-explicit-document</lhs>
          <rhs>
            <lineannotation>stream document with an explicit
            header</lineannotation>
            <nonterminal def="#ns-ns-document-header" /><sbr />
            ( <nonterminal def="#s-l-scalar-top-node(n)">s-l-scalar-top-node(any)</nonterminal><sbr />
            | <nonterminal def="#s-l-collect-top-node(n)">s-l-collect-top-node(any)</nonterminal> )
          </rhs>
        </production>
      </productionset>

      <sect2>
        <title><anchor id="syntax-stream-doc" />Document</title>

        <para>
          A YAML stream may contain several independent YAML documents. A
          document header line may be used to start a document and must be used
          to separate documents within a stream. This line must start with a
          document separator: <link linkend="ns-ns-document-start"
          ><quote><userinput>---</userinput></quote></link> followed by a line
          break or a sequence of space characters. If no explicit header line
          is specified at the start of the stream, the processor should behave
          as if a header line containing an unadorned
          <quote><userinput>---</userinput></quote> was specified.
        </para>

        <para>
          When YAML is used as the format for a communication stream, it is
          useful to be able to indicate the end of a document independent of
          starting the next one without closing the data stream. Lacking
          such a marker, the YAML processor reading the stream would be
          forced to wait for the header of the next document (that may be
          long time in coming) in order to detect the end of the previous
          document. To support this scenario, a YAML document may be
          terminated by a <link linkend="ns-ns-document-end"
          ><quote><userinput>...</userinput></quote></link> line. Nothing
          but throwaway comments may appear between this line and the
          (mandatory) header line of the following document.
        </para>

        <productionset>
          <production id="ns-ns-document-header">
            <lhs>ns-ns-document-header</lhs>
            <rhs>
              <lineannotation>document header</lineannotation>
              <nonterminal def="#ns-ns-document-start" /><sbr />
              ( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-directive" /> )*
            </rhs>
          </production>

          <production id="ns-ns-document-start">
            <lhs>ns-ns-document-start</lhs>
            <rhs>
              <lineannotation>document start indicator</lineannotation>
                <quote>-</quote> <quote>-</quote> <quote>-</quote>
            </rhs>
          </production>

          <production id="l-l-after-document">
            <lhs>l-l-after-document</lhs>
            <rhs>
              <lineannotation>document trailer</lineannotation>
              <nonterminal def="#ns-ns-document-end" /> <nonterminal def="#b-any" /><sbr />
              <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*
            </rhs>
          </production>

          <production id="ns-ns-document-end">
            <lhs>ns-ns-document-end</lhs>
            <rhs>
              <lineannotation>document end indicator</lineannotation>
              <quote>.</quote> <quote>.</quote> <quote>.</quote>
            </rhs>
          </production>
        </productionset>

        <para>
          Since <quote><userinput>---</userinput></quote> and
          <quote><userinput>...</userinput></quote> indicate document
          boundaries, these character strings are forbidden as content
          lines unless they are indented.
        </para>

        <productionset>
          <production id="l-forbidden-non-indented">
            <lhs>l-forbidden-non-indented</lhs>
            <rhs>
              <lineannotation>forbidden non-indented content
              line</lineannotation>
                &nbsp;&nbsp;( <nonterminal def="#ns-ns-document-start" /><sbr />
                &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-char" /> <nonterminal def="#nb-char" />* )<sbr />
                | <nonterminal def="#ns-ns-document-end" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
--- &gt;
This YAML stream contains a single text value.
The next stream is a log file - a sequence of
log entries. Adding an entry to the log is a
simple matter of appending it at the end.
</programlisting>
        </example>

        <example>
<programlisting>
---
at: 2001-08-12 09:25:00.00 Z
type: GET
HTTP: '1.0'
url: '/index.html'
---
at: 2001-08-12 09:25:10.00 Z
type: GET
HTTP: '1.0'
url: '/toc.html'
</programlisting>
        </example>

        <example>
<programlisting>
# This stream is an example of a top-level mapping.
invoice : 34843
date    : 2001-01-23
total   : 4443.52
</programlisting>
        </example>

        <example>
<programlisting>
# A one-line alternative syntax for the above document.
{ invoice: 34843, date: 2001-01-23, total: 4443.52 }
</programlisting>
        </example>

        <example>
<programlisting>
# The following is a stream of three documents. TODO
# The first is an empty mapping, the second an
# empty sequence, and the last an empty string.
--- {}
--- [ ]
--- ''
</programlisting>
        </example>

        <example>
<programlisting>
# A communication channel based on a YAML stream.
---
sent at: 2002-06-06 11:46:25.10 Z
payload: Whatever
# Receiver can process this as soon as the following is sent:
...
# Even if the next message is sent long after:
---
sent at: 2002-06-06 12:05:53.47 Z
payload: Whatever
...
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-directive" />Directive</title>

        <para>
          <link linkend="model-directive">Directives</link> are instructions
          to the YAML processor. Like <link
          linkend="syntax-space-comment">throwaway comments</link>,
          directives are not reflected in the document's representation
          graph. Directives apply to a single document. It is an error for
          the same directive to be specified more than once for the same
          document.
        </para>

        <productionset>
          <production id="c-ns-directive">
            <lhs>c-ns-directive</lhs>
            <rhs>
              <lineannotation>document directive</lineannotation>
              <nonterminal def="#c-directive"><quote>%</quote></nonterminal> <nonterminal def="#ns-ns-directive-name" /><sbr />
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal> <nonterminal def="#ns-ns-directive-value" />
            </rhs>
          </production>

          <production id="ns-ns-directive-name">
            <lhs>ns-ns-directive-name</lhs>
            <rhs>
              <lineannotation>document directive name</lineannotation>
              ( <nonterminal def="#ns-char" /> - <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal> )+
            </rhs>
          </production>

          <production id="ns-ns-directive-value">
            <lhs>ns-ns-directive-value</lhs>
            <rhs>
              <lineannotation>document directive value</lineannotation>
              <nonterminal def="#ns-char" />+
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-node" />Presentation Node</title>

        <para>
          A presentation node begins at a particular level of indentation,
          <varname>n</varname>, and its content is indented at some level
          &gt;&nbsp;<varname>n</varname>. A presentation node can be a <link
          linkend="syntax-collect">collection</link>, a <link
          linkend="syntax-scalar">scalar</link> or an <link
          linkend="syntax-alias">alias</link>.
        </para>

        <para>
          A YAML document is a normal node. However a document can't be an
          alias (there is nothing it may refer to). Also if the header line is
          omitted the first document must be a collection.
        </para>

        <productionset>
          <production id="s-l-top-node(n)">
            <lhs>s-l-top-node(n)</lhs>
            <rhs>
              <lineannotation>node outside flow
              collection</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#s-l-alias-top-node" /><sbr />
              | <nonterminal def="#s-l-collect-top-node(n)">s-l-collect-top-node(n)</nonterminal><sbr />
              | <nonterminal def="#s-l-scalar-top-node(n)" />
            </rhs>
          </production>

          <production id="ns-ns-flow-value-node(n)">
            <lhs>ns-ns-flow-value-node(n)</lhs>
            <rhs>
              <lineannotation>value node inside flow
              collection</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-alias-flow-node" /><sbr />
              | <nonterminal def="#c-c-collect-flow-node(n)" /><sbr />
              | <nonterminal def="#ns-ns-scalar-flow-value-node(n)" />
            </rhs>
          </production>

          <production id="ns-ns-flow-key-node(n)">
            <lhs>ns-ns-flow-key-node(n)</lhs>
            <rhs>
              <lineannotation>key node inside flow collection</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-alias-flow-node" /><sbr />
              | <nonterminal def="#c-c-collect-flow-node(n)" /><sbr />
              | <nonterminal def="#ns-ns-scalar-flow-key-node(n)" />
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-stream-property" />Node Property</title>

        <para>
          Each presentation node may have <link
          linkend="syntax-anchor">anchor</link> and <link
          linkend="syntax-tag">tag</link> properties. These properties
          are specified in a properties list appearing before the node value
          itself. For a root node (a document), the properties appear in the
          document header line, following the directives (if any). It is an
          error for the same property to be specified more than once for the
          same node.
        </para>

        <productionset>
          <production id="c-ns-properties">
            <lhs>c-ns-properties</lhs>
            <rhs>
              <lineannotation>properties list</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#c-ns-tag-property" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-anchor-property" /> )? )<sbr />
              | ( <nonterminal def="#c-ns-anchor-property" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-tag-property" /> )? )
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-tag" />Tag</title>

        <para>
          <link linkend="model-tag">Tags</link> can be presented in the
          character stream with the tag indicator, <link
          linkend="c-tag"><quote><userinput>!</userinput></quote></link>.
          Unlike <link linkend="syntax-anchor">anchors</link>, tags are
          part of the document's representation graph. The YAML processor
          is responsible for <link linkend="model-resolve">resolving</link> 
          tags which are not present in the character stream.
        </para>

        <example>
<programlisting>
a string: '12'
another string: "12"
explicit string: !str 12
explicit integer: !int 12
implicit integer: 12
</programlisting>
        </example>

        <sect3>
          <title><anchor id="syntax-tag-short" />Shorthands</title>

          <para>
            To increase readability, YAML does not use the full URI notation
            in the character stream. Instead, it provides several shorthand
            notations for different groups of tags. If a tag may be written
            using more than one shorthand, the shortest format must be used.
            A processor need not expand shorthand tags to a full URI form.
            However, in such a case the processor must still perform <link
            linkend="syntax-tag-escape">escaping</link>. These rules ensure
            that each tag's shorthand is a globally unique.
          </para>

          <itemizedlist>
            <listitem>
              <para>
                If a tag property is of the form
                <userinput>!</userinput><varname>foo</varname>, it is a
                shorthand for the <link
                linkend="model-private">private</link> tag URI
                <userinput>tag:private.yaml.org,2002:</userinput><varname>foo</varname>.
              </para>

              <example>
<programlisting>
# Both examples below make use of the 
# 'tag:private.yaml.org,2002:ball'
# tag, but with different semantics.
---
pool: !!ball { number: 8 }
---
bearing: !!ball { material: steel }
</programlisting>
              </example>
            </listitem>

            <listitem>
              <para>
                If a tag property <varname>foo</varname> contains neither
                <quote><userinput>:</userinput></quote> nor
                <quote><userinput>/</userinput></quote> characters, it is a
                shorthand for the tag URI
                <userinput>tag:yaml.org,2002:</userinput><varname>foo</varname>.
                The <userinput>yaml.org</userinput> domain is used to define
                the core and universal YAML data types.
              </para>

              <example>
<programlisting>
# The URI is 'tag:yaml.org,2002:str'
- !str is a Unicode string
</programlisting>
              </example>
            </listitem>

            <listitem>
              <para>
                If the tag property is of the form
                <varname>vocabulary</varname><userinput>/</userinput><varname>foo</varname>
                where <varname>vocabulary</varname> is a single word, it is
                a shorthand for the tag URI
                <userinput>tag:</userinput><varname>vocabulary</varname><userinput>.yaml.org,2002:</userinput><varname>foo</varname>.
                Each domain
                <varname>vocabulary</varname><userinput>.yaml.org</userinput>
                is used for tags specific to the given vocabulary, such as a
                particular programming language.
              </para>

              <example>
<programlisting>
# The URI is 'tag:perl.yaml.org,2002:Text::Tabs'
- !perl/Text::Tabs {}
</programlisting>
              </example>
            </listitem>

            <listitem>
              <para>
                Otherwise, the tag property must be of the form
                <varname>domain</varname><userinput>,</userinput><varname>date</varname><userinput>/</userinput><varname>foo</varname>,
                which is a shorthand for the tag URI
                <userinput>tag:</userinput><varname>domain</varname><userinput>,</userinput><varname>date</varname><userinput>/</userinput><varname>foo</varname>.
                To ensure uniqueness, the day must be omitted if it is the
                1st of the month, and the month and day must be omitted for
                January 1st. Such tags may be freely minted by the owners of
                the domain at the specified date.
              </para>

              <example>
<programlisting>
# The URI is 'tag:clarkevans.com,2003-02:timesheet'
- !clarkevans.com,2003-02/timesheet
</programlisting>
              </example>
            </listitem>
          </itemizedlist>
          <para>
            Following are several examples which are not valid tag
            shorthands.
          </para>
          <example>
            <title>Invalid Shorthands</title>
            <simplelist type="horiz" columns="2">
              <member>
  <screen>
- !http://www.yaml.org/bing invalid
- !tag:yaml.org,2002:str
  </screen>
              </member>
              <member>
  <screen>
Only the tag shorthand is allowed in 
a character stream, URIs, including
the taguri is forbidden.
  </screen>
              </member>
            </simplelist>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-tag-escape" />Escaping</title>

          <para>
            YAML allows arbitrary Unicode characters to be used in a tag
            with <link linkend="syntax-escape">escape sequences</link>. The
            processor must expand such escape sequences before reporting the
            tag's shorthand or URI to the application.
          </para>

          <para>
            Sometimes it may be helpful for a YAML tag to be expanded to its
            full URI form. A YAML processor may provide a mechanism to
            perform such expansion. Since URIs support a limited ASCII-based
            character set, this expansion requires all characters outside
            this set to be encoded in UTF-8 and the resulting bytes to be
            encoded using <quote><userinput>%</userinput></quote> notation
            with upper-case hexadecimal digits. Further details on the URI
            encoding requirements are given in <ulink
            url="http://www.ietf.org/rfc/rfc2396.txt">RFC2396</ulink>.
          </para>

          <example>
<programlisting>
# The following values have the same tag URI:
# 'tag:domain.tld,2002/a%3C%0A%25b'.
- !domain.tld,2002/a&lt;\n%b value
- !domain.tld,2002/a\x3c\x0A%b value
</programlisting>
          </example>
        </sect3>

        <sect3>
          <title><anchor id="syntax-tag-prefix" />Prefixing</title>

          <para>
            YAML provides a convenient prefix mechanism for the common case
            where a node and (most of) its descendents have globally unique
            tags, whose shorthand forms share a common prefix. If a node's
            tag property is of the form
            <varname>prefix</varname><userinput>^</userinput><varname>suffix</varname>,
            the <quote><userinput>^</userinput></quote> character is
            discarded from the tag. If a descendent node's tag property is
            of the form <userinput>^</userinput><varname>foo</varname>, it
            is treated as if it was written
            <varname>prefix</varname><varname>foo</varname> where
            <varname>prefix</varname> comes from the most recent ancestor
            that established a prefix. Note that this mechanism is purely
            syntactical and does not imply any additional semantics. In
            particular, the prefix must not be assumed to be an identifier
            for anything. It is possible to include a
            <quote><userinput>^</userinput></quote> character in a tag by
            <link linkend="syntax-escape">escaping</link> it. It is an error
            for a node's tag property to contain more than one unescaped
            <quote><userinput>^</userinput></quote> character, or for the
            tag property to begin with
            <quote><userinput>^</userinput></quote> unless the node is a
            descendent of an ancestor that established a tag prefix.
          </para>

          <example>
<programlisting>
# 'tag:domain.tld,2002:invoice' is some tag.
invoice: !domain.tld,2002/^invoice
  # 'seq' is shorthand for 'tag:yaml.org,2002:seq'.
  # This does not effect '^customer' below
  # because it is does not specify a prefix.
  customers: !seq
    # '^customer' is shorthand for the full notation
    # '!domain.tld,2002/customer' that stands for the
    # URI 'tag:domain.tld,2002:customer'.
    - !^customer
      given : Chris
      family : Dumars
</programlisting>
          </example>
        </sect3>

        <productionset>
          <production id="c-prefix">
            <lhs>c-prefix</lhs>
            <rhs>
              <lineannotation>seperate prefix from type</lineannotation>
              <quote>^</quote>
            </rhs>
          </production>

          <production id="ns-tag-char">
            <lhs>ns-tag-char</lhs>
            <rhs>
              <lineannotation>characters valid in a tag</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-esc-sequence" /><sbr />
              | ( <quote>%</quote> <nonterminal def="#ns-hex-digit" /> x 2 )<sbr />
              | ( <nonterminal def="#ns-char" /> - <nonterminal def="#c-escape"><quote>\</quote></nonterminal> - <nonterminal def="#c-prefix"><quote>^</quote></nonterminal> - <quote>%</quote> )
            </rhs>
          </production>

          <production id="ns-mundane-tag-char">
            <lhs>ns-mundane-tag-char</lhs>
            <rhs>
              <lineannotation>non-magical URI character</lineannotation>
              <nonterminal def="#ns-tag-char" /> - <quote>:</quote> - <quote>/</quote>
            </rhs>
          </production>

          <production id="c-ns-tag-property">
            <lhs>c-ns-tag-property</lhs>
            <rhs>
              <lineannotation>collection tag</lineannotation>
              <nonterminal def="#c-tag"><quote>!</quote></nonterminal><sbr />
              ( /* empty (implicit) */<sbr />
              | <nonterminal def="#c-ns-private-tag" /><sbr />
              | <nonterminal def="#ns-ns-global-tag" /><sbr />
              | ( Prefix-of-above?<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#c-prefix"><quote>^</quote></nonterminal><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;Suffix-of-above ) )
            </rhs>
          </production>

          <production id="c-ns-private-tag">
            <lhs>c-ns-private-tag</lhs>
            <rhs>
              <lineannotation>private tags</lineannotation>
              <nonterminal def="#c-tag"><quote>!</quote></nonterminal> <nonterminal def="#ns-tag-char" />+
            </rhs>
          </production>

          <production id="ns-ns-global-tag">
            <lhs>ns-ns-global-tag</lhs>
            <rhs>
              <lineannotation>global tags</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-core-tag" /><sbr />
              | <nonterminal def="#ns-ns-vocabulary-tag" /><sbr />
              | <nonterminal def="#ns-ns-domain-tag" />
            </rhs>
          </production>

          <production id="ns-ns-core-tag">
            <lhs>ns-ns-core-tag</lhs>
            <rhs>
              <lineannotation>shorthand for
              <userinput>tag:yaml.org,2002:</userinput><varname>type</varname>
              names</lineannotation>
              ( <nonterminal def="#ns-mundane-tag-char" /><sbr />
              - <nonterminal def="#c-tag"><quote>!</quote></nonterminal> )<sbr />
              <nonterminal def="#ns-mundane-tag-char" />*
            </rhs>
          </production>

          <production id="ns-ns-vocabulary-tag">
            <lhs>ns-ns-vocabulary-tag</lhs>
            <rhs>
              <lineannotation>shorthand for
              <userinput>tag:vocabulary.yaml.org,2002:</userinput><varname>type</varname>
              names</lineannotation>
              <nonterminal def="#ns-word-char" />+ <quote>/</quote> <nonterminal def="#ns-tag-char" />*
            </rhs>
          </production>

          <production id="ns-ns-domain-tag">
            <lhs>ns-ns-domain-tag</lhs>
            <rhs>
              <lineannotation>shorthand for
              <userinput>tag:domain,date:</userinput><varname>type</varname>
              names</lineannotation>
              <nonterminal def="#ns-word-char" />+<sbr />
              ( <quote>.</quote> <nonterminal def="#ns-word-char" />+ )<sbr />
              <quote>,</quote> <nonterminal def="#ns-ns-domain-year" /><sbr />
              ( <quote>-</quote> <nonterminal def="#ns-ns-domain-day-month" /><sbr />
              &nbsp;&nbsp;( <quote>-</quote> <nonterminal def="#ns-ns-domain-day-month" /> )? )?<sbr />
              <quote>/</quote> <nonterminal def="#ns-tag-char" />*
            </rhs>
          </production>

          <production id="ns-ns-domain-year">
            <lhs>ns-ns-domain-year</lhs>
            <rhs>
              <lineannotation>tag domain ownership year</lineannotation>
              <nonterminal def="#ns-decimal-digit" /> x 4
            </rhs>
          </production>

          <production id="ns-ns-domain-day-month">
            <lhs>ns-ns-domain-day-month</lhs>
            <rhs>
              <lineannotation>tag domain ownership day or month (01 by
              default)</lineannotation>
              <nonterminal def="#ns-decimal-digit" /> x 2
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-anchor" />Anchor</title>
        <para>
          An anchor is a property that can be used to mark a node for future
          reference. An <link linkend="syntax-alias">alias node</link> can then
          be used to indicate additional inclusions of an anchored node by
          specifying the node's anchor.
        </para>

        <productionset>
          <production id="c-ns-anchor-property">
            <lhs>c-ns-anchor-property</lhs>
            <rhs>
              <lineannotation>associates an anchor with a given
              node</lineannotation>
              <nonterminal def="#c-anchor"><quote>&amp;</quote></nonterminal> <nonterminal def="#ns-ns-anchor-name" />
            </rhs>
          </production>

          <production id="ns-ns-anchor-name">
            <lhs>ns-ns-anchor-name</lhs>
            <rhs>
              <lineannotation>unique anchor name</lineannotation>
              <nonterminal def="#ns-char" />+
            </rhs>
          </production>
        </productionset>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-alias" />Alias</title>

      <para>
        An alias node is a place holder for subsequent occurrences of a
        previously serialized node. The first occurence of the node must be
        marked by an <link linkend="syntax-anchor">anchor</link> to allow
        subsequent occurences to be represented as alias nodes.
      </para>

      <para>
        An alias refers to the most recent <link
        linkend="model-key-order">preceding</link> node having the same
        anchor. It is an error to have an alias use an anchor that does not
        occur previously in the serialization of the documeht. It is not an
        error to have an anchor that is not used by any alias node.
      </para>

      <productionset>
        <production id="s-l-alias-top-node">
          <lhs>s-l-alias-top-node</lhs>
          <rhs>
            <lineannotation>alias node outside flow
            collection</lineannotation>
            <nonterminal def="#s-char" /> <nonterminal def="#ns-ns-alias-flow-node" /><sbr />
            <nonterminal def="#s-b-trailing-comment" /><sbr />
            <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*
          </rhs>
        </production>

        <production id="ns-ns-alias-flow-node">
          <lhs>ns-ns-alias-flow-node</lhs>
          <rhs>
            <lineannotation>alias node inside flow collection</lineannotation>
            <nonterminal def="#c-alias"><quote>*</quote></nonterminal> <nonterminal def="#ns-ns-anchor-name" />
          </rhs>
        </production>
      </productionset>

      <example>
<programlisting>
anchor : &amp;A001 This scalar has an anchor.
override : &amp;A001 The alias node below is a repeated use of this value.
alias : *A001
</programlisting>
      </example>
    </sect1>

    <sect1>
      <title><anchor id="syntax-collect" />Collection</title>

      <para>
        Collection nodes come in two kinds, <link
        linkend="syntax-collect-seq">sequence</link> and <link
        linkend="syntax-collect-map">mapping</link>. Each kind has two styles,
        block and flow. Block styles begin on the next line and use indentation
        for internal structure. Flow collection styles start on the current
        line, may span multiple lines, and rely on indicators to represent
        internal structure.
      </para>

      <productionset>
        <production id="s-l-collect-top-node(n)">
          <lhs>s-l-collect-top-node(n)</lhs>
          <rhs>
            <lineannotation>collection node outside flow
            collection</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#s-l-collect-blk-node(n)" /><sbr />
            | ( <nonterminal def="#s-s-required(n)" /><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#c-c-collect-flow-node(n)" /><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-b-trailing-comment">s-b-trailing-comment</nonterminal><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>* )
          </rhs>
        </production>

        <production id="l-l-collect-top-flow-node(n)">
          <lhs>l-l-collect-top-flow-node(n)</lhs>
          <rhs>
            <lineannotation>top-level (document) flow collection
            node</lineannotation>
            <nonterminal def="#i-spaces(n)" /><sbr />
            <nonterminal def="#c-c-collect-flow-node(n)" /><sbr />
            <nonterminal def="#s-b-trailing-comment" /><sbr />
            <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*
          </rhs>
        </production>

        <production id="c-c-collect-flow-node(n)">
          <lhs>c-c-collect-flow-node(n)</lhs>
          <rhs>
            <lineannotation>collection node in flow style</lineannotation>
            ( <nonterminal def="#c-ns-properties" /> <nonterminal def="#s-char" />+ )?<sbr />
            <nonterminal def="#c-c-collect-flow-value(n)" />
          </rhs>
        </production>

        <production id="s-l-collect-blk-node(n)">
          <lhs>s-l-collect-blk-node(n)</lhs>
          <rhs>
            <lineannotation>collection node in block style</lineannotation>
            ( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-properties" /> )?<sbr />
            <nonterminal def="#s-b-trailing-comment" /><sbr />
            <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*<sbr />
            <nonterminal def="#l-l-collect-blk-value(n)" />
          </rhs>
        </production>

        <production id="l-l-collect-blk-value(n)">
          <lhs>l-l-collect-blk-value(n)</lhs>
          <rhs>
            <lineannotation>collection value in block style</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#l-l-blk-seq-value(n)" /><sbr />
            | <nonterminal def="#l-l-blk-map-value(n)" />
          </rhs>
        </production>

        <production id="c-c-collect-flow-value(n)">
          <lhs>c-c-collect-flow-value(n)</lhs>
          <rhs>
            <lineannotation>collection value in flow style</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-c-flow-seq-value(n)" /><sbr />
            | <nonterminal def="#c-c-flow-map-value(n)" />
          </rhs>
        </production>
      </productionset>

      <para>
        To enable line spanning in flow collections, wherever tokens may be
        separated by white space it is possible to end the line (with an
        optional throwaway comment) and continue the collection in the next
        line. Line spanning functionality is indicated by the use of the <link
        linkend="s-s-optional(n)"><userinput>s-s-optional(n)</userinput></link>
        space and the <link
        linkend="s-s-required(n)"><userinput>s-s-required(n)</userinput></link>
        space productions.
      </para>

      <productionset>
        <production id="s-s-optional(n)">
          <lhs>s-s-optional(n)</lhs>
          <rhs>
            <lineannotation>optional white space separating
            tokens</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#s-char" />*<sbr />
            | ( <nonterminal def="#s-b-trailing-comment" /><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-spaces(n)" /> <nonterminal def="#s-char" />+ )
          </rhs>
        </production>

        <production id="s-s-required(n)">
          <lhs>s-s-required(n)</lhs>
          <rhs>
            <lineannotation>required white space separating
            tokens</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#s-char" />+<sbr />
            | ( <nonterminal def="#s-b-trailing-comment" /><sbr />
            &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-spaces(n)" /> <nonterminal def="#s-char" />+ )
          </rhs>
        </production>
      </productionset>

      <sect2>
        <title><anchor id="syntax-collect-seq" />Sequence</title>
        <para>
          A sequence node is an ordered collection of sub-nodes, where each
          subordinate node has a higher indentation level. A flow  style is
          available for short, simple sequences. For syntax compactness, if a
          sub-sequence node has no properties, and its  first entry is
          specified without any properties, the sub-sequence may immediately
          follow the sequence entry indicator.
        </para>

        <para>
          TODO: Talk about the single-key map.
        </para>

        <productionset>
          <production id="l-l-blk-seq-value(n)">
            <lhs>l-l-blk-seq-value(n)</lhs>
            <rhs>
              <lineannotation>sequence value in block style;
              <userinput>-1</userinput> unless the block sequence is the value
              of an entry of a parent block sequence</lineannotation>
              ( <nonterminal def="#i-spaces(n)">i-spaces(n-1)</nonterminal><sbr />
              &nbsp;&nbsp;<nonterminal def="#c-l-blk-seq-entry(n)">c-l-blk-seq-entry(n-1)</nonterminal> )+
            </rhs>
          </production>

          <production id="c-l-blk-seq-entry(n)">
            <lhs>c-l-blk-seq-entry(n)</lhs>
            <rhs>
              <lineannotation>block sequence node entry</lineannotation>
              <nonterminal def="#c-sequence-entry"><quote>-</quote></nonterminal>
              <nonterminal def="#s-l-inline-node(n)" /><sbr />
            </rhs>
          </production>

          <production id="s-l-inline-node(n)">
            <lhs>s-l-inline-node(n)</lhs>
            <rhs>
              <lineannotation>top node or a shorthand inline
              collection</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#s-l-top-node(n)">s-l-top-node(&gt;n)</nonterminal><sbr />
              | <nonterminal def="#i-l-inline-seq(n)" /><sbr />
              | <nonterminal def="#i-l-inline-map(n)" />
            </rhs>
          </production>

          <production id="i-l-inline-seq(n)">
            <lhs>i-l-inline-seq(n)</lhs>
            <rhs>
              <lineannotation>inline sequence node with no properties
              (where <varname>m</varname>&nbsp;&gt;&nbsp;0)</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(m)</nonterminal><sbr />
              <nonterminal def="#c-l-blk-seq-entry(n)">c-l-blk-seq-entry(n+m+1)</nonterminal><sbr />
              <nonterminal def="#l-l-blk-seq-value(n)">l-l-blk-seq-value(n+m+1)</nonterminal>?
            </rhs>
          </production>

          <production id="c-c-flow-seq-value(n)">
            <lhs>c-c-flow-seq-value(n)</lhs>
            <rhs>
              <lineannotation>sequence value in flow style</lineannotation>
              <nonterminal def="#c-sequence-start"><quote>[</quote></nonterminal><sbr />
              <nonterminal def="#s-s-optional(n)" /><sbr />
              ( <nonterminal def="#ns-ns-flow-seq-entry(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#s-s-optional(n)" /><sbr />
              &nbsp;&nbsp;( <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal>
              <nonterminal def="#s-s-required(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-ns-flow-seq-entry(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-s-optional(n)" /> )* )?<sbr />
              <nonterminal def="#c-sequence-end"><quote>]</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-ns-flow-seq-entry(n)">
            <lhs>ns-ns-flow-seq-entry(n)</lhs>
            <rhs>
              <lineannotation>flow style sequence entry</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-flow-value-node(n)" /><sbr />
              | <nonterminal def="#ns-ns-flow-pair-map(n)" />
            </rhs>
          </production>

        </productionset>

        <example>
<programlisting>
empty: []
flow: [ one, two, three # May span lines,
         , four,        # indentation is
           five ]       # mostly ignored.
block:
- Note indicator is not indented.
-
 - Subordinate sequence entry (note must be indented).
 - Another entry in subordinate sequence
- - Another way to write a sub-sequence
  - Another entry in sub-sequence
- &gt;
 A folded sequence entry (fifth entry)
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-collect-map" />Mapping</title>

        <para>
          A mapping node is an unordered association of unique keys with
          values. It is an error for two <link
          linkend="model-equality">equal</link> key entries to
          appear in the same mapping node. In such a case the processor may
          continue, ignoring the second key and issuing an appropriate warning.
          This strategy preserves a consistent information model for streaming
          and random access applications.
        </para>

        <para>
          A flow form is available for short, simple mapping nodes. For syntax
          compactness, if a mapping node has no properties, and its  first key
          is specified as a flow scalar without any properties,  this first key
          may immediately follow the sequence entry indicator.
        </para>

        <para>
          TODO: Talk about optional ':'.
        </para>

        <productionset>
          <production id="l-l-blk-map-value(n)">
            <lhs>l-l-blk-map-value(n)</lhs>
            <rhs>
              <lineannotation>mapping value in block style</lineannotation>
              ( <nonterminal def="#i-spaces(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#ns-l-blk-map-entry(n)" /> )+
            </rhs>
          </production>

          <production id="i-l-inline-map(n)">
            <lhs>i-l-inline-map(n)</lhs>
            <rhs>
              <lineannotation>inline mapping node with no properties
              (where <varname>m</varname>&nbsp;&gt;&nbsp;0)</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(m)</nonterminal><sbr />
              <nonterminal def="#ns-ns-scalar-key-value(n)">ns-ns-scalar-key-value(n&#43;m&#43;1)</nonterminal><sbr />
              <nonterminal def="#s-char" />*
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal><sbr />
              <nonterminal def="#s-l-top-node(n)">s-l-top-node(&gt;n&#43;m&#43;1)</nonterminal><sbr />
              <nonterminal def="#l-l-blk-map-value(n)">l-l-blk-map-value(n&#43;m&#43;1)</nonterminal>?
            </rhs>
          </production>

          <production id="ns-l-blk-map-entry(n)">
            <lhs>ns-l-blk-map-entry(n)</lhs>
            <rhs>
              <lineannotation>block key:value pair</lineannotation>
              <nonterminal def="#ns-l-simple-map-entry(n)" /><sbr />
              <nonterminal def="#ns-l-complex-map-entry(n)" />
            </rhs>
          </production>

          <production id="ns-l-simple-map-entry(n)">
            <lhs>ns-l-simple-map-entry(n)</lhs>
            <rhs>
              <lineannotation>simple key:value pair</lineannotation>
              <nonterminal def="#ns-ns-flow-key-node(n)" />
              <nonterminal def="#s-char" />*
              <sbr />
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              <nonterminal def="#s-l-top-node(n)">s-l-top-node(&gt;n)</nonterminal>
            </rhs>
          </production>

          <production id="ns-l-complex-map-entry(n)">
            <lhs>ns-l-complex-map-entry(n)</lhs>
            <rhs>
              <lineannotation>complex key:value pair</lineannotation>
              <nonterminal def="#c-complex-key"><quote>?</quote></nonterminal>
              <nonterminal def="#s-l-inline-node(n)" /><sbr />
              ( <nonterminal def="#i-spaces(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              <nonterminal def="#s-l-inline-node(n)" /> )?
            </rhs>
          </production>

          <production id="c-c-flow-map-value(n)">
            <lhs>c-c-flow-map-value(n)</lhs>
            <rhs>
              <lineannotation>mapping value in flow style</lineannotation>
              <nonterminal def="#c-mapping-start"><quote>{</quote></nonterminal><sbr />
              <nonterminal def="#s-s-optional(n)" /><sbr />
              ( <nonterminal def="#ns-ns-flow-map-entry(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#s-s-optional(n)" /><sbr />
              &nbsp;&nbsp;( <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal>
              <nonterminal def="#s-s-required(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-ns-flow-map-entry(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-s-optional(n)" /> )* )?<sbr />
              <nonterminal def="#c-mapping-end"><quote>}</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-ns-flow-map-entry(n)">
            <lhs>ns-ns-flow-map-entry(n)</lhs>
            <rhs>
              <lineannotation>flow key:value pair</lineannotation>
              <nonterminal def="#ns-ns-flow-key-node(n)" /><sbr />
              ( <nonterminal def="#s-char" />*
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal><sbr />
              &nbsp;&nbsp;<nonterminal def="#s-s-required(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#ns-ns-flow-value-node(n)" /> )?
            </rhs>
          </production>

          <production id="ns-ns-flow-pair-map(n)">
            <lhs>ns-ns-flow-pair-map(n)</lhs>
            <rhs>
              <lineannotation>single key:value pair map in flow sequence</lineannotation>
              <nonterminal def="#ns-ns-flow-key-node(n)" /><sbr />
              <nonterminal def="#s-char" />*
              <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal><sbr />
              <nonterminal def="#s-s-required(n)" /><sbr />
              <nonterminal def="#ns-ns-flow-value-node(n)" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: {}
null values: { one, two }
flow: { one: 1, two: 2 }
two equal maps in a sequence: [ key: value, { "key" : value } ]
spanning: { one: 1,
   two: 2 }
block:
 key : value
 nested mapping:
  key: Subordinate mapping
 nested sequence:
  - Subordinate sequence
!float 12 : This key is a float.
"\a" : This key had to be escaped.
? '?'
: This key had to be quoted.
? &gt;
 This is a multi
 line folded key
: Whose value is
  also multi-line.
? This key has implicit null value
?
 - This key
 - is a sequence
: - With a sequence value.
? This: key
  is a: mapping
:
 with a: mapping value.
---
- A key: value pair in a sequence.
  A second: key:value pair.
- The previous entry is equal to the following one.
-
 A key:
     value pair in a sequence.
 A second:
     key:value pair.
</programlisting>
        </example>
      </sect2>
    </sect1>

    <sect1>
      <title><anchor id="syntax-scalar" />Scalar</title>

      <para>
        While most of the document productions are fairly strict, the scalar
        production is generous. It offers three flow style variants and two
        block style variants to choose from, depending upon the readability
        requirements.
      </para>

      <para>
        Additionally, <link linkend="syntax-space-comment">Throwaway
        comments</link> may follow a scalar  node, but may not appear inside
        one. The comment lines following a  block scalar node must be less
        indented than the block scalar value. Empty lines in a scalar node
        that are followed by a non-empty content  line are interpreted as
        content rather than as implicit comments. Such lines may be less
        indented than the text content.
      </para>

      <productionset>
        <production id="s-l-scalar-top-node(n)">
          <lhs>s-l-scalar-top-node(n)</lhs>
          <rhs>
            <lineannotation>scalar node outside flow
            collection</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#s-l-scalar-top-blk-node(n)" /><sbr />
            | <nonterminal def="#s-l-scalar-top-flow-node(n)" />
          </rhs>
        </production>

        <production id="s-l-scalar-top-blk-node(n)">
          <lhs>s-l-scalar-top-blk-node(n)</lhs>
          <rhs>
            <lineannotation>scalar node outside flow collection, in block
            style</lineannotation>
            ( <nonterminal def="#s-char" />+ <nonterminal def="#c-ns-properties" /> )?<sbr />
            <nonterminal def="#s-char" />+ <nonterminal def="#c-l-scalar-blk-value(n)" />
          </rhs>
        </production>

        <production id="s-l-scalar-top-flow-node(n)">
          <lhs>s-l-scalar-top-flow-node(n)</lhs>
          <rhs>
            <lineannotation>scalar node outside flow collection, in flow
            style</lineannotation>
            <nonterminal def="#s-s-required(n)" /><sbr />
            ( <nonterminal def="#c-ns-properties" /> <nonterminal def="#s-char" />+ )?<sbr />
            <nonterminal def="#ns-ns-scalar-top-value(n)" /><sbr />
            <nonterminal def="#s-b-trailing-comment" /><sbr />
            <nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>*
          </rhs>
        </production>

        <production id="ns-ns-scalar-flow-value-node(n)">
          <lhs>ns-ns-scalar-flow-value-node(n)</lhs>
          <rhs>
            <lineannotation>scalar node inside flow collection, used as
            value</lineannotation>
            ( <nonterminal def="#c-ns-properties" /> <nonterminal def="#s-char" />+ )?<sbr />
            <nonterminal def="#ns-ns-scalar-flow-value(n)" />
          </rhs>
        </production>

        <production id="ns-ns-scalar-flow-key-node(n)">
          <lhs>ns-ns-scalar-flow-key-node(n)</lhs>
          <rhs>
            <lineannotation>scalar node inside flow collection, used as
            key</lineannotation>
            ( <nonterminal def="#c-ns-properties" /> <nonterminal def="#s-char" />+ )?<sbr />
            <nonterminal def="#ns-ns-scalar-key-value(n)" />
          </rhs>
        </production>

        <production id="c-l-scalar-blk-value(n)">
          <lhs>c-l-scalar-blk-value(n)</lhs>
          <rhs>
            <lineannotation>scalar value in block style</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-l-literal(n)" /><sbr />
            | <nonterminal def="#c-l-folded(n)" />
          </rhs>
        </production>

        <production id="ns-ns-scalar-flow-value(n)">
          <lhs>ns-ns-scalar-flow-value(n)</lhs>
          <rhs>
            <lineannotation>scalar value in flow style, used as value, inside
            flow collection</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-c-single-quoted(n)" /><sbr />
            | <nonterminal def="#c-c-double-quoted(n)" /><sbr />
            | <nonterminal def="#ns-ns-plain-flow(n)" />
          </rhs>
        </production>

        <production id="ns-ns-scalar-top-value(n)">
          <lhs>ns-ns-scalar-top-value(n)</lhs>
          <rhs>
            <lineannotation>scalar value in flow style, used as value, outside
            flow collection</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-c-single-quoted(n)" /><sbr />
            | <nonterminal def="#c-c-double-quoted(n)" /><sbr />
            | <nonterminal def="#ns-ns-plain-top(n)" />
          </rhs>
        </production>

        <production id="ns-ns-scalar-key-value(n)">
          <lhs>ns-ns-scalar-key-value(n)</lhs>
          <rhs>
            <lineannotation>scalar value in flow style, used as
            key</lineannotation>
            &nbsp;&nbsp;<nonterminal def="#c-c-single-quoted(n)" /><sbr />
            | <nonterminal def="#c-c-double-quoted(n)" /><sbr />
            | <nonterminal def="#ns-ns-plain-key" />
          </rhs>
        </production>
      </productionset>

      <sect2>
        <title>
          <anchor id="syntax-scalar-norm" />
          End Of line Normalization
        </title>

        <para>
          Inside all scalar nodes, a compliant YAML processor must translate
          the two-character combination <link
          linkend="b-carriage-return">CR</link> <link
          linkend="b-line-feed">LF</link>, any <link
          linkend="b-carriage-return">CR</link> that is not followed by an
          <link linkend="b-line-feed">LF</link>, and any <link
          linkend="b-next-line">NEL</link> into a single <link
          linkend="b-line-feed">LF</link> (this does not apply to <link
          linkend="syntax-escape">escaped characters</link>). <link
          linkend="b-line-separator">LS</link> and <link
          linkend="b-paragraph-separator">PS</link> characters are preserved.
          These rules are compatible with Unicode's <ulink
          url="http://www.unicode.org/unicode/reports/tr13/">newline
          guidelines</ulink>.
        </para>

        <para>
          Normalization functionality is indicated by the use of the <link
          linkend="b-as-line-feed"><userinput>b-as-line-feed</userinput></link>
          production defined below.
        </para>

        <productionset>
          <production id="b-as-line-feed">
            <lhs>b-as-line-feed</lhs>
            <rhs>
              <lineannotation>line break converted to a line
              feed</lineannotation>
              <nonterminal def="#b-generic" />
            </rhs>
          </production>

          <production id="b-normalized">
            <lhs>b-normalized</lhs>
            <rhs>
              <lineannotation>a normalized end of line marker</lineannotation>
              <nonterminal def="#b-as-line-feed" /> | <nonterminal def="#b-specific" />
            </rhs>
          </production>
        </productionset>

        <para>
          On output, a YAML processor is free to serialize end of line markers
          using whatever convention is most appropriate, though again <link
          linkend="b-line-separator">LS</link> and <link
          linkend="b-paragraph-separator">PS</link> must be preserved.
        </para>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-mod" />Block Modifiers</title>
        <para>
          Each block scalar may have <link
          linkend="syntax-scalar-indent">explicit indentation</link> and
          <link linkend="syntax-scalar-chomp">chomping</link> modifiers.
          These modifiers are specified following the block style indicator.
          It is an error for the same modifier to be specified more than
          once for the same node.
        </para>

        <productionset>
          <production id="ns-ns-blk-modifiers">
            <lhs>ns-ns-blk-modifiers</lhs>
            <rhs>
              <lineannotation>block scalar modifiers</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#ns-explicit-indent" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#c-chomp-control" />? )<sbr />
              | ( <nonterminal def="#c-chomp-control" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-explicit-indent" />? )
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title>
          <anchor id="syntax-scalar-indent" />
          Explicit Indentation
        </title>

        <para>
          Typically the indentation level of a block scalar node is detected
          from its first non-empty content line. This detection fails when this
          first non-empty line contains leading white space characters. Note
          that content lines, including the first non-empty content line, may
          begin with a <quote><userinput>#</userinput></quote> character.
        </para>

        <para>
          When the first non-empty content line begins with spaces, YAML
          requires that the indentation level for the scalar node text content
          be given explicitly. This level is specified as the integer number of
          the additional indentation spaces used for the text content.
        </para>

        <para>
          If the block scalar begins with lines containing only spaces, and no
          explicit indentation is given, the processor assumes such lines are
          empty lines. It is an error for any such leading empty line to
          contain more spaces than the indentation level that is deduced from
          the first non-empty content line.
        </para>

        <para>
          The indentation level is always non-zero, except for the top level
          node of each document. This node is commonly indented by zero spaces
          (not indented). When the content is not indented, all lines up to the
          next document separator, document terminator, or end of the stream
          are assumed to be content lines, even if they begin with a
          <quote><userinput>#</userinput></quote> character. Note that in this
          case, all lines up to the next document seperator are assumed to be
          content lines, even if they begin with a
          <quote><userinput>#</userinput></quote> character.
        </para>

        <para>
          It is always valid to specify an explicit indentation level, though a
          YAML processor should only do so in cases where detection fails. It
          is an error for detection to fail when there is no explicit
          indentation specified.
        </para>

        <productionset>
          <production id="ns-explicit-indent">
            <lhs>ns-explicit-indent</lhs>
            <rhs>
              <lineannotation>explicit additional indentation
              level</lineannotation>
              <nonterminal def="#ns-decimal-digit" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
# Explicit indentation must be given
# in both the following cases.
leading spaces: |2
      This value starts with four spaces.

leading spaces after empty lines: |2

      This value starts with four spaces.

# The following is valid:
leading comment indicator: |

  # Content line starts with a '#'
  character, and follows empty lines.

# This is a comment because it is not
# more indented than the base level.
# Since blocks may not contain comments,
# this ends the block and the following
# empty line is not a content line.

# Explicit indentation may
# also be given when it is
# not required.
redundant: |2
  This value is indented 2 spaces.

# Indentation applies to top level nodes.
--- |
Usually top level nodes are not indented.
--- |
  This text is indented two spaces.
  It contains no leading spaces.
--- |0
  This text contains two leading spaces.
---
This text is not indented, so
# this is a content line and
--- |
  However, this is indented two spaces
# So this is a comment ending the block.
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-chomp" />Chomping</title>
        <para>
          Typically the final line break of a block scalar is considered to be
          a part of its value, and any trailing empty lines are taken to be
          <link linkend="l-empty-comment(n)">comment lines</link>. This default
          <firstterm>clip</firstterm> chomping behavior can be overriden by
          specifying a chomp control modifier.
        </para>

        <productionset>
          <production id="c-chomp-control">
            <lhs>c-chomp-control</lhs>
            <rhs>
              <lineannotation>override the default "clip"
              chomping</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#c-strip-chomp" /><sbr />
              | <nonterminal def="#c-keep-chomp" />
            </rhs>
          </production>

          <production id="c-strip-chomp">
            <lhs>c-strip-chomp</lhs>
            <rhs>
              <lineannotation>strip final line break from
              value</lineannotation>
              <quote>-</quote>
            </rhs>
          </production>

          <production id="c-keep-chomp">
            <lhs>c-keep-chomp</lhs>
            <rhs>
              <lineannotation>keep trailing line breaks in
              value</lineannotation>
              <quote>+</quote>
            </rhs>
          </production>
        </productionset>

        <variablelist>
          <varlistentry>
            <term>
                <firstterm>strip</firstterm>
                (<quote><userinput>-</userinput></quote>)
            </term>

            <listitem>
              The <quote><userinput>-</userinput></quote> chomp control
              specifies that the final line break character of the block scalar
              should be stripped from its value.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>
                <firstterm>keep</firstterm>
                (<quote><userinput>+</userinput></quote>)
            </term>

            <listitem>
              The <quote><userinput>+</userinput></quote> chomp control
              specifies that any trailing empty lines following the block
              scalar should be considered to be a part of its value. If this
              modifier is not specified, such lines are considered to be empty
              throwaway comment lines and are ignored.
            </listitem>
          </varlistentry>
        </variablelist>

        <para>
          When this functionality is implied, the <link
          linkend="l-l-empty-trailing(n)"
          ><userinput>l-l-empty-trailing(n)</userinput></link> production will
          be used.
        </para>

        <productionset>
          <production id="l-l-empty-trailing(n)">
            <lhs>l-l-empty-trailing(n)</lhs>
            <rhs>
              <lineannotation>trailing line feeds or comment lines, depending
              on chomp control)</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#l-empty-comment(n)" />+<sbr />
              | <nonterminal def="#l-blk-empty-line-feed(n)" />+
            </rhs>
          </production>

          <production id="l-blk-empty-line-feed(n)">
            <lhs>l-blk-empty-line-feed(n)</lhs>
            <rhs>
              <lineannotation>empty block line</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal> <nonterminal def="#b-as-line-feed" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
clipped: |
    This has one newline.

same as "clipped" above: "This has one newline.\n"

stripped: |-
    This has no newline.

same as "stripped" above: "This has no newline."

kept: |+
    This has two newlines.

same as "kept" above: "This has two newlines.\n\n"
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-literal" />Literal</title>

        <para>
          A literal scalar is the simplest scalar style. No processing is
          performed on literal scalar characters aside from <link
          linkend="syntax-scalar-norm">end of line normalization</link> and
          stripping away the <link
          linkend="syntax-indentation">indentation</link>. Indentation is
          detected from the first non-empty content line. <link
          linkend="syntax-scalar-indent">Explicit indentation</link> must be
          specified in case this yields the wrong result.
        </para>

        <para>
          Since escaping is not done, the literal style is restricted to <link
          linkend="c-printable">printable characters</link> and long lines
          cannot be wrapped. In exchange for these restrictions, literal
          scalars are the  most readable format for source code or other text
          values with  significant use of indicators, quotes, escape sequences,
          and  line breaks.
        </para>

        <productionset>
          <production id="c-l-literal(n)">
            <lhs>c-l-literal(n)</lhs>
            <rhs>
              <lineannotation>literal scalar</lineannotation>
              <nonterminal def="#c-literal"><quote>|</quote></nonterminal>
              <nonterminal def="#ns-ns-blk-modifiers" />?<sbr />
              <nonterminal def="#s-b-trailing-comment" /><sbr />
              <nonterminal def="#l-l-literal-value(n)" />?<sbr />
              <nonterminal def="#l-l-empty-trailing(n)" />?<sbr />
              ( <nonterminal def="#l-text-comment(n)">l-text-comment(&lt;n)</nonterminal><sbr />
              &nbsp;&nbsp;<nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>* )?
            </rhs>
          </production>

          <production id="l-l-literal-value(n)">
            <lhs>l-l-literal-value(n)</lhs>
            <rhs>
              <lineannotation>value of literal scalar</lineannotation>
              <nonterminal def="#l-l-literal-chunk(n)" />+
            </rhs>
          </production>

          <production id="l-l-literal-chunk(n)">
            <lhs>l-l-literal-chunk(n)</lhs>
            <rhs>
              <lineannotation>chunk of literal scalar lines</lineannotation>
              <nonterminal def="#l-blk-empty-line-feed(n)" />*<sbr />
              ( <nonterminal def="#l-literal-text(n)" /><sbr />
              | <nonterminal def="#l-blk-empty-specific(n)" /> )
            </rhs>
          </production>

          <production id="l-blk-empty-specific(n)">
            <lhs>l-blk-empty-specific(n)</lhs>
            <rhs>
              <lineannotation>empty block line with preserved specific line
              break</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal> <nonterminal def="#b-specific" />
            </rhs>
          </production>

          <production id="l-literal-text(n)">
            <lhs>l-literal-text(n)</lhs>
            <rhs>
              <lineannotation>literal line character data</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#i-spaces(n)" /> <nonterminal def="#nb-char" />+ <nonterminal def="#b-normalized" /> )<sbr />
              - ( <nonterminal def="#l-forbidden-non-indented" /> <nonterminal def="#b-any" /> )
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: |

literal: |
 The \ ' " characters may be
 freely used. Leading white
    space is significant.

 Line breaks are significant. Thus this value
 contains one empty line and ends with a single
 line break, but does not start with one.

is equal to: "The \\ ' \" characters may \
 be\nfreely used. Leading white\n   space \
 is significant.\n\nLine breaks are \
 significant. Thus this value\ncontains \
 one empty line and ends with a single\nline \
 break, but does not start with one.\n"

# Comments may follow a block scalar value.
# They must be less indented.

# Modifiers may be combined in any order.
indented and chomped: |2-
    This has no newline.

also written as: |-2
    This has no newline.

both are equal to: "  This has no newline."
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-folding" />Folding</title>

        <para>
          Folding supports scenarios where word-wrapping is useful for
          presentation, where the serialized content does not contain line
          breaks at convenient places.

          <remark>
            TODO: Rephrase.
          </remark>
        </para>

        <para>
          When folding is done, a single <link
          linkend="b-as-line-feed">normalized line feed</link> is converted to
          a single space (<userinput>#x20</userinput>). When two or more
          consecutive (possibly indented) normalized line feeds are
          encountered, the processor does not convert them into spaces.
          Instead, the parser ignores the first line feed and preserves the
          rest. Thus a single line feed can be serialized as two, two line
          feeds can be serialized as three, etc. In this process, <link
          linkend="b-specific">specific line breaks</link> are preserved and
          may be safely used to convey text structure.
        </para>

        <para>
          Since scalars come in both a block and flow variants, folding
          behavior must be defined in both contexts.

        </para>

        <sect3>
          <title>
            <anchor id="syntax-scalar-folding-block" />
            Folding in a block context
          </title>

          <para>
            When folding block scalars, space conversion only applies to  line
            feeds separating text lines having a non-space starting  character.
            Hence, folding does not apply to leading line feeds, line feeds
            surrounding a specific line break, or line feeds adjacent to a text
            line that starts with a space character.
          </para>

          <para>
            The combined effect of the processing rules above is that each
            "paragraph" is interpreted as a single line, empty lines are used
            to represent a line feed, and "more indented" lines are preserved.
            Also, specific line breaks may be safely used to indicate text
            structure.
          </para>

          <productionset>
            <production id="b-as-space">
              <lhs>b-as-space</lhs>
              <rhs>
                <lineannotation>line feed converted to a
                space</lineannotation>
                <nonterminal def="#b-generic" />
              </rhs>
            </production>

            <production id="b-ignored">
              <lhs>b-ignored</lhs>
              <rhs>
                <lineannotation>ignored line feed</lineannotation>
                <nonterminal def="#b-generic" />
              </rhs>
            </production>

            <production id="b-l-blk-trimmed(n)">
              <lhs>b-l-blk-trimmed(n)</lhs>
              <rhs>
                <lineannotation>sequence of line feeds in block
                scalar</lineannotation>
                <nonterminal def="#b-ignored" /><sbr />
                <nonterminal def="#l-blk-empty-line-feed(n)" />+
              </rhs>
            </production>
          </productionset>
        </sect3>

        <sect3>
          <title>
            <anchor id="syntax-scalar-folding-flow" />
            Folding flow scalars
          </title>

          <para>
            When folding is applied in a flow context, the process is somewhat
            different. Flow scalars depend on explicit indicators  to convey
            structure, rather than indentation. Hence, in such  scalars, all
            line space preceding or following a line break is  not considered
            to be part of the scalar value. Hence folding  flow scalars
            provides a more relaxed, less powerful semantics. In flow scalars,
            folding strips all leading and trailing white  space, further, all
            generic line breaks are folded, even if the line was "more
            indented".
          </para>

          <para>
            The combined effect of these processing rules is that each
            "paragraph" is interpreted as a single line, empty lines are used
            to represent a line feed, and text can be freely "indented" without
            affecting the scalar value. Again, specific line breaks may be
            safely used to indicate text structure.
          </para>

          <productionset>
            <production id="i-s-ignored-leading(n)">
              <lhs>i-s-ignored-leading(n)</lhs>
              <rhs>
                <lineannotation>ignored spaces at start of flow scalar
                line</lineannotation>
                <nonterminal def="#i-spaces(n)" /> <nonterminal def="#s-char" />+
              </rhs>
            </production>

            <production id="s-s-ignored-trailing">
              <lhs>s-s-ignored-trailing</lhs>
              <rhs>
                <lineannotation>ignored spaces at end of flow scalar
                line</lineannotation>
                <nonterminal def="#s-char" />+
              </rhs>
            </production>

            <production id="l-flow-empty-specific(n)">
              <lhs>l-flow-empty-specific(n)</lhs>
              <rhs>
                <lineannotation>empty flow line with preserved specific line
                break</lineannotation>
                ( <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal><sbr />
                | <nonterminal def="#i-s-ignored-leading(n)" /> )<sbr />
                <nonterminal def="#b-specific" />
              </rhs>
            </production>

            <production id="l-flow-empty-line-feed(n)">
              <lhs>l-flow-empty-line-feed(n)</lhs>
              <rhs>
                <lineannotation>empty flow line with line break normalized to
                line feed</lineannotation>
                ( <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal><sbr />
                | <nonterminal def="#i-s-ignored-leading(n)" /> )<sbr />
                <nonterminal def="#b-as-line-feed" />
              </rhs>
            </production>

            <production id="b-l-flow-trimmed(n)">
              <lhs>b-l-flow-trimmed(n)</lhs>
              <rhs>
                <lineannotation>sequence of line feeds in flow
                scalar</lineannotation>
                <nonterminal def="#b-ignored" /><sbr />
                <nonterminal def="#l-flow-empty-line-feed(n)" />+
              </rhs>
            </production>

            <production id="s-l-end-flow-line(n)">
              <lhs>s-l-end-flow-line(n)</lhs>
              <rhs>
                <lineannotation>end of a line in a multi-line flow
                scalar</lineannotation>
                <nonterminal def="#s-s-ignored-trailing" /><sbr />
                ( <nonterminal def="#b-as-space" /><sbr />
                | <nonterminal def="#b-l-flow-trimmed(n)" /><sbr />
                | <nonterminal def="#b-specific" /> )
              </rhs>
            </production>
          </productionset>
        </sect3>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-folded" />Folded</title>

        <para>
          A folded scalar is similar to a <link
          linkend="syntax-scalar-literal">literal scalar</link>. However,
          unlike a literal scalar, a folded scalar is subject to (block) <link
          linkend="syntax-scalar-folding-block">line folding</link>. This
          allows long lines to be broken anywhere a space character
          (<userinput>#x20</userinput>) appears, at the cost of requiring an
          empty line to represent each <link linkend="b-line-feed">line
          feed</link> character.
        </para>

        <productionset>
          <production id="c-l-folded(n)">
            <lhs>c-l-folded(n)</lhs>
            <rhs>
              <lineannotation>folded scalar</lineannotation>
              <nonterminal def="#c-folded"><quote>&gt;</quote></nonterminal>
              <nonterminal def="#ns-ns-blk-modifiers" /><sbr />
              <nonterminal def="#s-b-trailing-comment" /><sbr />
              <nonterminal def="#l-l-folded-value(n)" />?<sbr />
              <nonterminal def="#l-l-empty-trailing(n)" />?<sbr />
              ( <nonterminal def="#l-text-comment(n)">l-text-comment(&lt;n)</nonterminal><sbr />
              &nbsp;&nbsp;<nonterminal def="#l-comment(n)">l-comment(any)</nonterminal>* )?
            </rhs>
          </production>

          <production id="l-l-folded-value(n)">
            <lhs>l-l-folded-value(n)</lhs>
            <rhs>
              <lineannotation>value of folded scalar</lineannotation>
              <nonterminal def="#l-blk-empty-line-feed(n)" />*<sbr />
              ( <nonterminal def="#l-l-folded-chunk(n)" /><sbr />
              | <nonterminal def="#l-l-non-folded-chunk(n)" /> )
            </rhs>
          </production>

          <production id="l-l-folded-chunk(n)">
            <lhs>l-l-folded-chunk(n)</lhs>
            <rhs>
              <lineannotation>value starting with a chunk of folded
              text</lineannotation>
              ( <nonterminal def="#i-nb-folded-paragraph(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#b-l-blk-trimmed(n)" /> )*<sbr />
              <nonterminal def="#i-nb-folded-paragraph(n)" /><sbr />
              <nonterminal def="#b-l-after-folded-chunk(n)" />
            </rhs>
          </production>

          <production id="i-nb-folded-paragraph(n)">
            <lhs>i-nb-folded-paragraph(n)</lhs>
            <rhs>
              <lineannotation>single content paragraph folded into multiple
              physical lines</lineannotation>
              ( <nonterminal def="#i-nb-folded-text(n)" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#b-as-space" /> )*<sbr />
              <nonterminal def="#i-nb-folded-text(n)" />
            </rhs>
          </production>

          <production id="i-nb-folded-text(n)">
            <lhs>i-nb-folded-text(n)</lhs>
            <rhs>
              <lineannotation>folded text line characters</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#i-spaces(n)" /> <nonterminal def="#ns-char" /> <nonterminal def="#nb-char" />* )<sbr />
              - <nonterminal def="#l-forbidden-non-indented" />
            </rhs>
          </production>

          <production id="b-l-after-folded-chunk(n)">
            <lhs>b-l-after-folded-chunk(n)</lhs>
            <rhs>
              <lineannotation>text following a folded text
              chunk</lineannotation>
              <nonterminal def="#b-normalized" /><sbr />
              ( <nonterminal def="#l-blk-empty-line-feed(n)" />*<sbr />
              &nbsp;&nbsp;<nonterminal def="#l-l-non-folded-chunk(n)" /> )?
            </rhs>
          </production>

          <production id="l-l-non-folded-chunk(n)">
            <lhs>l-l-non-folded-chunk(n)</lhs>
            <rhs>
              <lineannotation>value starting with non-folded text
              chunk</lineannotation>
              ( <nonterminal def="#l-empty-non-folded(n)" /><sbr />
              | <nonterminal def="#l-indented-non-folded(n)" /> )<sbr />
              <nonterminal def="#l-l-folded-value(n)" />?
            </rhs>
          </production>

          <production id="l-empty-non-folded(n)">
            <lhs>l-empty-non-folded(n)</lhs>
            <rhs>
              <lineannotation>not folded due to specific line
              break</lineannotation>
              <nonterminal def="#i-spaces(n)">i-spaces(&les;n)</nonterminal> <nonterminal def="#b-specific" />
            </rhs>
          </production>

          <production id="l-indented-non-folded(n)">
            <lhs>l-indented-non-folded(n)</lhs>
            <rhs>
              <lineannotation>not folded due to starting white
              space</lineannotation>
              <nonterminal def="#i-spaces(n)" /> <nonterminal def="#s-char" /> <nonterminal def="#nb-char" />*<sbr />
              <nonterminal def="#b-normalized" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: &gt;

one paragraph: &gt;
 Line feeds are converted to spaces,
 so this value contains no line
 breaks except for the final one.

multiple paragraphs: &gt;2

  An empty line, either at
  the start or in the value:

  Is interpreted as a line
  break. Thus this value
  contains three line breaks.

indented text: &gt;
    This is a folded paragraph
    followed by a list:
     * first entry
     * second entry
    Followed by another folded
    paragraph, another list:

     * first entry

     * second entry

    And a final folded
    paragraph.

above is equal to: |
    This is a folded paragraph followed by a list:
     * first entry
     * second entry
    Followed by another folded paragraph, another list:

     * first entry

     * second entry

    And a final folded paragraph.

# Explicit comments may follow
# but must be less indented.
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-single" />Single Quoted</title>

        <para>
          The single quoted flow scalar style is indicated by surrounding
          <link
          linkend="c-single-quote"><quote><userinput
          >'</userinput></quote></link>
          characters. Therefore, within a single quoted scalar such
          characters need to be <link
          linkend="ns-escaped-single-quote">escaped</link>. No other form of
          escaping is done, limiting single quoted scalars to printable
          characters.
        </para>

        <para>
          Single quoted scalars are subject to (flow) <link
          linkend="syntax-scalar-folding-flow">folding</link>. This allows
          empty lines to be broken everywhere a single space character
          (<userinput>#x20</userinput>) separates non-space characters, at the
          cost of requiring an empty line to represent each <link
          linkend="b-line-feed">line feed</link> character.
        </para>

        <productionset>
          <production id="c-c-single-quoted(n)">
            <lhs>c-c-single-quoted(n)</lhs>
            <rhs>
              <lineannotation>single quoted scalar</lineannotation>
              <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal>
              <nonterminal def="#nb-nb-single-quoted-value(n)" />?
              <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-nb-single-quoted-value(n)">
            <lhs>nb-nb-single-quoted-value(n)</lhs>
            <rhs>
              <lineannotation>value of a single quoted scalar</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#nb-nb-one-single-line" /><sbr />
              | ( <nonterminal def="#nb-l-first-single-line(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-l-inner-single-line(n)" />*<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-nb-last-single-line(n)" /> )
            </rhs>
          </production>

          <production id="nb-nb-one-single-line">
            <lhs>nb-nb-one-single-line</lhs>
            <rhs>
              <lineannotation>one line value of single quoted
              scalar</lineannotation>
              <nonterminal def="#nb-single-char" />+
            </rhs>
          </production>

          <production id="nb-l-first-single-line(n)">
            <lhs>nb-l-first-single-line(n)</lhs>
            <rhs>
              <lineannotation>first line of multi-line single quoted
              scalar</lineannotation>
              ( <nonterminal def="#nb-single-char" />* <nonterminal def="#ns-single-char" /> )?<sbr />
              <nonterminal def="#s-l-end-flow-line(n)" />
            </rhs>
          </production>

          <production id="l-l-inner-single-line(n)">
            <lhs>l-l-inner-single-line(n)</lhs>
            <rhs>
              <lineannotation>inner line of multi-line single quoted
              scalar</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#l-flow-empty-specific(n)" /><sbr />
              | ( <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-single-char" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#nb-l-first-single-line(n)" /> )
            </rhs>
          </production>

          <production id="i-nb-last-single-line(n)">
            <lhs>i-nb-last-single-line(n)</lhs>
            <rhs>
              <lineannotation>last line of multi-line single quoted
              scalar</lineannotation>
              <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              ( <nonterminal def="#ns-single-char" /> <nonterminal def="#nb-single-char" />* )?
            </rhs>
          </production>

          <production id="ns-escaped-single-quote">
            <lhs>ns-escaped-single-quote</lhs>
            <rhs>
              <lineannotation>indicates a single quote</lineannotation>
              <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal> <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-single-char">
            <lhs>nb-single-char</lhs>
            <rhs>
              <lineannotation>non-break char valid in a single quoted
              scalar</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-escaped-single-quote" /><sbr />
              | ( <nonterminal def="#nb-char" /> - <nonterminal def="#c-single-quote"><quote>'</quote></nonterminal> )
            </rhs>
          </production>

          <production id="ns-single-char">
            <lhs>ns-single-char</lhs>
            <rhs>
              <lineannotation>non-space char valid in a single quoted
              scalar</lineannotation>
              <nonterminal def="#nb-single-char" /> - <nonterminal def="#s-char" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: ''
second:
  '! : \ etc. can be used freely.'
third: 'a single quote '' must be escaped.'
span: 'this contains
      six spaces

      and one
      line break'
is same as: "this contains six spaces\nand one line break"
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-escape" />Escaping</title>

        <para>
          Escaping allows YAML scalar nodes to specify arbitrary Unicode
          characters, using C-style escape codes. Non-escaped nodes are
          restricted to <link linkend="c-printable">printable Unicode
          characters</link>.
        </para>

        <productionset>
          <production id="c-escape">
            <lhs>c-escape</lhs>
            <rhs>
              <lineannotation>escape character</lineannotation>
              <quote>\</quote>
            </rhs>
          </production>

          <production id="ns-esc-escape">
            <lhs>ns-esc-escape</lhs>
            <rhs>
              <lineannotation>escaped backslash</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <nonterminal def="#c-escape"><quote>\</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-esc-double-quote">
            <lhs>ns-esc-double-quote</lhs>
            <rhs>
              <lineannotation>escaped double quote character</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal>
            </rhs>
          </production>

          <production id="ns-esc-bel">
            <lhs>ns-esc-bel</lhs>
            <rhs>
              <lineannotation>aSCII alert (BEL)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>a</quote>
            </rhs>
          </production>

          <production id="ns-esc-backspace">
            <lhs>ns-esc-backspace</lhs>
            <rhs>
              <lineannotation>aSCII backspace (BS)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>b</quote>
            </rhs>
          </production>

          <production id="ns-esc-esc">
            <lhs>ns-esc-esc</lhs>
            <rhs>
              <lineannotation>aSCII escape (ESC)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>e</quote>
            </rhs>
          </production>

          <production id="ns-esc-form-feed">
            <lhs>ns-esc-form-feed</lhs>
            <rhs>
              <lineannotation>aSCII formfeed (FF)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>f</quote>
            </rhs>
          </production>

          <production id="ns-esc-line-feed">
            <lhs>ns-esc-line-feed</lhs>
            <rhs>
              <lineannotation>aSCII linefeed (LF)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>n</quote>
            </rhs>
          </production>

          <production id="ns-esc-return">
            <lhs>ns-esc-return</lhs>
            <rhs>
              <lineannotation>aSCII carriage return (CR)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>r</quote>
            </rhs>
          </production>

          <production id="ns-esc-tab">
            <lhs>ns-esc-tab</lhs>
            <rhs>
              <lineannotation>aSCII horizontal tab (TAB)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>t</quote>
            </rhs>
          </production>

          <production id="ns-esc-vertical-tab">
            <lhs>ns-esc-vertical-tab</lhs>
            <rhs>
              <lineannotation>aSCII vertical tab (VTAB)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>v</quote>
            </rhs>
          </production>

          <production id="ns-esc-hat">
            <lhs>ns-esc-hat</lhs>
            <rhs>
              <lineannotation>aSCII hat (CIRCUMFLEX ACCENT)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>^</quote>
            </rhs>
          </production>

          <production id="ns-esc-null">
            <lhs>ns-esc-null</lhs>
            <rhs>
              <lineannotation>aSCII zero (NUL)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>0</quote>
            </rhs>
          </production>

          <production id="ns-esc-space">
            <lhs>ns-esc-space</lhs>
            <rhs>
              <lineannotation>aSCII space (SP)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> #20
            </rhs>
          </production>

          <production id="ns-esc-non-breaking-space">
            <lhs>ns-esc-non-breaking-space</lhs>
            <rhs>
              <lineannotation>unicode non-breaking space
              (NBSP)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>_</quote>
            </rhs>
          </production>

          <production id="ns-esc-next-line">
            <lhs>ns-esc-next-line</lhs>
            <rhs>
              <lineannotation>unicode next line (NEL)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>N</quote>
            </rhs>
          </production>

          <production id="ns-esc-line-separator">
            <lhs>ns-esc-line-separator</lhs>
            <rhs>
              <lineannotation>unicode line separator (LS)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>L</quote>
            </rhs>
          </production>

          <production id="ns-esc-paragraph-separator">
            <lhs>ns-esc-paragraph-separator</lhs>
            <rhs>
              <lineannotation>unicode paragraph separator (PS)</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>P</quote>
            </rhs>
          </production>

          <production id="ns-esc-8-bit">
            <lhs>ns-esc-8-bit</lhs>
            <rhs>
              <lineannotation>8-bit character</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>x</quote> ( <nonterminal def="#ns-hex-digit" /> x 2 )
            </rhs>
          </production>

          <production id="ns-esc-16-bit">
            <lhs>ns-esc-16-bit</lhs>
            <rhs>
              <lineannotation>16-bit character</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>u</quote> ( <nonterminal def="#ns-hex-digit" /> x 4 )
            </rhs>
          </production>

          <production id="ns-esc-32-bit">
            <lhs>ns-esc-32-bit</lhs>
            <rhs>
              <lineannotation>32-bit character</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <quote>U</quote> ( <nonterminal def="#ns-hex-digit" /> x 8 )
            </rhs>
          </production>

          <production id="ns-esc-sequence">
            <lhs>ns-esc-sequence</lhs>
            <rhs>
              <lineannotation>escape codes in escaped scalars</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-esc-escape" /><sbr />
              | <nonterminal def="#ns-esc-double-quote" /><sbr />
              | <nonterminal def="#ns-esc-bel" /><sbr />
              | <nonterminal def="#ns-esc-backspace" /><sbr />
              | <nonterminal def="#ns-esc-esc" /><sbr />
              | <nonterminal def="#ns-esc-form-feed" /><sbr />
              | <nonterminal def="#ns-esc-line-feed" /><sbr />
              | <nonterminal def="#ns-esc-return" /><sbr />
              | <nonterminal def="#ns-esc-tab" /><sbr />
              | <nonterminal def="#ns-esc-vertical-tab" /><sbr />
              | <nonterminal def="#ns-esc-hat" /><sbr />
              | <nonterminal def="#ns-esc-null" /><sbr />
              | <nonterminal def="#ns-esc-space" /><sbr />
              | <nonterminal def="#ns-esc-non-breaking-space" /><sbr />
              | <nonterminal def="#ns-esc-next-line" /><sbr />
              | <nonterminal def="#ns-esc-line-separator" /><sbr />
              | <nonterminal def="#ns-esc-paragraph-separator" /><sbr />
              | <nonterminal def="#ns-esc-8-bit" /><sbr />
              | <nonterminal def="#ns-esc-16-bit" /><sbr />
              | <nonterminal def="#ns-esc-32-bit" />
            </rhs>
          </production>
        </productionset>

        <para>
          An escaped line break is completely ignored.
        </para>

        <productionset>
          <production id="b-escaped">
            <lhs>b-escaped</lhs>
            <rhs>
              <lineannotation>escaped (ignored) line break</lineannotation>
              <nonterminal def="#c-escape"><quote>\</quote></nonterminal> <nonterminal def="#b-any" />
            </rhs>
          </production>
        </productionset>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-double" />Double Quoted</title>

        <para>
          The double quoted style variant adds <link
          linkend="syntax-escape">escaping</link> to the <link
          linkend="syntax-single">single quoted</link> style variant. This is
          indicated by surrounding <link linkend="c-double-quote"
          ><quote><userinput>"</userinput></quote></link> characters. Escaping
          allows arbitrary Unicode characters to be specified at the cost of
          some verbosity: escaping the printable <link
          linkend="c-escape"><quote><userinput>\</userinput></quote></link> and
          <link linkend="c-double-quote"
          ><quote><userinput>"</userinput></quote></link> characters. It is an
          error for a double quoted value to contain invalid escape sequences.
        </para>

        <para>
          Like single quoted scalars, double quoted scalars may span multiple
          lines, resulting in a single space content character for each line
          break. If the line break is escaped, any white space preceding it is
          preserved, and the line break and any leading white space in the
          continuation line are discarded.
        </para>

        <productionset>
          <production id="c-c-double-quoted(n)">
            <lhs>c-c-double-quoted(n)</lhs>
            <rhs>
              <lineannotation>double quoted scalar</lineannotation>
              <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal>
              <nonterminal def="#nb-nb-double-quoted-value(n)" />?
              <nonterminal def="#c-double-quote"><quote>"</quote></nonterminal>
            </rhs>
          </production>

          <production id="nb-nb-double-quoted-value(n)">
            <lhs>nb-nb-double-quoted-value(n)</lhs>
            <rhs>
              <lineannotation>value of a double quoted scalar</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#nb-nb-one-double-line" /><sbr />
              | ( <nonterminal def="#nb-l-first-double-line(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-l-inner-double-line(n)" />*<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-nb-last-double-line(n)" /> )
            </rhs>
          </production>

          <production id="nb-nb-one-double-line">
            <lhs>nb-nb-one-double-line</lhs>
            <rhs>
              <lineannotation>one line value of double quoted
              scalar</lineannotation>
              <nonterminal def="#nb-double-char" />+
            </rhs>
          </production>

          <production id="nb-l-first-double-line(n)">
            <lhs>nb-l-first-double-line(n)</lhs>
            <rhs>
              <lineannotation>first line of multi-line double quoted
              scalar</lineannotation>
              ( <nonterminal def="#nb-double-char" />* <nonterminal def="#ns-double-char" /> )?<sbr />
              <nonterminal def="#s-l-end-double-line(n)" />
            </rhs>
          </production>

          <production id="l-l-inner-double-line(n)">
            <lhs>l-l-inner-double-line(n)</lhs>
            <rhs>
              <lineannotation>inner line of multi-line double quoted
              scalar</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#l-flow-empty-specific(n)" /><sbr />
              | ( <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-double-char" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#nb-l-first-double-line(n)" /> )
            </rhs>
          </production>

          <production id="i-nb-last-double-line(n)">
            <lhs>i-nb-last-double-line(n)</lhs>
            <rhs>
              <lineannotation>last line of multi-line double quoted
              scalar</lineannotation>
              <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              ( <nonterminal def="#ns-double-char" /> <nonterminal def="#nb-double-char" />* )?
            </rhs>
          </production>

          <production id="s-l-end-double-line(n)">
            <lhs>s-l-end-double-line(n)</lhs>
            <rhs>
              <lineannotation>end of a line in a multi-line double quoted
              scalar</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#s-l-end-flow-line(n)" /><sbr />
              | ( <nonterminal def="#s-char" />* <nonterminal def="#b-escaped" /> )
            </rhs>
          </production>

          <production id="nb-double-char">
            <lhs>nb-double-char</lhs>
            <rhs>
              <lineannotation>non-break char valid in a double quoted
              scalar</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-esc-sequence" /><sbr />
              | ( <nonterminal def="#nb-char" /> - <nonterminal def="#c-escape"><quote>\</quote></nonterminal> )
            </rhs>
          </production>

          <production id="ns-double-char">
            <lhs>ns-double-char</lhs>
            <rhs>
              <lineannotation>non-space char valid in a double quoted
              scalar</lineannotation>
              <nonterminal def="#nb-double-char" /> - <nonterminal def="#s-char" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
empty: ""
second: "! : etc. can be used freely."
third: "a \" or a \\ must be escaped."
fourth:
  "this value ends with an LF.\n"
span: "this contains
  four  \
      spaces"
is equal to: "this contains four  spaces"
</programlisting>
        </example>
      </sect2>

      <sect2>
        <title><anchor id="syntax-scalar-plain" />Plain</title>

        <para>
          The plain style variant is a restricted form of the <link
          linkend="syntax-single">single quoted</link> style variant. As it has
          no identifying markers, it may not start or end with white space
          characters, may not start with most <link
          linkend="syntax-indicator">indicators</link>, and may not
          contain certain indicators. Also, a plain scalar is subject to <link
          linkend="model-resolve">implicit typing</link>. This can be
          avoided by providing a explicit<link linkend="syntax-tag">tag
          property</link>.
        </para>

        <para>
          Since it lacks identifying markers, the restrictions on a plain
          scalar depends on the context. There are three different such
          contexts, with increasing restrictions. Top level plain values are
          the least restricted plain scalar format. While they can't start with
          <link linkend="ns-first-plain-char">most indicators</link>, they may
          contain any indicator except <link linkend="c-throwaway"
          ><quote>&nbsp;<userinput>#</userinput></quote></link> and <link
          linkend="c-mapping-entry"
          ><quote><userinput>:</userinput>&nbsp;</quote></link>. Plain scalars
          used in flow collections are further restricted not to contain <link
          linkend="nb-plain-flow-char">flow indicators</link>. Finally, plain
          keys are further restricted to a single line.
        </para>

        <productionset>
          <production id="ns-ns-plain-top(n)">
            <lhs>ns-ns-plain-top(n)</lhs>
            <rhs>
              <lineannotation>avoiding top indicator chars</lineannotation>
              <nonterminal def="#ns-ns-plain-value(n)" />
            </rhs>
          </production>

          <production id="ns-ns-plain-flow(n)">
            <lhs>ns-ns-plain-flow(n)</lhs>
            <rhs>
              <lineannotation>avoiding flow indicator chars</lineannotation>
              <nonterminal def="#ns-ns-plain-value(n)" />
            </rhs>
          </production>

          <production id="ns-ns-plain-key">
            <lhs>ns-ns-plain-key</lhs>
            <rhs>
              <lineannotation>plain scalar used as a key; avoiding flow
              indicator chars</lineannotation>
              <nonterminal def="#ns-ns-one-plain-line" />
            </rhs>
          </production>

          <production id="ns-ns-plain-value(n)">
            <lhs>ns-ns-plain-value(n)</lhs>
            <rhs>
              <lineannotation>plain scalar used as a value</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#ns-ns-one-plain-line" /><sbr />
              | ( <nonterminal def="#ns-l-first-plain-line(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#l-l-inner-plain-line(n)" />*<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#i-ns-last-plain-line(n)" /> )
            </rhs>
          </production>

          <production id="ns-ns-one-plain-line">
            <lhs>ns-ns-one-plain-line</lhs>
            <rhs>
              <lineannotation>plain one-line value</lineannotation>
              <nonterminal def="#ns-first-plain-char" /><sbr />
              <nonterminal def="#nb-ns-plain-text" />?
            </rhs>
          </production>

          <production id="ns-l-first-plain-line(n)">
            <lhs>ns-l-first-plain-line(n)</lhs>
            <rhs>
              <lineannotation>first line of multi-line plain
              scalar</lineannotation>
              <nonterminal def="#ns-ns-one-plain-line" /><sbr />
              <nonterminal def="#s-l-end-flow-line(n)" />
            </rhs>
          </production>

          <production id="l-l-inner-plain-line(n)">
            <lhs>l-l-inner-plain-line(n)</lhs>
            <rhs>
              <lineannotation>inner line of multi-line plain
              scalar</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#l-flow-empty-specific(n)" /><sbr />
              | ( <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-plain-char" /><sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#nb-ns-plain-text" />?<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#s-l-end-flow-line(n)" /> )
            </rhs>
          </production>

          <production id="i-ns-last-plain-line(n)">
            <lhs>i-ns-last-plain-line(n)</lhs>
            <rhs>
              <lineannotation>last line of multi-line plain
              scalar</lineannotation>
              <nonterminal def="#i-s-ignored-leading(n)" /><sbr />
              ( <nonterminal def="#ns-plain-char" /><sbr />
              &nbsp;&nbsp;<nonterminal def="#nb-ns-plain-text" />? )?
            </rhs>
          </production>

          <production id="nb-ns-plain-text">
            <lhs>nb-ns-plain-text</lhs>
            <rhs>
              <lineannotation>chunk of plain text</lineannotation>
              <nonterminal def="#nb-plain-char" />* <nonterminal def="#ns-plain-char" />
            </rhs>
          </production>

          <production id="ns-first-plain-char">
            <lhs>ns-first-plain-char</lhs>
            <rhs>
              <lineannotation>first character in a plain
              scalar</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#ns-plain-char" /><sbr />
              &nbsp;&nbsp;- <nonterminal def="#c-indicators" /> )<sbr />
              | ( ( <nonterminal def="#c-sequence-entry"><quote>-</quote></nonterminal>
              | <nonterminal def="#c-complex-key"><quote>?</quote></nonterminal>
              | <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              | <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal> )<sbr />
              &nbsp;&nbsp;&nbsp;&nbsp;<nonterminal def="#ns-plain-char" /> )
            </rhs>
          </production>

          <production id="nb-plain-top-char">
            <lhs>nb-plain-top-char</lhs>
            <rhs>
              <lineannotation>char allowed in plain scalar used as top level
              value</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#nb-char" />
              - <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              - <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal> )<sbr />
              | ( <nonterminal def="#ns-plain-char" />
              <nonterminal def="#c-throwaway"><quote>#</quote></nonterminal> )<sbr />
              | ( <nonterminal def="#c-mapping-entry"><quote>:</quote></nonterminal>
              <nonterminal def="#ns-plain-char" /> )
            </rhs>
          </production>

          <production id="nb-plain-flow-char">
            <lhs>nb-plain-flow-char</lhs>
            <rhs>
              <lineannotation>char allowed in plain scalar used as value in a
              flow collection</lineannotation>
              &nbsp;&nbsp;( <nonterminal def="#nb-plain-top-char" /><sbr />
              &nbsp;&nbsp;- <nonterminal def="#c-sequence-start"><quote>[</quote></nonterminal>
              - <nonterminal def="#c-sequence-end"><quote>]</quote></nonterminal>
              - <nonterminal def="#c-mapping-start"><quote>{</quote></nonterminal>
              - <nonterminal def="#c-mapping-end"><quote>}</quote></nonterminal>
              - <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal> )<sbr />
              | ( <nonterminal def="#c-collect-entry"><quote>,</quote></nonterminal>
              <nonterminal def="#ns-plain-char" /> )
            </rhs>
          </production>

          <production id="nb-plain-key-char">
            <lhs>nb-plain-key-char</lhs>
            <rhs>
              <lineannotation>char allowed in plain scalar used as
              key</lineannotation>
              <nonterminal def="#nb-plain-flow-char" />
            </rhs>
          </production>

          <production id="nb-plain-char">
            <lhs>nb-plain-char</lhs>
            <rhs>
              <lineannotation>depending whether reached from top, flow or key
              plain scalar production</lineannotation>
              &nbsp;&nbsp;<nonterminal def="#nb-plain-top-char" /><sbr />
              | <nonterminal def="#nb-plain-flow-char" /><sbr />
              | <nonterminal def="#nb-plain-key-char" />
            </rhs>
          </production>

          <production id="ns-plain-char">
            <lhs>ns-plain-char</lhs>
            <rhs>
              <lineannotation>non-space char valid in a plain
              scalar</lineannotation>
              <nonterminal def="#nb-plain-char" /> - <nonterminal def="#s-char" />
            </rhs>
          </production>
        </productionset>

        <example>
<programlisting>
first: There is no unquoted empty string.
second: 12          ## This is an integer.
boolean: n          ## This is false.
third: !str 12      ## This is a string.
span: this contains
      six spaces

      and one
      line break

indicators: this has no comments.
            #:foo and bar# are
            both text.
flow: [ can span
           lines, # comment
             like
           this ]
note: { one-line keys: but
        multi-line values }
</programlisting>
        </example>
      </sect2>
    </sect1>
  </chapter>

  <appendix>
    <title><anchor id="tag-repository" />Tag Repository</title>

    <para>
      Following is a description of the three mandatory core tags. YAML
      requires support for the <link linkend="type-seq">seq</link>, <link
      linkend="type-map">map</link> and <link linkend="type-str">str</link>
      tags. YAML also provides a set of universal tags, that are not
      mandatory, in the YAML tag repository available at <ulink
      url="http://yaml.org/tags.html" />. These tags represent native data
      types in most programming languages, or are useful in a wide range of
      applications. Therefore, applications are strongly encouraged to make
      use of them whenever they are appropriate, in order to improve
      interoperability between YAML systems.
    </para>

    <sect1>
      <title><anchor id="type-seq" />Sequence</title>

      <variablelist>
        <varlistentry>
          <term>URI:</term>
          <listitem><userinput>tag:yaml.org,2002:seq</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Shorthand:</term>
          <listitem><userinput>!seq</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Kind:</term>
          <listitem>Sequence.</listitem>
        </varlistentry>

        <varlistentry>
          <term>Definition:</term>
          <listitem>
            <para>
              Collections indexed by sequential integers starting with zero.
              Example bindings include the Perl array, Python's list or
              tuple, and Java's array or vector.
            </para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Resolution and Validation:</term>

          <listitem>
            This tag accepts all sequence values. It is is typically used as
            the fallback tag for <link
            linkend="syntax-collect-seq">sequence</link> nodes.
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
<programlisting>
# The following are equal seqs
# with different identities.
flow: [ one, two ]
spanning: [ one,
     two ]
block:
  - one
  - two
</programlisting>
      </example>
    </sect1>

    <sect1>
      <title><anchor id="type-map" />Mapping</title>

      <variablelist>
        <varlistentry>
          <term>URI:</term>
          <listitem><userinput>tag:yaml.org,2002:map</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Shorthand:</term>
          <listitem><userinput>!map</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Kind:</term>
          <listitem>Mapping.</listitem>
        </varlistentry>

        <varlistentry>
          <term>Definition:</term>
          <listitem>
            Associative container, where each key is unique in the
            association and mapped to exactly one value. Example bindings
            include the Perl hash, Python's dictionary, and Java's
            Hashtable.
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Resolution and Validation:</term>

          <listitem>
            This tag accepts all mapping values. It is is typically used as
            the fallback tag for <link
            linkend="syntax-collect-map">mapping</link> nodes.
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
<programlisting>
# The following are equal maps
# with different identities.
flow: { one: 1, two: 2 }
block:
    one: 1
    two: 2
</programlisting>
      </example>
    </sect1>

    <sect1>
      <title><anchor id="type-str" />String</title>

      <variablelist>
        <varlistentry>
          <term>URI:</term>
          <listitem><userinput>tag:yaml.org,2002:str</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Shorthand:</term>
          <listitem><userinput>!str</userinput></listitem>
        </varlistentry>

        <varlistentry>
          <term>Kind:</term>
          <listitem>Scalar.</listitem>
        </varlistentry>

        <varlistentry>
          <term>Definition:</term>
          <listitem>
            Unicode strings, a sequence of zero or more Unicode characters.
            This type is usually bound to the native language's string or
            character array construct. Note that generic YAML tools should
            have an immutable (const) interface to such constructs even
            when the language default is mutable (such as in C/C++).
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Canonical Format:</term>
          <listitem>
            N/A (single format).
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Resolution and Validation:</term>

          <listitem>
            This tag accepts all scalar values. It is is typically used as
            the fallback tag for <link
            linkend="syntax-scalar">scalar</link> nodes.
          </listitem>
        </varlistentry>
      </variablelist>

      <example>
<programlisting>
# Assuming an application
# using implicit integers.
- 12     # An integer
# The following scalars
# are loaded to the
# string value '1' '2'.
- !str 12
- '12'
- "12"
- "\
 1\
 2"
# Otherwise, everything is a string:
- /foo/bar
- 192.168.1.1
</programlisting>
      </example>
    </sect1>
  </appendix>

  <appendix>
    <title>YAML Terms</title>

    <para>
      YAML defines a special meaning to the following terms:
    </para>

    <index>
      <title />
    </index>
  </appendix>
</book>
